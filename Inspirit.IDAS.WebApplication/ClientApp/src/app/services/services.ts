/* tslint:disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v11.17.21.0 (NJsonSchema v9.10.63.0 (Newtonsoft.Json v9.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import 'rxjs/add/observable/fromPromise'
import 'rxjs/add/observable/of'
import 'rxjs/add/observable/throw'
import 'rxjs/add/operator/map'
import 'rxjs/add/operator/toPromise'
import 'rxjs/add/operator/mergeMap'
import 'rxjs/add/operator/catch'

import { Observable } from 'rxjs/Observable'
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core'
import {
  HttpClient,
  HttpHeaders,
  HttpResponse,
  HttpResponseBase,
} from '@angular/common/http'

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL')

@Injectable()
export class CompanyService {
  private http: HttpClient
  private baseUrl: string
  protected jsonParseReviver: (key: string, value: any) => any = undefined

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string,
  ) {
    this.http = http
    this.baseUrl = baseUrl ? baseUrl : ''
  }

  getCompanyDetails(request: CompanyRequest): Observable<CompanyProfile> {
    let url_ = this.baseUrl + '/api/Company/action'
    url_ = url_.replace(/[?&]$/, '')

    const content_ = JSON.stringify(request)

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('post', url_, options_)
      .flatMap((response_: any) => {
        return this.processGetCompanyDetails(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processGetCompanyDetails(<any>response_)
          } catch (e) {
            return <Observable<CompanyProfile>>(<any>Observable.throw(e))
          }
        } else
          return <Observable<CompanyProfile>>(<any>Observable.throw(response_))
      })
  }

  protected processGetCompanyDetails(
    response: HttpResponseBase,
  ): Observable<CompanyProfile> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = resultData200
          ? CompanyProfile.fromJS(resultData200)
          : <any>null
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<CompanyProfile>(<any>null)
  }

  getAuditorDetail(auditorId: number): Observable<CommercialAuditorVm> {
    let url_ = this.baseUrl + '/api/Company/action?'
    if (auditorId === undefined || auditorId === null)
      throw new Error(
        "The parameter 'auditorId' must be defined and cannot be null.",
      )
    else url_ += 'AuditorId=' + encodeURIComponent('' + auditorId) + '&'
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('get', url_, options_)
      .flatMap((response_: any) => {
        return this.processGetAuditorDetail(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processGetAuditorDetail(<any>response_)
          } catch (e) {
            return <Observable<CommercialAuditorVm>>(<any>Observable.throw(e))
          }
        } else
          return <Observable<CommercialAuditorVm>>(
            (<any>Observable.throw(response_))
          )
      })
  }

  protected processGetAuditorDetail(
    response: HttpResponseBase,
  ): Observable<CommercialAuditorVm> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = resultData200
          ? CommercialAuditorVm.fromJS(resultData200)
          : <any>null
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<CommercialAuditorVm>(<any>null)
  }
}

@Injectable()
export class BatchTracingService {
  private http: HttpClient
  private baseUrl: string
  protected jsonParseReviver: (key: string, value: any) => any = undefined

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string,
  ) {
    this.http = http
    this.baseUrl = baseUrl ? baseUrl : ''
  }

  addBatchTraces(batchTrace: BatchTrace): Observable<string> {
    let url_ = this.baseUrl + '/api/BatchTracing/AddBatchTraces'
    url_ = url_.replace(/[?&]$/, '')

    const content_ = JSON.stringify(batchTrace)

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('post', url_, options_)
      .flatMap((response_: any) => {
        return this.processAddBatchTraces(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processAddBatchTraces(<any>response_)
          } catch (e) {
            return <Observable<string>>(<any>Observable.throw(e))
          }
        } else return <Observable<string>>(<any>Observable.throw(response_))
      })
  }

  protected processAddBatchTraces(
    response: HttpResponseBase,
  ): Observable<string> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = resultData200 !== undefined ? resultData200 : <any>null
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<string>(<any>null)
  }

  checkBatchProcessConfiguration(customerUserid: string): Observable<string> {
    let url_ =
      this.baseUrl + '/api/BatchTracing/CheckBatchProcessConfiguration?'
    if (customerUserid === undefined || customerUserid === null)
      throw new Error(
        "The parameter 'customerUserid' must be defined and cannot be null.",
      )
    else
      url_ += 'customerUserid=' + encodeURIComponent('' + customerUserid) + '&'
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('get', url_, options_)
      .flatMap((response_: any) => {
        return this.processCheckBatchProcessConfiguration(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processCheckBatchProcessConfiguration(<any>response_)
          } catch (e) {
            return <Observable<string>>(<any>Observable.throw(e))
          }
        } else return <Observable<string>>(<any>Observable.throw(response_))
      })
  }

  protected processCheckBatchProcessConfiguration(
    response: HttpResponseBase,
  ): Observable<string> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = resultData200 !== undefined ? resultData200 : <any>null
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<string>(<any>null)
  }

  view(iD: string): Observable<BatchTrace> {
    let url_ = this.baseUrl + '/api/BatchTracing?'
    if (iD === undefined || iD === null)
      throw new Error("The parameter 'iD' must be defined and cannot be null.")
    else url_ += 'ID=' + encodeURIComponent('' + iD) + '&'
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('post', url_, options_)
      .flatMap((response_: any) => {
        return this.processView(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processView(<any>response_)
          } catch (e) {
            return <Observable<BatchTrace>>(<any>Observable.throw(e))
          }
        } else return <Observable<BatchTrace>>(<any>Observable.throw(response_))
      })
  }

  protected processView(response: HttpResponseBase): Observable<BatchTrace> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = resultData200 ? BatchTrace.fromJS(resultData200) : <any>null
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<BatchTrace>(<any>null)
  }

  removeBatchTrace(iD: string): Observable<string> {
    let url_ = this.baseUrl + '/api/BatchTracing/RemoveBatchTrace?'
    if (iD === undefined || iD === null)
      throw new Error("The parameter 'iD' must be defined and cannot be null.")
    else url_ += 'ID=' + encodeURIComponent('' + iD) + '&'
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('get', url_, options_)
      .flatMap((response_: any) => {
        return this.processRemoveBatchTrace(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processRemoveBatchTrace(<any>response_)
          } catch (e) {
            return <Observable<string>>(<any>Observable.throw(e))
          }
        } else return <Observable<string>>(<any>Observable.throw(response_))
      })
  }

  protected processRemoveBatchTrace(
    response: HttpResponseBase,
  ): Observable<string> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = resultData200 !== undefined ? resultData200 : <any>null
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<string>(<any>null)
  }

  excelValidation(
    filename: string,
    userId: string,
    custId: string,
  ): Observable<BatchTraceServices> {
    let url_ = this.baseUrl + '/api/BatchTracing/ExcelValidation?'
    if (filename === undefined)
      throw new Error("The parameter 'filename' must be defined.")
    else url_ += 'filename=' + encodeURIComponent('' + filename) + '&'
    if (userId === undefined || userId === null)
      throw new Error(
        "The parameter 'userId' must be defined and cannot be null.",
      )
    else url_ += 'UserId=' + encodeURIComponent('' + userId) + '&'
    if (custId === undefined || custId === null)
      throw new Error(
        "The parameter 'custId' must be defined and cannot be null.",
      )
    else url_ += 'CustId=' + encodeURIComponent('' + custId) + '&'
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('get', url_, options_)
      .flatMap((response_: any) => {
        return this.processExcelValidation(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processExcelValidation(<any>response_)
          } catch (e) {
            return <Observable<BatchTraceServices>>(<any>Observable.throw(e))
          }
        } else
          return <Observable<BatchTraceServices>>(
            (<any>Observable.throw(response_))
          )
      })
  }

  protected processExcelValidation(
    response: HttpResponseBase,
  ): Observable<BatchTraceServices> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = resultData200
          ? BatchTraceServices.fromJS(resultData200)
          : <any>null
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<BatchTraceServices>(<any>null)
  }

  fetchingData(
    consumers: string[],
    filename: string,
    customerid: string,
  ): Observable<BatchTraceServices> {
    let url_ = this.baseUrl + '/api/BatchTracing/FetchingData?'
    if (filename === undefined)
      throw new Error("The parameter 'filename' must be defined.")
    else url_ += 'filename=' + encodeURIComponent('' + filename) + '&'
    if (customerid === undefined || customerid === null)
      throw new Error(
        "The parameter 'customerid' must be defined and cannot be null.",
      )
    else url_ += 'customerid=' + encodeURIComponent('' + customerid) + '&'
    url_ = url_.replace(/[?&]$/, '')

    const content_ = JSON.stringify(consumers)

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('post', url_, options_)
      .flatMap((response_: any) => {
        return this.processFetchingData(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processFetchingData(<any>response_)
          } catch (e) {
            return <Observable<BatchTraceServices>>(<any>Observable.throw(e))
          }
        } else
          return <Observable<BatchTraceServices>>(
            (<any>Observable.throw(response_))
          )
      })
  }

  protected processFetchingData(
    response: HttpResponseBase,
  ): Observable<BatchTraceServices> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = resultData200
          ? BatchTraceServices.fromJS(resultData200)
          : <any>null
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<BatchTraceServices>(<any>null)
  }

  preparingChart(batchTrace: BatchTrace): Observable<BatchTraceServices> {
    let url_ = this.baseUrl + '/api/BatchTracing/PreparingChart'
    url_ = url_.replace(/[?&]$/, '')

    const content_ = JSON.stringify(batchTrace)

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('post', url_, options_)
      .flatMap((response_: any) => {
        return this.processPreparingChart(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processPreparingChart(<any>response_)
          } catch (e) {
            return <Observable<BatchTraceServices>>(<any>Observable.throw(e))
          }
        } else
          return <Observable<BatchTraceServices>>(
            (<any>Observable.throw(response_))
          )
      })
  }

  protected processPreparingChart(
    response: HttpResponseBase,
  ): Observable<BatchTraceServices> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = resultData200
          ? BatchTraceServices.fromJS(resultData200)
          : <any>null
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<BatchTraceServices>(<any>null)
  }

  getIdNos(filename: string, userid: string): Observable<string[]> {
    let url_ = this.baseUrl + '/api/BatchTracing/GetIdNos?'
    if (filename === undefined)
      throw new Error("The parameter 'filename' must be defined.")
    else url_ += 'filename=' + encodeURIComponent('' + filename) + '&'
    if (userid === undefined)
      throw new Error("The parameter 'userid' must be defined.")
    else url_ += 'userid=' + encodeURIComponent('' + userid) + '&'
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('get', url_, options_)
      .flatMap((response_: any) => {
        return this.processGetIdNos(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processGetIdNos(<any>response_)
          } catch (e) {
            return <Observable<string[]>>(<any>Observable.throw(e))
          }
        } else return <Observable<string[]>>(<any>Observable.throw(response_))
      })
  }

  protected processGetIdNos(response: HttpResponseBase): Observable<string[]> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        if (resultData200 && resultData200.constructor === Array) {
          result200 = []
          for (let item of resultData200) result200.push(item)
        }
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<string[]>(<any>null)
  }

  getColumns(filename: string, userid: string): Observable<string[]> {
    let url_ = this.baseUrl + '/api/BatchTracing/GetColumns?'
    if (filename === undefined)
      throw new Error("The parameter 'filename' must be defined.")
    else url_ += 'filename=' + encodeURIComponent('' + filename) + '&'
    if (userid === undefined)
      throw new Error("The parameter 'userid' must be defined.")
    else url_ += 'userid=' + encodeURIComponent('' + userid) + '&'
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('get', url_, options_)
      .flatMap((response_: any) => {
        return this.processGetColumns(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processGetColumns(<any>response_)
          } catch (e) {
            return <Observable<string[]>>(<any>Observable.throw(e))
          }
        } else return <Observable<string[]>>(<any>Observable.throw(response_))
      })
  }

  protected processGetColumns(
    response: HttpResponseBase,
  ): Observable<string[]> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        if (resultData200 && resultData200.constructor === Array) {
          result200 = []
          for (let item of resultData200) result200.push(item)
        }
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<string[]>(<any>null)
  }

  uploadFile(): Observable<FileResponse> {
    let url_ = this.baseUrl + '/api/BatchTracing/UploadFile'
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('post', url_, options_)
      .flatMap((response_: any) => {
        return this.processUploadFile(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processUploadFile(<any>response_)
          } catch (e) {
            return <Observable<FileResponse>>(<any>Observable.throw(e))
          }
        } else
          return <Observable<FileResponse>>(<any>Observable.throw(response_))
      })
  }

  protected processUploadFile(
    response: HttpResponseBase,
  ): Observable<FileResponse> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers
        ? response.headers.get('content-disposition')
        : undefined
      const fileNameMatch = contentDisposition
        ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
        : undefined
      const fileName =
        fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined
      return Observable.of({
        fileName: fileName,
        data: <any>responseBlob,
        status: status,
        headers: _headers,
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<FileResponse>(<any>null)
  }

  downloadExcel(id: string): Observable<FileResponse> {
    let url_ = this.baseUrl + '/api/BatchTracing/DownloadExcel?'
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined and cannot be null.")
    else url_ += 'id=' + encodeURIComponent('' + id) + '&'
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('get', url_, options_)
      .flatMap((response_: any) => {
        return this.processDownloadExcel(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processDownloadExcel(<any>response_)
          } catch (e) {
            return <Observable<FileResponse>>(<any>Observable.throw(e))
          }
        } else
          return <Observable<FileResponse>>(<any>Observable.throw(response_))
      })
  }

  protected processDownloadExcel(
    response: HttpResponseBase,
  ): Observable<FileResponse> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers
        ? response.headers.get('content-disposition')
        : undefined
      const fileNameMatch = contentDisposition
        ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
        : undefined
      const fileName =
        fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined
      return Observable.of({
        fileName: fileName,
        data: <any>responseBlob,
        status: status,
        headers: _headers,
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<FileResponse>(<any>null)
  }

  batchTraceServiceList(
    request: BatchTracingServiceRequest,
  ): Observable<BatchTraceServiceResponse> {
    let url_ = this.baseUrl + '/api/BatchTracing/BatchTraceServiceList'
    url_ = url_.replace(/[?&]$/, '')

    const content_ = JSON.stringify(request)

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('post', url_, options_)
      .flatMap((response_: any) => {
        return this.processBatchTraceServiceList(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processBatchTraceServiceList(<any>response_)
          } catch (e) {
            return <Observable<BatchTraceServiceResponse>>(
              (<any>Observable.throw(e))
            )
          }
        } else
          return <Observable<BatchTraceServiceResponse>>(
            (<any>Observable.throw(response_))
          )
      })
  }

  protected processBatchTraceServiceList(
    response: HttpResponseBase,
  ): Observable<BatchTraceServiceResponse> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = resultData200
          ? BatchTraceServiceResponse.fromJS(resultData200)
          : <any>null
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<BatchTraceServiceResponse>(<any>null)
  }
  // pending verification
  getPoints(userId: string, customerId: string): Observable<number> {
    let url_ = this.baseUrl + '/api/BatchTracing/GetPoints?'
    if (customerId === undefined || customerId === null)
      throw new Error(
        "The parameter 'customerId' must be defined and cannot be null.",
      )
    else url_ += 'customerId=' + encodeURIComponent('' + customerId) + '&'
    url_ = url_.replace(/[?&]$/, '')

    const content_ = JSON.stringify(userId)

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('post', url_, options_)
      .flatMap((response_: any) => {
        return this.processGetPoints(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processGetPoints(<any>response_)
          } catch (e) {
            return <Observable<number>>(<any>Observable.throw(e))
          }
        } else return <Observable<number>>(<any>Observable.throw(response_))
      })
  }

  protected processGetPoints(response: HttpResponseBase): Observable<number> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = resultData200 !== undefined ? resultData200 : <any>null
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<number>(<any>null)
  }

  generateProformaInvoice(
    userId: string,
    batchId: string,
  ): Observable<InvoiceGenResponse> {
    let url_ = this.baseUrl + '/api/BatchTracing/GenerateProformaInvoice?'
    if (batchId === undefined || batchId === null)
      throw new Error(
        "The parameter 'batchId' must be defined and cannot be null.",
      )
    else url_ += 'batchId=' + encodeURIComponent('' + batchId) + '&'
    url_ = url_.replace(/[?&]$/, '')

    const content_ = JSON.stringify(userId)

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('post', url_, options_)
      .flatMap((response_: any) => {
        return this.processGenerateProformaInvoice(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processGenerateProformaInvoice(<any>response_)
          } catch (e) {
            return <Observable<InvoiceGenResponse>>(<any>Observable.throw(e))
          }
        } else
          return <Observable<InvoiceGenResponse>>(
            (<any>Observable.throw(response_))
          )
      })
  }

  protected processGenerateProformaInvoice(
    response: HttpResponseBase,
  ): Observable<InvoiceGenResponse> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = resultData200
          ? InvoiceGenResponse.fromJS(resultData200)
          : <any>null
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<InvoiceGenResponse>(<any>null)
  }
}

@Injectable()
export class FullAuditReportService {
  private http: HttpClient
  private baseUrl: string
  protected jsonParseReviver: (key: string, value: any) => any = undefined

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string,
  ) {
    this.http = http
    this.baseUrl = baseUrl ? baseUrl : ''
  }

  fullAuditDataList(
    request: FullAuditSearchRequest,
  ): Observable<FullAuditDataResponse> {
    let url_ = this.baseUrl + '/api/FullAuditReport/FullAuditDataList'
    url_ = url_.replace(/[?&]$/, '')

    const content_ = JSON.stringify(request)

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('post', url_, options_)
      .flatMap((response_: any) => {
        return this.processFullAuditDataList(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processFullAuditDataList(<any>response_)
          } catch (e) {
            return <Observable<FullAuditDataResponse>>(<any>Observable.throw(e))
          }
        } else
          return <Observable<FullAuditDataResponse>>(
            (<any>Observable.throw(response_))
          )
      })
  }

  protected processFullAuditDataList(
    response: HttpResponseBase,
  ): Observable<FullAuditDataResponse> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = resultData200
          ? FullAuditDataResponse.fromJS(resultData200)
          : <any>null
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<FullAuditDataResponse>(<any>null)
  }

  view(id: string): Observable<CustomerLog> {
    let url_ = this.baseUrl + '/api/FullAuditReport/View?'
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined and cannot be null.")
    else url_ += 'id=' + encodeURIComponent('' + id) + '&'
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('post', url_, options_)
      .flatMap((response_: any) => {
        return this.processView(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processView(<any>response_)
          } catch (e) {
            return <Observable<CustomerLog>>(<any>Observable.throw(e))
          }
        } else
          return <Observable<CustomerLog>>(<any>Observable.throw(response_))
      })
  }

  protected processView(response: HttpResponseBase): Observable<CustomerLog> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = resultData200
          ? CustomerLog.fromJS(resultData200)
          : <any>null
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<CustomerLog>(<any>null)
  }
}

@Injectable()
export class InvoiceService {
  private http: HttpClient
  private baseUrl: string
  protected jsonParseReviver: (key: string, value: any) => any = undefined

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string,
  ) {
    this.http = http
    this.baseUrl = baseUrl ? baseUrl : ''
  }

  invoiceDataList(
    request: InvDataTableRequest,
  ): Observable<InvoiceDataResponse> {
    let url_ = this.baseUrl + '/api/Invoice/InvoiceDataList'
    url_ = url_.replace(/[?&]$/, '')

    const content_ = JSON.stringify(request)

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('post', url_, options_)
      .flatMap((response_: any) => {
        return this.processInvoiceDataList(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processInvoiceDataList(<any>response_)
          } catch (e) {
            return <Observable<InvoiceDataResponse>>(<any>Observable.throw(e))
          }
        } else
          return <Observable<InvoiceDataResponse>>(
            (<any>Observable.throw(response_))
          )
      })
  }

  protected processInvoiceDataList(
    response: HttpResponseBase,
  ): Observable<InvoiceDataResponse> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = resultData200
          ? InvoiceDataResponse.fromJS(resultData200)
          : <any>null
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<InvoiceDataResponse>(<any>null)
  }

  invoiceDataListdata(id: string): Observable<InvoiceVm> {
    let url_ = this.baseUrl + '/api/Invoice/InvoiceDataListdata?'
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined and cannot be null.")
    else url_ += 'id=' + encodeURIComponent('' + id) + '&'
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('get', url_, options_)
      .flatMap((response_: any) => {
        return this.processInvoiceDataListdata(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processInvoiceDataListdata(<any>response_)
          } catch (e) {
            return <Observable<InvoiceVm>>(<any>Observable.throw(e))
          }
        } else return <Observable<InvoiceVm>>(<any>Observable.throw(response_))
      })
  }

  protected processInvoiceDataListdata(
    response: HttpResponseBase,
  ): Observable<InvoiceVm> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = resultData200 ? InvoiceVm.fromJS(resultData200) : <any>null
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<InvoiceVm>(<any>null)
  }

  view(id: string): Observable<Invoice> {
    let url_ = this.baseUrl + '/api/Invoice/View?'
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined and cannot be null.")
    else url_ += 'id=' + encodeURIComponent('' + id) + '&'
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('post', url_, options_)
      .flatMap((response_: any) => {
        return this.processView(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processView(<any>response_)
          } catch (e) {
            return <Observable<Invoice>>(<any>Observable.throw(e))
          }
        } else return <Observable<Invoice>>(<any>Observable.throw(response_))
      })
  }

  protected processView(response: HttpResponseBase): Observable<Invoice> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = resultData200 ? Invoice.fromJS(resultData200) : <any>null
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<Invoice>(<any>null)
  }

  insert(request: Invoice): Observable<InvoiceCrudResponses> {
    let url_ = this.baseUrl + '/api/Invoice/Insert'
    url_ = url_.replace(/[?&]$/, '')

    const content_ = JSON.stringify(request)

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('post', url_, options_)
      .flatMap((response_: any) => {
        return this.processInsert(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processInsert(<any>response_)
          } catch (e) {
            return <Observable<InvoiceCrudResponses>>(<any>Observable.throw(e))
          }
        } else
          return <Observable<InvoiceCrudResponses>>(
            (<any>Observable.throw(response_))
          )
      })
  }

  protected processInsert(
    response: HttpResponseBase,
  ): Observable<InvoiceCrudResponses> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = resultData200
          ? InvoiceCrudResponses.fromJS(resultData200)
          : <any>null
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<InvoiceCrudResponses>(<any>null)
  }

  createPayment(invoiceId: string): Observable<PaymentResponse> {
    let url_ = this.baseUrl + '/api/Invoice/CreatePayment'
    url_ = url_.replace(/[?&]$/, '')

    const content_ = JSON.stringify(invoiceId)

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('post', url_, options_)
      .flatMap((response_: any) => {
        return this.processCreatePayment(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processCreatePayment(<any>response_)
          } catch (e) {
            return <Observable<PaymentResponse>>(<any>Observable.throw(e))
          }
        } else
          return <Observable<PaymentResponse>>(<any>Observable.throw(response_))
      })
  }

  protected processCreatePayment(
    response: HttpResponseBase,
  ): Observable<PaymentResponse> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = resultData200
          ? PaymentResponse.fromJS(resultData200)
          : <any>null
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<PaymentResponse>(<any>null)
  }

  getCustomers(): Observable<Customer[]> {
    let url_ = this.baseUrl + '/api/Invoice/GetCustomers'
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('get', url_, options_)
      .flatMap((response_: any) => {
        return this.processGetCustomers(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processGetCustomers(<any>response_)
          } catch (e) {
            return <Observable<Customer[]>>(<any>Observable.throw(e))
          }
        } else return <Observable<Customer[]>>(<any>Observable.throw(response_))
      })
  }

  protected processGetCustomers(
    response: HttpResponseBase,
  ): Observable<Customer[]> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        if (resultData200 && resultData200.constructor === Array) {
          result200 = []
          for (let item of resultData200) result200.push(Customer.fromJS(item))
        }
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<Customer[]>(<any>null)
  }

  getProducts(): Observable<ProductVm[]> {
    let url_ = this.baseUrl + '/api/Invoice/GetProducts'
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('get', url_, options_)
      .flatMap((response_: any) => {
        return this.processGetProducts(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processGetProducts(<any>response_)
          } catch (e) {
            return <Observable<ProductVm[]>>(<any>Observable.throw(e))
          }
        } else
          return <Observable<ProductVm[]>>(<any>Observable.throw(response_))
      })
  }

  protected processGetProducts(
    response: HttpResponseBase,
  ): Observable<ProductVm[]> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        if (resultData200 && resultData200.constructor === Array) {
          result200 = []
          for (let item of resultData200) result200.push(ProductVm.fromJS(item))
        }
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<ProductVm[]>(<any>null)
  }

  getProductRates(id: string): Observable<ProductPackageRate[]> {
    let url_ = this.baseUrl + '/api/Invoice/GetProductRates?'
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined and cannot be null.")
    else url_ += 'Id=' + encodeURIComponent('' + id) + '&'
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('get', url_, options_)
      .flatMap((response_: any) => {
        return this.processGetProductRates(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processGetProductRates(<any>response_)
          } catch (e) {
            return <Observable<ProductPackageRate[]>>(<any>Observable.throw(e))
          }
        } else
          return <Observable<ProductPackageRate[]>>(
            (<any>Observable.throw(response_))
          )
      })
  }

  protected processGetProductRates(
    response: HttpResponseBase,
  ): Observable<ProductPackageRate[]> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        if (resultData200 && resultData200.constructor === Array) {
          result200 = []
          for (let item of resultData200)
            result200.push(ProductPackageRate.fromJS(item))
        }
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<ProductPackageRate[]>(<any>null)
  }

  productRate(id: string): Observable<ProductPackageRate> {
    let url_ = this.baseUrl + '/api/Invoice/productRate?'
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined and cannot be null.")
    else url_ += 'id=' + encodeURIComponent('' + id) + '&'
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('get', url_, options_)
      .flatMap((response_: any) => {
        return this.processProductRate(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processProductRate(<any>response_)
          } catch (e) {
            return <Observable<ProductPackageRate>>(<any>Observable.throw(e))
          }
        } else
          return <Observable<ProductPackageRate>>(
            (<any>Observable.throw(response_))
          )
      })
  }

  protected processProductRate(
    response: HttpResponseBase,
  ): Observable<ProductPackageRate> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = resultData200
          ? ProductPackageRate.fromJS(resultData200)
          : <any>null
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<ProductPackageRate>(<any>null)
  }
}

@Injectable()
export class NewsService {
  private http: HttpClient
  private baseUrl: string
  protected jsonParseReviver: (key: string, value: any) => any = undefined

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string,
  ) {
    this.http = http
    this.baseUrl = baseUrl ? baseUrl : ''
  }

  newsBlogDetail(id: string): Observable<FileResponse> {
    let url_ = this.baseUrl + '/News/NewsBlogDetail?'
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined and cannot be null.")
    else url_ += 'Id=' + encodeURIComponent('' + id) + '&'
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('get', url_, options_)
      .flatMap((response_: any) => {
        return this.processNewsBlogDetail(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processNewsBlogDetail(<any>response_)
          } catch (e) {
            return <Observable<FileResponse>>(<any>Observable.throw(e))
          }
        } else
          return <Observable<FileResponse>>(<any>Observable.throw(response_))
      })
  }

  protected processNewsBlogDetail(
    response: HttpResponseBase,
  ): Observable<FileResponse> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers
        ? response.headers.get('content-disposition')
        : undefined
      const fileNameMatch = contentDisposition
        ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
        : undefined
      const fileName =
        fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined
      return Observable.of({
        fileName: fileName,
        data: <any>responseBlob,
        status: status,
        headers: _headers,
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<FileResponse>(<any>null)
  }

  getKeywordDetails(key: string): Observable<FileResponse> {
    let url_ = this.baseUrl + '/News/GetKeywordDetails?'
    if (key === undefined)
      throw new Error("The parameter 'key' must be defined.")
    else url_ += 'key=' + encodeURIComponent('' + key) + '&'
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('get', url_, options_)
      .flatMap((response_: any) => {
        return this.processGetKeywordDetails(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processGetKeywordDetails(<any>response_)
          } catch (e) {
            return <Observable<FileResponse>>(<any>Observable.throw(e))
          }
        } else
          return <Observable<FileResponse>>(<any>Observable.throw(response_))
      })
  }

  protected processGetKeywordDetails(
    response: HttpResponseBase,
  ): Observable<FileResponse> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers
        ? response.headers.get('content-disposition')
        : undefined
      const fileNameMatch = contentDisposition
        ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
        : undefined
      const fileName =
        fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined
      return Observable.of({
        fileName: fileName,
        data: <any>responseBlob,
        status: status,
        headers: _headers,
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<FileResponse>(<any>null)
  }
}

@Injectable()
export class ProductsService {
  private http: HttpClient
  private baseUrl: string
  protected jsonParseReviver: (key: string, value: any) => any = undefined

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string,
  ) {
    this.http = http
    this.baseUrl = baseUrl ? baseUrl : ''
  }

  home(): Observable<FileResponse> {
    let url_ = this.baseUrl + '/api/Products'
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('post', url_, options_)
      .flatMap((response_: any) => {
        return this.processHome(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processHome(<any>response_)
          } catch (e) {
            return <Observable<FileResponse>>(<any>Observable.throw(e))
          }
        } else
          return <Observable<FileResponse>>(<any>Observable.throw(response_))
      })
  }

  protected processHome(response: HttpResponseBase): Observable<FileResponse> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers
        ? response.headers.get('content-disposition')
        : undefined
      const fileNameMatch = contentDisposition
        ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
        : undefined
      const fileName =
        fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined
      return Observable.of({
        fileName: fileName,
        data: <any>responseBlob,
        status: status,
        headers: _headers,
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<FileResponse>(<any>null)
  }

  getProducts(): Observable<FileResponse> {
    let url_ = this.baseUrl + '/api/Products'
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('get', url_, options_)
      .flatMap((response_: any) => {
        return this.processGetProducts(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processGetProducts(<any>response_)
          } catch (e) {
            return <Observable<FileResponse>>(<any>Observable.throw(e))
          }
        } else
          return <Observable<FileResponse>>(<any>Observable.throw(response_))
      })
  }

  protected processGetProducts(
    response: HttpResponseBase,
  ): Observable<FileResponse> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers
        ? response.headers.get('content-disposition')
        : undefined
      const fileNameMatch = contentDisposition
        ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
        : undefined
      const fileName =
        fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined
      return Observable.of({
        fileName: fileName,
        data: <any>responseBlob,
        status: status,
        headers: _headers,
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<FileResponse>(<any>null)
  }
}

@Injectable()
export class SubscriptionService {
  private http: HttpClient
  private baseUrl: string
  protected jsonParseReviver: (key: string, value: any) => any = undefined

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string,
  ) {
    this.http = http
    this.baseUrl = baseUrl ? baseUrl : ''
  }

  getServices(): Observable<ProductPackageRate[]> {
    let url_ = this.baseUrl + '/api/Subscription/GetServices'
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('post', url_, options_)
      .flatMap((response_: any) => {
        return this.processGetServices(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processGetServices(<any>response_)
          } catch (e) {
            return <Observable<ProductPackageRate[]>>(<any>Observable.throw(e))
          }
        } else
          return <Observable<ProductPackageRate[]>>(
            (<any>Observable.throw(response_))
          )
      })
  }

  protected processGetServices(
    response: HttpResponseBase,
  ): Observable<ProductPackageRate[]> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        if (resultData200 && resultData200.constructor === Array) {
          result200 = []
          for (let item of resultData200)
            result200.push(ProductPackageRate.fromJS(item))
        }
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<ProductPackageRate[]>(<any>null)
  }

  getSubscribtionUsers(guid: string): Observable<SubscriptionLicenceVm[]> {
    let url_ = this.baseUrl + '/api/Subscription/GetSubscribtionUsers?'
    if (guid === undefined || guid === null)
      throw new Error(
        "The parameter 'guid' must be defined and cannot be null.",
      )
    else url_ += 'guid=' + encodeURIComponent('' + guid) + '&'
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('get', url_, options_)
      .flatMap((response_: any) => {
        return this.processGetSubscribtionUsers(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processGetSubscribtionUsers(<any>response_)
          } catch (e) {
            return <Observable<SubscriptionLicenceVm[]>>(
              (<any>Observable.throw(e))
            )
          }
        } else
          return <Observable<SubscriptionLicenceVm[]>>(
            (<any>Observable.throw(response_))
          )
      })
  }

  protected processGetSubscribtionUsers(
    response: HttpResponseBase,
  ): Observable<SubscriptionLicenceVm[]> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        if (resultData200 && resultData200.constructor === Array) {
          result200 = []
          for (let item of resultData200)
            result200.push(SubscriptionLicenceVm.fromJS(item))
        }
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<SubscriptionLicenceVm[]>(<any>null)
  }

  assignLicensetoUsers(
    subscriptionLicenceRequest: SubscriptionLicenceRequest,
  ): Observable<string> {
    let url_ = this.baseUrl + '/api/Subscription/AssignLicensetoUsers'
    url_ = url_.replace(/[?&]$/, '')

    const content_ = JSON.stringify(subscriptionLicenceRequest)

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('post', url_, options_)
      .flatMap((response_: any) => {
        return this.processAssignLicensetoUsers(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processAssignLicensetoUsers(<any>response_)
          } catch (e) {
            return <Observable<string>>(<any>Observable.throw(e))
          }
        } else return <Observable<string>>(<any>Observable.throw(response_))
      })
  }

  protected processAssignLicensetoUsers(
    response: HttpResponseBase,
  ): Observable<string> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = resultData200 !== undefined ? resultData200 : <any>null
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<string>(<any>null)
  }

  getData(): Observable<ProductsVm[]> {
    let url_ = this.baseUrl + '/api/Subscription/GetData'
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('post', url_, options_)
      .flatMap((response_: any) => {
        return this.processGetData(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processGetData(<any>response_)
          } catch (e) {
            return <Observable<ProductsVm[]>>(<any>Observable.throw(e))
          }
        } else
          return <Observable<ProductsVm[]>>(<any>Observable.throw(response_))
      })
  }

  protected processGetData(
    response: HttpResponseBase,
  ): Observable<ProductsVm[]> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        if (resultData200 && resultData200.constructor === Array) {
          result200 = []
          for (let item of resultData200)
            result200.push(ProductsVm.fromJS(item))
        }
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<ProductsVm[]>(<any>null)
  }

  addSubscription(products: ProductsVm, customerId: string): Observable<void> {
    let url_ = this.baseUrl + '/api/Subscription/AddSubscription?'
    if (customerId === undefined || customerId === null)
      throw new Error(
        "The parameter 'customerId' must be defined and cannot be null.",
      )
    else url_ += 'customerId=' + encodeURIComponent('' + customerId) + '&'
    url_ = url_.replace(/[?&]$/, '')

    const content_ = JSON.stringify(products)

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    }

    return this.http
      .request('post', url_, options_)
      .flatMap((response_: any) => {
        return this.processAddSubscription(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processAddSubscription(<any>response_)
          } catch (e) {
            return <Observable<void>>(<any>Observable.throw(e))
          }
        } else return <Observable<void>>(<any>Observable.throw(response_))
      })
  }

  protected processAddSubscription(
    response: HttpResponseBase,
  ): Observable<void> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return Observable.of<void>(<any>null)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<void>(<any>null)
  }

  getSubscriptionList(
    request: SubDataTableRequest,
  ): Observable<SubscriptionDataTableRespone> {
    let url_ = this.baseUrl + '/api/Subscription/GetSubscriptionList'
    url_ = url_.replace(/[?&]$/, '')

    const content_ = JSON.stringify(request)

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('post', url_, options_)
      .flatMap((response_: any) => {
        return this.processGetSubscriptionList(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processGetSubscriptionList(<any>response_)
          } catch (e) {
            return <Observable<SubscriptionDataTableRespone>>(
              (<any>Observable.throw(e))
            )
          }
        } else
          return <Observable<SubscriptionDataTableRespone>>(
            (<any>Observable.throw(response_))
          )
      })
  }

  protected processGetSubscriptionList(
    response: HttpResponseBase,
  ): Observable<SubscriptionDataTableRespone> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = resultData200
          ? SubscriptionDataTableRespone.fromJS(resultData200)
          : <any>null
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<SubscriptionDataTableRespone>(<any>null)
  }

  getProductList(id: string): Observable<ProductPackageRate[]> {
    let url_ = this.baseUrl + '/api/Subscription/GetProductList?'
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined and cannot be null.")
    else url_ += 'id=' + encodeURIComponent('' + id) + '&'
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('get', url_, options_)
      .flatMap((response_: any) => {
        return this.processGetProductList(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processGetProductList(<any>response_)
          } catch (e) {
            return <Observable<ProductPackageRate[]>>(<any>Observable.throw(e))
          }
        } else
          return <Observable<ProductPackageRate[]>>(
            (<any>Observable.throw(response_))
          )
      })
  }

  protected processGetProductList(
    response: HttpResponseBase,
  ): Observable<ProductPackageRate[]> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        if (resultData200 && resultData200.constructor === Array) {
          result200 = []
          for (let item of resultData200)
            result200.push(ProductPackageRate.fromJS(item))
        }
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<ProductPackageRate[]>(<any>null)
  }

  getSubscription(id: string): Observable<SubscriptionVm> {
    let url_ = this.baseUrl + '/api/Subscription/GetSubscription?'
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined and cannot be null.")
    else url_ += 'id=' + encodeURIComponent('' + id) + '&'
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('get', url_, options_)
      .flatMap((response_: any) => {
        return this.processGetSubscription(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processGetSubscription(<any>response_)
          } catch (e) {
            return <Observable<SubscriptionVm>>(<any>Observable.throw(e))
          }
        } else
          return <Observable<SubscriptionVm>>(<any>Observable.throw(response_))
      })
  }

  protected processGetSubscription(
    response: HttpResponseBase,
  ): Observable<SubscriptionVm> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = resultData200
          ? SubscriptionVm.fromJS(resultData200)
          : <any>null
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<SubscriptionVm>(<any>null)
  }
}

@Injectable()
export class SummaryFullAuditService {
  private http: HttpClient
  private baseUrl: string
  protected jsonParseReviver: (key: string, value: any) => any = undefined

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string,
  ) {
    this.http = http
    this.baseUrl = baseUrl ? baseUrl : ''
  }

  summaryAuditDataList(
    request: SummaryAuditSearchRequest,
  ): Observable<SummaryAuditDataResponse> {
    let url_ = this.baseUrl + '/api/SummaryFullAudit/SummaryAuditDataList'
    url_ = url_.replace(/[?&]$/, '')

    const content_ = JSON.stringify(request)

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('post', url_, options_)
      .flatMap((response_: any) => {
        return this.processSummaryAuditDataList(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processSummaryAuditDataList(<any>response_)
          } catch (e) {
            return <Observable<SummaryAuditDataResponse>>(
              (<any>Observable.throw(e))
            )
          }
        } else
          return <Observable<SummaryAuditDataResponse>>(
            (<any>Observable.throw(response_))
          )
      })
  }

  protected processSummaryAuditDataList(
    response: HttpResponseBase,
  ): Observable<SummaryAuditDataResponse> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = resultData200
          ? SummaryAuditDataResponse.fromJS(resultData200)
          : <any>null
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<SummaryAuditDataResponse>(<any>null)
  }

  view(id: string): Observable<CustomerLog> {
    let url_ = this.baseUrl + '/api/SummaryFullAudit/View?'
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined and cannot be null.")
    else url_ += 'id=' + encodeURIComponent('' + id) + '&'
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('post', url_, options_)
      .flatMap((response_: any) => {
        return this.processView(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processView(<any>response_)
          } catch (e) {
            return <Observable<CustomerLog>>(<any>Observable.throw(e))
          }
        } else
          return <Observable<CustomerLog>>(<any>Observable.throw(response_))
      })
  }

  protected processView(response: HttpResponseBase): Observable<CustomerLog> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = resultData200
          ? CustomerLog.fromJS(resultData200)
          : <any>null
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<CustomerLog>(<any>null)
  }
}

@Injectable()
export class UserService {
  private http: HttpClient
  private baseUrl: string
  protected jsonParseReviver: (key: string, value: any) => any = undefined

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string,
  ) {
    this.http = http
    this.baseUrl = baseUrl ? baseUrl : ''
  }

  userList(request: UserDataTableRequest): Observable<UserResponse> {
    let url_ = this.baseUrl + '/api/User/UserList'
    url_ = url_.replace(/[?&]$/, '')

    const content_ = JSON.stringify(request)

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('post', url_, options_)
      .flatMap((response_: any) => {
        return this.processUserList(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processUserList(<any>response_)
          } catch (e) {
            return <Observable<UserResponse>>(<any>Observable.throw(e))
          }
        } else
          return <Observable<UserResponse>>(<any>Observable.throw(response_))
      })
  }

  protected processUserList(
    response: HttpResponseBase,
  ): Observable<UserResponse> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = resultData200
          ? UserResponse.fromJS(resultData200)
          : <any>null
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<UserResponse>(<any>null)
  }

  insert(request: CustomerUser): Observable<CrudUserResponse> {
    let url_ = this.baseUrl + '/api/User/Insert'
    url_ = url_.replace(/[?&]$/, '')

    const content_ = JSON.stringify(request)

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('post', url_, options_)
      .flatMap((response_: any) => {
        return this.processInsert(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processInsert(<any>response_)
          } catch (e) {
            return <Observable<CrudUserResponse>>(<any>Observable.throw(e))
          }
        } else
          return <Observable<CrudUserResponse>>(
            (<any>Observable.throw(response_))
          )
      })
  }

  protected processInsert(
    response: HttpResponseBase,
  ): Observable<CrudUserResponse> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = resultData200
          ? CrudUserResponse.fromJS(resultData200)
          : <any>null
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<CrudUserResponse>(<any>null)
  }

  update(request: CustomerUser): Observable<CrudUserResponse> {
    let url_ = this.baseUrl + '/api/User/Update'
    url_ = url_.replace(/[?&]$/, '')

    const content_ = JSON.stringify(request)

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('post', url_, options_)
      .flatMap((response_: any) => {
        return this.processUpdate(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processUpdate(<any>response_)
          } catch (e) {
            return <Observable<CrudUserResponse>>(<any>Observable.throw(e))
          }
        } else
          return <Observable<CrudUserResponse>>(
            (<any>Observable.throw(response_))
          )
      })
  }

  protected processUpdate(
    response: HttpResponseBase,
  ): Observable<CrudUserResponse> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = resultData200
          ? CrudUserResponse.fromJS(resultData200)
          : <any>null
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<CrudUserResponse>(<any>null)
  }

  delete(id: string): Observable<CrudUserResponse> {
    let url_ = this.baseUrl + '/api/User/Delete?'
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined and cannot be null.")
    else url_ += 'id=' + encodeURIComponent('' + id) + '&'
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('post', url_, options_)
      .flatMap((response_: any) => {
        return this.processDelete(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processDelete(<any>response_)
          } catch (e) {
            return <Observable<CrudUserResponse>>(<any>Observable.throw(e))
          }
        } else
          return <Observable<CrudUserResponse>>(
            (<any>Observable.throw(response_))
          )
      })
  }

  protected processDelete(
    response: HttpResponseBase,
  ): Observable<CrudUserResponse> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = resultData200
          ? CrudUserResponse.fromJS(resultData200)
          : <any>null
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<CrudUserResponse>(<any>null)
  }

  view(id: string): Observable<CustomerUser> {
    let url_ = this.baseUrl + '/api/User/View?'
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined and cannot be null.")
    else url_ += 'id=' + encodeURIComponent('' + id) + '&'
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('post', url_, options_)
      .flatMap((response_: any) => {
        return this.processView(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processView(<any>response_)
          } catch (e) {
            return <Observable<CustomerUser>>(<any>Observable.throw(e))
          }
        } else
          return <Observable<CustomerUser>>(<any>Observable.throw(response_))
      })
  }

  protected processView(response: HttpResponseBase): Observable<CustomerUser> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = resultData200
          ? CustomerUser.fromJS(resultData200)
          : <any>null
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<CustomerUser>(<any>null)
  }
}

@Injectable()
export class DashboardService {
  private http: HttpClient
  private baseUrl: string
  protected jsonParseReviver: (key: string, value: any) => any = undefined

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string,
  ) {
    this.http = http
    this.baseUrl = baseUrl ? baseUrl : ''
  }

  getData(): Observable<DashboardVm[]> {
    let url_ = this.baseUrl + '/api/Dashboard/action'
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('get', url_, options_)
      .flatMap((response_: any) => {
        return this.processGetData(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processGetData(<any>response_)
          } catch (e) {
            return <Observable<DashboardVm[]>>(<any>Observable.throw(e))
          }
        } else
          return <Observable<DashboardVm[]>>(<any>Observable.throw(response_))
      })
  }

  protected processGetData(
    response: HttpResponseBase,
  ): Observable<DashboardVm[]> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        if (resultData200 && resultData200.constructor === Array) {
          result200 = []
          for (let item of resultData200)
            result200.push(DashboardVm.fromJS(item))
        }
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<DashboardVm[]>(<any>null)
  }
}

@Injectable()
export class LeadGenerationService {
  private http: HttpClient
  private baseUrl: string
  protected jsonParseReviver: (key: string, value: any) => any = undefined

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string,
  ) {
    this.http = http
    this.baseUrl = baseUrl ? baseUrl : ''
  }

  getLeadList(req: DatatableLeadRequest): Observable<LeadsDatatableResponse> {
    let url_ = this.baseUrl + '/api/LeadGeneration/GetLeadList'
    url_ = url_.replace(/[?&]$/, '')

    const content_ = JSON.stringify(req)

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('post', url_, options_)
      .flatMap((response_: any) => {
        return this.processGetLeadList(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processGetLeadList(<any>response_)
          } catch (e) {
            return <Observable<LeadsDatatableResponse>>(
              (<any>Observable.throw(e))
            )
          }
        } else
          return <Observable<LeadsDatatableResponse>>(
            (<any>Observable.throw(response_))
          )
      })
  }

  protected processGetLeadList(
    response: HttpResponseBase,
  ): Observable<LeadsDatatableResponse> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = resultData200
          ? LeadsDatatableResponse.fromJS(resultData200)
          : <any>null
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<LeadsDatatableResponse>(<any>null)
  }

  getLeadsCount(request: LeadsRequest): Observable<LeadGenerationResponse> {
    let url_ = this.baseUrl + '/api/LeadGeneration/GetLeadsCount'
    url_ = url_.replace(/[?&]$/, '')

    const content_ = JSON.stringify(request)

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('post', url_, options_)
      .flatMap((response_: any) => {
        return this.processGetLeadsCount(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processGetLeadsCount(<any>response_)
          } catch (e) {
            return <Observable<LeadGenerationResponse>>(
              (<any>Observable.throw(e))
            )
          }
        } else
          return <Observable<LeadGenerationResponse>>(
            (<any>Observable.throw(response_))
          )
      })
  }

  protected processGetLeadsCount(
    response: HttpResponseBase,
  ): Observable<LeadGenerationResponse> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = resultData200
          ? LeadGenerationResponse.fromJS(resultData200)
          : <any>null
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<LeadGenerationResponse>(<any>null)
  }

  cancelLead(iD: string): Observable<string> {
    let url_ = this.baseUrl + '/api/LeadGeneration/CancelLead?'
    if (iD === undefined || iD === null)
      throw new Error("The parameter 'iD' must be defined and cannot be null.")
    else url_ += 'ID=' + encodeURIComponent('' + iD) + '&'
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('get', url_, options_)
      .flatMap((response_: any) => {
        return this.processCancelLead(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processCancelLead(<any>response_)
          } catch (e) {
            return <Observable<string>>(<any>Observable.throw(e))
          }
        } else return <Observable<string>>(<any>Observable.throw(response_))
      })
  }

  protected processCancelLead(response: HttpResponseBase): Observable<string> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = resultData200 !== undefined ? resultData200 : <any>null
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<string>(<any>null)
  }

  generateProformaInvoice(
    userId: string,
    leadId: string,
  ): Observable<InvoiceGenResponse> {
    let url_ = this.baseUrl + '/api/LeadGeneration/GenerateProformaInvoice?'
    if (leadId === undefined || leadId === null)
      throw new Error(
        "The parameter 'leadId' must be defined and cannot be null.",
      )
    else url_ += 'LeadId=' + encodeURIComponent('' + leadId) + '&'
    url_ = url_.replace(/[?&]$/, '')

    const content_ = JSON.stringify(userId)

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('post', url_, options_)
      .flatMap((response_: any) => {
        return this.processGenerateProformaInvoice(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processGenerateProformaInvoice(<any>response_)
          } catch (e) {
            return <Observable<InvoiceGenResponse>>(<any>Observable.throw(e))
          }
        } else
          return <Observable<InvoiceGenResponse>>(
            (<any>Observable.throw(response_))
          )
      })
  }

  protected processGenerateProformaInvoice(
    response: HttpResponseBase,
  ): Observable<InvoiceGenResponse> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = resultData200
          ? InvoiceGenResponse.fromJS(resultData200)
          : <any>null
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<InvoiceGenResponse>(<any>null)
  }

  checkLeadConfig(customerUserid: string): Observable<string> {
    let url_ = this.baseUrl + '/api/LeadGeneration/CheckLeadConfig?'
    if (customerUserid === undefined || customerUserid === null)
      throw new Error(
        "The parameter 'customerUserid' must be defined and cannot be null.",
      )
    else
      url_ += 'customerUserid=' + encodeURIComponent('' + customerUserid) + '&'
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('get', url_, options_)
      .flatMap((response_: any) => {
        return this.processCheckLeadConfig(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processCheckLeadConfig(<any>response_)
          } catch (e) {
            return <Observable<string>>(<any>Observable.throw(e))
          }
        } else return <Observable<string>>(<any>Observable.throw(response_))
      })
  }

  protected processCheckLeadConfig(
    response: HttpResponseBase,
  ): Observable<string> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = resultData200 !== undefined ? resultData200 : <any>null
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<string>(<any>null)
  }

  getLeadInformation(leadId: string): Observable<LeadGenerationResponse> {
    let url_ = this.baseUrl + '/api/LeadGeneration/GetLeadInformation?'
    if (leadId === undefined || leadId === null)
      throw new Error(
        "The parameter 'leadId' must be defined and cannot be null.",
      )
    else url_ += 'LeadId=' + encodeURIComponent('' + leadId) + '&'
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('get', url_, options_)
      .flatMap((response_: any) => {
        return this.processGetLeadInformation(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processGetLeadInformation(<any>response_)
          } catch (e) {
            return <Observable<LeadGenerationResponse>>(
              (<any>Observable.throw(e))
            )
          }
        } else
          return <Observable<LeadGenerationResponse>>(
            (<any>Observable.throw(response_))
          )
      })
  }

  protected processGetLeadInformation(
    response: HttpResponseBase,
  ): Observable<LeadGenerationResponse> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = resultData200
          ? LeadGenerationResponse.fromJS(resultData200)
          : <any>null
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<LeadGenerationResponse>(<any>null)
  }

  getLeadtablevalue(leadId: string): Observable<LeadGenerationResponse> {
    let url_ = this.baseUrl + '/api/LeadGeneration/GetLeadtablevalue?'
    if (leadId === undefined || leadId === null)
      throw new Error(
        "The parameter 'leadId' must be defined and cannot be null.",
      )
    else url_ += 'LeadId=' + encodeURIComponent('' + leadId) + '&'
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('get', url_, options_)
      .flatMap((response_: any) => {
        return this.processGetLeadtablevalue(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processGetLeadtablevalue(<any>response_)
          } catch (e) {
            return <Observable<LeadGenerationResponse>>(
              (<any>Observable.throw(e))
            )
          }
        } else
          return <Observable<LeadGenerationResponse>>(
            (<any>Observable.throw(response_))
          )
      })
  }

  protected processGetLeadtablevalue(
    response: HttpResponseBase,
  ): Observable<LeadGenerationResponse> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = resultData200
          ? LeadGenerationResponse.fromJS(resultData200)
          : <any>null
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<LeadGenerationResponse>(<any>null)
  }

  updateLeads(req: LeadGenerationResponse): Observable<LeadsMessage> {
    let url_ = this.baseUrl + '/api/LeadGeneration/UpdateLeads'
    url_ = url_.replace(/[?&]$/, '')

    const content_ = JSON.stringify(req)

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('post', url_, options_)
      .flatMap((response_: any) => {
        return this.processUpdateLeads(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processUpdateLeads(<any>response_)
          } catch (e) {
            return <Observable<LeadsMessage>>(<any>Observable.throw(e))
          }
        } else
          return <Observable<LeadsMessage>>(<any>Observable.throw(response_))
      })
  }

  protected processUpdateLeads(
    response: HttpResponseBase,
  ): Observable<LeadsMessage> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = resultData200
          ? LeadsMessage.fromJS(resultData200)
          : <any>null
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<LeadsMessage>(<any>null)
  }

  getLeadsIdNumber(id: string): Observable<LeadGenerationResponse> {
    let url_ = this.baseUrl + '/api/LeadGeneration/GetLeadsIdNumber?'
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined and cannot be null.")
    else url_ += 'Id=' + encodeURIComponent('' + id) + '&'
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('get', url_, options_)
      .flatMap((response_: any) => {
        return this.processGetLeadsIdNumber(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processGetLeadsIdNumber(<any>response_)
          } catch (e) {
            return <Observable<LeadGenerationResponse>>(
              (<any>Observable.throw(e))
            )
          }
        } else
          return <Observable<LeadGenerationResponse>>(
            (<any>Observable.throw(response_))
          )
      })
  }

  protected processGetLeadsIdNumber(
    response: HttpResponseBase,
  ): Observable<LeadGenerationResponse> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = resultData200
          ? LeadGenerationResponse.fromJS(resultData200)
          : <any>null
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<LeadGenerationResponse>(<any>null)
  }
}

@Injectable()
export class PersonProfileService {
  private http: HttpClient
  private baseUrl: string
  protected jsonParseReviver: (key: string, value: any) => any = undefined

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string,
  ) {
    this.http = http
    this.baseUrl = baseUrl ? baseUrl : ''
  }

  getProfileDetils(request: ProfileRequest): Observable<PersonProfile> {
    let url_ = this.baseUrl + '/api/PersonProfile/GetProfileDetils'
    url_ = url_.replace(/[?&]$/, '')

    const content_ = JSON.stringify(request)

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('post', url_, options_)
      .flatMap((response_: any) => {
        return this.processGetProfileDetils(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processGetProfileDetils(<any>response_)
          } catch (e) {
            return <Observable<PersonProfile>>(<any>Observable.throw(e))
          }
        } else
          return <Observable<PersonProfile>>(<any>Observable.throw(response_))
      })
  }

  protected processGetProfileDetils(
    response: HttpResponseBase,
  ): Observable<PersonProfile> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = resultData200
          ? PersonProfile.fromJS(resultData200)
          : <any>null
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<PersonProfile>(<any>null)
  }
  // krishna pending
  downloadPdf(base64: string): Observable<FileResponse> {
    let url_ = this.baseUrl + '/api/PersonProfile/DownloadPdf'
    url_ = url_.replace(/[?&]$/, '')

    const content_ = JSON.stringify(base64)

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('post', url_, options_)
      .flatMap((response_: any) => {
        return this.processDownloadPdf(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processDownloadPdf(<any>response_)
          } catch (e) {
            return <Observable<FileResponse>>(<any>Observable.throw(e))
          }
        } else
          return <Observable<FileResponse>>(<any>Observable.throw(response_))
      })
  }

  protected processDownloadPdf(
    response: HttpResponseBase,
  ): Observable<FileResponse> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers
        ? response.headers.get('content-disposition')
        : undefined
      const fileNameMatch = contentDisposition
        ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
        : undefined
      const fileName =
        fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined
      return Observable.of({
        fileName: fileName,
        data: <any>responseBlob,
        status: status,
        headers: _headers,
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<FileResponse>(<any>null)
  }

  getConsumerID(idno: string): Observable<number> {
    let url_ = this.baseUrl + '/api/PersonProfile/GetConsumerID?'
    if (idno === undefined)
      throw new Error("The parameter 'idno' must be defined.")
    else url_ += 'Idno=' + encodeURIComponent('' + idno) + '&'
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('get', url_, options_)
      .flatMap((response_: any) => {
        return this.processGetConsumerID(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processGetConsumerID(<any>response_)
          } catch (e) {
            return <Observable<number>>(<any>Observable.throw(e))
          }
        } else return <Observable<number>>(<any>Observable.throw(response_))
      })
  }

  protected processGetConsumerID(
    response: HttpResponseBase,
  ): Observable<number> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = resultData200 !== undefined ? resultData200 : <any>null
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<number>(<any>null)
  }

  getDirectorInfo(directorid: number): Observable<DirectorShip> {
    let url_ = this.baseUrl + '/api/PersonProfile/GetDirectorInfo?'
    if (directorid === undefined || directorid === null)
      throw new Error(
        "The parameter 'directorid' must be defined and cannot be null.",
      )
    else url_ += 'directorid=' + encodeURIComponent('' + directorid) + '&'
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('get', url_, options_)
      .flatMap((response_: any) => {
        return this.processGetDirectorInfo(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processGetDirectorInfo(<any>response_)
          } catch (e) {
            return <Observable<DirectorShip>>(<any>Observable.throw(e))
          }
        } else
          return <Observable<DirectorShip>>(<any>Observable.throw(response_))
      })
  }

  protected processGetDirectorInfo(
    response: HttpResponseBase,
  ): Observable<DirectorShip> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = resultData200
          ? DirectorShip.fromJS(resultData200)
          : <any>null
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<DirectorShip>(<any>null)
  }

  getEndorsementdetail(propertydeedid: number): Observable<Endorsement> {
    let url_ = this.baseUrl + '/api/PersonProfile/GetEndorsementdetail?'
    if (propertydeedid === undefined || propertydeedid === null)
      throw new Error(
        "The parameter 'propertydeedid' must be defined and cannot be null.",
      )
    else
      url_ += 'Propertydeedid=' + encodeURIComponent('' + propertydeedid) + '&'
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('get', url_, options_)
      .flatMap((response_: any) => {
        return this.processGetEndorsementdetail(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processGetEndorsementdetail(<any>response_)
          } catch (e) {
            return <Observable<Endorsement>>(<any>Observable.throw(e))
          }
        } else
          return <Observable<Endorsement>>(<any>Observable.throw(response_))
      })
  }

  protected processGetEndorsementdetail(
    response: HttpResponseBase,
  ): Observable<Endorsement> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = resultData200
          ? Endorsement.fromJS(resultData200)
          : <any>null
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<Endorsement>(<any>null)
  }
}

@Injectable()
export class SecurityService {
  private http: HttpClient
  private baseUrl: string
  protected jsonParseReviver: (key: string, value: any) => any = undefined

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string,
  ) {
    this.http = http
    this.baseUrl = baseUrl ? baseUrl : ''
  }

  login(request: LoginRequest): Observable<LoginReponse> {
    let url_ = this.baseUrl + '/api/Security/Login'
    url_ = url_.replace(/[?&]$/, '')

    const content_ = JSON.stringify(request)

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('post', url_, options_)
      .flatMap((response_: any) => {
        return this.processLogin(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processLogin(<any>response_)
          } catch (e) {
            return <Observable<LoginReponse>>(<any>Observable.throw(e))
          }
        } else
          return <Observable<LoginReponse>>(<any>Observable.throw(response_))
      })
  }

  // krishna pending
  Xdslogin(request: string): Observable<LoginReponse> {
  //Xdslogin(request: XdsLoginRequest): Observable<LoginReponse> {
    //https://localhost:52255/api/security/xdslogin?token=tokendata
    //const token = localStorage.getItem('token')
    let url_ = this.baseUrl + '/api/Security/XdsLogin?token=' + request
    //let url_ = this.baseUrl + '/api/Security/XdsLogin'
    url_ = url_.replace(/[?&]$/, '')
    console.log(url_)
    const content_ = JSON.stringify(request)

    let options_: any = {
      //body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('post', url_, options_)
      .flatMap((response_: any) => {
        return this.processLogin(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processLogin(<any>response_)
          } catch (e) {
            return <Observable<LoginReponse>>(<any>Observable.throw(e))
          }
        } else
          return <Observable<LoginReponse>>(<any>Observable.throw(response_))
      })
  }

  //getcompanyname(request: LoginReponse): Observable<LoginReponse>

  protected processLogin(response: HttpResponseBase): Observable<LoginReponse> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = resultData200
          ? LoginReponse.fromJS(resultData200)
          : <any>null
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<LoginReponse>(<any>null)
  }

  logout(id: string, istrailuser: boolean): Observable<string> {
    let url_ = this.baseUrl + '/api/Security/Logout?'
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined and cannot be null.")
    else url_ += 'Id=' + encodeURIComponent('' + id) + '&'
    if (istrailuser === undefined || istrailuser === null)
      throw new Error(
        "The parameter 'istrailuser' must be defined and cannot be null.",
      )
    else url_ += 'istrailuser=' + encodeURIComponent('' + istrailuser) + '&'
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('get', url_, options_)
      .flatMap((response_: any) => {
        return this.processLogout(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processLogout(<any>response_)
          } catch (e) {
            return <Observable<string>>(<any>Observable.throw(e))
          }
        } else return <Observable<string>>(<any>Observable.throw(response_))
      })
  }

  protected processLogout(response: HttpResponseBase): Observable<string> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = resultData200 !== undefined ? resultData200 : <any>null
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<string>(<any>null)
  }

  getAdminlink(): Observable<string> {
    let url_ = this.baseUrl + '/api/Security/GetAdminlink'
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('get', url_, options_)
      .flatMap((response_: any) => {
        return this.processGetAdminlink(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processGetAdminlink(<any>response_)
          } catch (e) {
            return <Observable<string>>(<any>Observable.throw(e))
          }
        } else return <Observable<string>>(<any>Observable.throw(response_))
      })
  }

  protected processGetAdminlink(
    response: HttpResponseBase,
  ): Observable<string> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = resultData200 !== undefined ? resultData200 : <any>null
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<string>(<any>null)
  }

  trailuserLogin(request: LoginRequest): Observable<LoginReponse> {
    let url_ = this.baseUrl + '/api/Security/TrailuserLogin'
    url_ = url_.replace(/[?&]$/, '')

    const content_ = JSON.stringify(request)

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('post', url_, options_)
      .flatMap((response_: any) => {
        return this.processTrailuserLogin(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processTrailuserLogin(<any>response_)
          } catch (e) {
            return <Observable<LoginReponse>>(<any>Observable.throw(e))
          }
        } else
          return <Observable<LoginReponse>>(<any>Observable.throw(response_))
      })
  }

  protected processTrailuserLogin(
    response: HttpResponseBase,
  ): Observable<LoginReponse> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = resultData200
          ? LoginReponse.fromJS(resultData200)
          : <any>null
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<LoginReponse>(<any>null)
  }

  signUp(request: SignUpRequest): Observable<SignUpResponse> {
    let url_ = this.baseUrl + '/api/Security/SignUp'
    url_ = url_.replace(/[?&]$/, '')

    const content_ = JSON.stringify(request)

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('post', url_, options_)
      .flatMap((response_: any) => {
        return this.processSignUp(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processSignUp(<any>response_)
          } catch (e) {
            return <Observable<SignUpResponse>>(<any>Observable.throw(e))
          }
        } else
          return <Observable<SignUpResponse>>(<any>Observable.throw(response_))
      })
  }

  protected processSignUp(
    response: HttpResponseBase,
  ): Observable<SignUpResponse> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = resultData200
          ? SignUpResponse.fromJS(resultData200)
          : <any>null
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<SignUpResponse>(<any>null)
  }

  callregistry(
    request: DonotCallRegistryRequest,
  ): Observable<DonoCallRegistryResponse> {
    let url_ = this.baseUrl + '/api/Security/callregistry'
    url_ = url_.replace(/[?&]$/, '')

    const content_ = JSON.stringify(request)

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('post', url_, options_)
      .flatMap((response_: any) => {
        return this.processCallregistry(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processCallregistry(<any>response_)
          } catch (e) {
            return <Observable<DonoCallRegistryResponse>>(
              (<any>Observable.throw(e))
            )
          }
        } else
          return <Observable<DonoCallRegistryResponse>>(
            (<any>Observable.throw(response_))
          )
      })
  }

  protected processCallregistry(
    response: HttpResponseBase,
  ): Observable<DonoCallRegistryResponse> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = resultData200
          ? DonoCallRegistryResponse.fromJS(resultData200)
          : <any>null
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<DonoCallRegistryResponse>(<any>null)
  }

  forgotPassword(email: string): Observable<LoginReponse> {
    let url_ = this.baseUrl + '/api/Security/ForgotPassword?'
    if (email === undefined)
      throw new Error("The parameter 'email' must be defined.")
    else url_ += 'email=' + encodeURIComponent('' + email) + '&'
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('get', url_, options_)
      .flatMap((response_: any) => {
        return this.processForgotPassword(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processForgotPassword(<any>response_)
          } catch (e) {
            return <Observable<LoginReponse>>(<any>Observable.throw(e))
          }
        } else
          return <Observable<LoginReponse>>(<any>Observable.throw(response_))
      })
  }

  protected processForgotPassword(
    response: HttpResponseBase,
  ): Observable<LoginReponse> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = resultData200
          ? LoginReponse.fromJS(resultData200)
          : <any>null
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<LoginReponse>(<any>null)
  }

  getDsa(userid: string): Observable<DataServiceResponse> {
    let url_ = this.baseUrl + '/api/Security/GetDsa?'
    if (userid === undefined)
      throw new Error("The parameter 'userid' must be defined.")
    else url_ += 'userid=' + encodeURIComponent('' + userid) + '&'
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('get', url_, options_)
      .flatMap((response_: any) => {
        return this.processGetDsa(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processGetDsa(<any>response_)
          } catch (e) {
            return <Observable<DataServiceResponse>>(<any>Observable.throw(e))
          }
        } else
          return <Observable<DataServiceResponse>>(
            (<any>Observable.throw(response_))
          )
      })
  }

  protected processGetDsa(
    response: HttpResponseBase,
  ): Observable<DataServiceResponse> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = resultData200
          ? DataServiceResponse.fromJS(resultData200)
          : <any>null
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<DataServiceResponse>(<any>null)
  }

  registrationNumberVerify(request: SignUpRequest): Observable<SignUpResponse> {
    let url_ = this.baseUrl + '/api/Security/RegistrationNumberVerify'
    url_ = url_.replace(/[?&]$/, '')

    const content_ = JSON.stringify(request)

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('post', url_, options_)
      .flatMap((response_: any) => {
        return this.processRegistrationNumberVerify(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processRegistrationNumberVerify(<any>response_)
          } catch (e) {
            return <Observable<SignUpResponse>>(<any>Observable.throw(e))
          }
        } else
          return <Observable<SignUpResponse>>(<any>Observable.throw(response_))
      })
  }

  protected processRegistrationNumberVerify(
    response: HttpResponseBase,
  ): Observable<SignUpResponse> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = resultData200
          ? SignUpResponse.fromJS(resultData200)
          : <any>null
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<SignUpResponse>(<any>null)
  }

  getLogs(userid: string): Observable<CustomerLog[]> {
    let url_ = this.baseUrl + '/api/Security/GetLogs?'
    if (userid === undefined)
      throw new Error("The parameter 'userid' must be defined.")
    else url_ += 'userid=' + encodeURIComponent('' + userid) + '&'
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('get', url_, options_)
      .flatMap((response_: any) => {
        return this.processGetLogs(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processGetLogs(<any>response_)
          } catch (e) {
            return <Observable<CustomerLog[]>>(<any>Observable.throw(e))
          }
        } else
          return <Observable<CustomerLog[]>>(<any>Observable.throw(response_))
      })
  }

  protected processGetLogs(
    response: HttpResponseBase,
  ): Observable<CustomerLog[]> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        if (resultData200 && resultData200.constructor === Array) {
          result200 = []
          for (let item of resultData200)
            result200.push(CustomerLog.fromJS(item))
        }
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<CustomerLog[]>(<any>null)
  }

  getTrailLogs(userid: string): Observable<TrailUserLog[]> {
    let url_ = this.baseUrl + '/api/Security/GetTrailLogs?'
    if (userid === undefined)
      throw new Error("The parameter 'userid' must be defined.")
    else url_ += 'userid=' + encodeURIComponent('' + userid) + '&'
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('get', url_, options_)
      .flatMap((response_: any) => {
        return this.processGetTrailLogs(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processGetTrailLogs(<any>response_)
          } catch (e) {
            return <Observable<TrailUserLog[]>>(<any>Observable.throw(e))
          }
        } else
          return <Observable<TrailUserLog[]>>(<any>Observable.throw(response_))
      })
  }

  protected processGetTrailLogs(
    response: HttpResponseBase,
  ): Observable<TrailUserLog[]> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        if (resultData200 && resultData200.constructor === Array) {
          result200 = []
          for (let item of resultData200)
            result200.push(TrailUserLog.fromJS(item))
        }
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<TrailUserLog[]>(<any>null)
  }

  getUserMenu(id: string, screensize: number): Observable<Menu[]> {
    let url_ = this.baseUrl + '/api/Security/GetUserMenu?'
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined and cannot be null.")
    else url_ += 'Id=' + encodeURIComponent('' + id) + '&'
    if (screensize === undefined || screensize === null)
      throw new Error(
        "The parameter 'screensize' must be defined and cannot be null.",
      )
    else url_ += 'screensize=' + encodeURIComponent('' + screensize) + '&'
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('get', url_, options_)
      .flatMap((response_: any) => {
        return this.processGetUserMenu(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processGetUserMenu(<any>response_)
          } catch (e) {
            return <Observable<Menu[]>>(<any>Observable.throw(e))
          }
        } else return <Observable<Menu[]>>(<any>Observable.throw(response_))
      })
  }

  protected processGetUserMenu(response: HttpResponseBase): Observable<Menu[]> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        if (resultData200 && resultData200.constructor === Array) {
          result200 = []
          for (let item of resultData200) result200.push(Menu.fromJS(item))
        }
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<Menu[]>(<any>null)
  }

  getLookupDatas(): Observable<LookupData[]> {
    let url_ = this.baseUrl + '/api/Security/GetLookupDatas'
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('get', url_, options_)
      .flatMap((response_: any) => {
        return this.processGetLookupDatas(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processGetLookupDatas(<any>response_)
          } catch (e) {
            return <Observable<LookupData[]>>(<any>Observable.throw(e))
          }
        } else
          return <Observable<LookupData[]>>(<any>Observable.throw(response_))
      })
  }

  protected processGetLookupDatas(
    response: HttpResponseBase,
  ): Observable<LookupData[]> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        if (resultData200 && resultData200.constructor === Array) {
          result200 = []
          for (let item of resultData200)
            result200.push(LookupData.fromJS(item))
        }
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<LookupData[]>(<any>null)
  }

  resetPassword(
    username: string,
    oldpassword: string,
    code: string,
  ): Observable<LoginReponse> {
    let url_ = this.baseUrl + '/api/Security/ResetPassword?'
    if (username === undefined)
      throw new Error("The parameter 'username' must be defined.")
    else url_ += 'username=' + encodeURIComponent('' + username) + '&'
    if (oldpassword === undefined)
      throw new Error("The parameter 'oldpassword' must be defined.")
    else url_ += 'oldpassword=' + encodeURIComponent('' + oldpassword) + '&'
    if (code === undefined)
      throw new Error("The parameter 'code' must be defined.")
    else url_ += 'code=' + encodeURIComponent('' + code) + '&'
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('post', url_, options_)
      .flatMap((response_: any) => {
        return this.processResetPassword(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processResetPassword(<any>response_)
          } catch (e) {
            return <Observable<LoginReponse>>(<any>Observable.throw(e))
          }
        } else
          return <Observable<LoginReponse>>(<any>Observable.throw(response_))
      })
  }

  protected processResetPassword(
    response: HttpResponseBase,
  ): Observable<LoginReponse> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = resultData200
          ? LoginReponse.fromJS(resultData200)
          : <any>null
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<LoginReponse>(<any>null)
  }

  getMessages(id: string): Observable<ApplicationMessages[]> {
    let url_ = this.baseUrl + '/api/Security/GetMessages?'
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined and cannot be null.")
    else url_ += 'Id=' + encodeURIComponent('' + id) + '&'
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('get', url_, options_)
      .flatMap((response_: any) => {
        return this.processGetMessages(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processGetMessages(<any>response_)
          } catch (e) {
            return <Observable<ApplicationMessages[]>>(<any>Observable.throw(e))
          }
        } else
          return <Observable<ApplicationMessages[]>>(
            (<any>Observable.throw(response_))
          )
      })
  }

  protected processGetMessages(
    response: HttpResponseBase,
  ): Observable<ApplicationMessages[]> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        if (resultData200 && resultData200.constructor === Array) {
          result200 = []
          for (let item of resultData200)
            result200.push(ApplicationMessages.fromJS(item))
        }
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<ApplicationMessages[]>(<any>null)
  }

  removeAppMessages(id: string): Observable<string> {
    let url_ = this.baseUrl + '/api/Security/RemoveAppMessages?'
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined and cannot be null.")
    else url_ += 'Id=' + encodeURIComponent('' + id) + '&'
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('get', url_, options_)
      .flatMap((response_: any) => {
        return this.processRemoveAppMessages(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processRemoveAppMessages(<any>response_)
          } catch (e) {
            return <Observable<string>>(<any>Observable.throw(e))
          }
        } else return <Observable<string>>(<any>Observable.throw(response_))
      })
  }

  protected processRemoveAppMessages(
    response: HttpResponseBase,
  ): Observable<string> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = resultData200 !== undefined ? resultData200 : <any>null
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<string>(<any>null)
  }

  downloadHelpPdf(): Observable<FileResponse> {
    let url_ = this.baseUrl + '/api/Security/DownloadHelpPdf'
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('get', url_, options_)
      .flatMap((response_: any) => {
        return this.processDownloadHelpPdf(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processDownloadHelpPdf(<any>response_)
          } catch (e) {
            return <Observable<FileResponse>>(<any>Observable.throw(e))
          }
        } else
          return <Observable<FileResponse>>(<any>Observable.throw(response_))
      })
  }

  protected processDownloadHelpPdf(
    response: HttpResponseBase,
  ): Observable<FileResponse> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers
        ? response.headers.get('content-disposition')
        : undefined
      const fileNameMatch = contentDisposition
        ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
        : undefined
      const fileName =
        fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined
      return Observable.of({
        fileName: fileName,
        data: <any>responseBlob,
        status: status,
        headers: _headers,
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<FileResponse>(<any>null)
  }

  getLastPasswordResetDateCustomerUser(customerId: string): Observable<string> {
    let url_ =
      this.baseUrl + '/api/Security/GetLastPasswordResetDateCustomerUser?'
    if (customerId === undefined || customerId === null)
      throw new Error(
        "The parameter 'customerId' must be defined and cannot be null.",
      )
    else url_ += 'Id=' + encodeURIComponent('' + customerId)
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request(
        'get',
        url_,
        // 'https://localhost:5001/api/Security/GetLastPasswordResetDateCustomerUser?Id=4717E73D-1F3F-4ACE-BE1A-0244770D6275',
        options_,
      )
      .flatMap((response_: any) => {
        return this.processLastPasswordResetDateCustomerUser(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processLastPasswordResetDateCustomerUser(<any>response_)
          } catch (e) {
            return <Observable<string>>(<any>Observable.throw(e))
          }
        } else return <Observable<string>>(<any>Observable.throw(response_))
      })
  }

  protected processLastPasswordResetDateCustomerUser(
    response: HttpResponseBase,
  ): Observable<string> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = resultData200 !== undefined ? resultData200 : <any>null
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<string>(<any>null)
  }

  // getLastPasswordResetDateCustomerUser2(id: string): Observable<string> {
  //   let url_ =
  //     this.baseUrl + '/api/Security/GetLastPasswordResetDateCustomerUser?'
  //   if (id === undefined || id === null)
  //     throw new Error("The parameter 'id' must be defined and cannot be null.")
  //   else url_ += 'Id=' + encodeURIComponent('' + id) + '&'
  //   url_ = url_.replace(/[?&]$/, '')

  //   let options_: any = {
  //     observe: 'response',
  //     responseType: 'blob',
  //     headers: new HttpHeaders({
  //       'Content-Type': 'application/json',
  //       Accept: 'application/json',
  //     }),
  //   }

  //   return this.http
  //     .request('get', url_, options_)
  //     .flatMap((response_: any) => {
  //       return this.processLastPasswordResetDateCustomerUser2(response_)
  //     })
  //     .catch((response_: any) => {
  //       if (response_ instanceof HttpResponseBase) {
  //         try {
  //           return this.processLastPasswordResetDateCustomerUser2(
  //             <any>response_,
  //           )
  //         } catch (e) {
  //           return <Observable<string>>(<any>Observable.throw(e))
  //         }
  //       } else return <Observable<string>>(<any>Observable.throw(response_))
  //     })
  // }

  // protected processLastPasswordResetDateCustomerUser2(
  //   response: HttpResponseBase,
  // ): Observable<string> {
  //   const status = response.status
  //   const responseBlob =
  //     response instanceof HttpResponse
  //       ? response.body
  //       : (<any>response).error instanceof Blob
  //       ? (<any>response).error
  //       : undefined

  //   let _headers: any = {}
  //   if (response.headers) {
  //     for (let key of response.headers.keys()) {
  //       _headers[key] = response.headers.get(key)
  //     }
  //   }
  //   if (status === 200) {
  //     return blobToText(responseBlob).flatMap((_responseText) => {
  //       let result200: any = null
  //       let resultData200 =
  //         _responseText === ''
  //           ? null
  //           : JSON.parse(_responseText, this.jsonParseReviver)
  //       result200 = resultData200 !== undefined ? resultData200 : <any>null
  //       return Observable.of(result200)
  //     })
  //   } else if (status !== 200 && status !== 204) {
  //     return blobToText(responseBlob).flatMap((_responseText) => {
  //       return throwException(
  //         'An unexpected server error occurred.',
  //         status,
  //         _responseText,
  //         _headers,
  //       )
  //     })
  //   }
  //   return Observable.of<string>(<any>null)
  // }
}

@Injectable()
export class TracingService {
  private http: HttpClient
  private baseUrl: string
  protected jsonParseReviver: (key: string, value: any) => any = undefined
  // critical
  //isXDS: any;
  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string,
  ) {
    this.http = http
    this.baseUrl = baseUrl ? baseUrl : ''
    // krishna start
    //this.isXDS = localStorage.getItem('isXDS')
    // krishna end

  }

  tracingConsumerSearch(
    request: ConsumerSearchRequest,
  ): Observable<ConsumerSearchResponse> {
    let url_ = this.baseUrl + '/api/Tracing/TracingConsumerSearch'
    url_ = url_.replace(/[?&]$/, '')

    const content_ = JSON.stringify(request)

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('post', url_, options_)
      .flatMap((response_: any) => {
        return this.processTracingConsumerSearch(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processTracingConsumerSearch(<any>response_)
          } catch (e) {
            return <Observable<ConsumerSearchResponse>>(
              (<any>Observable.throw(e))
            )
          }
        } else
          return <Observable<ConsumerSearchResponse>>(
            (<any>Observable.throw(response_))
          )
      })
  }

  protected processTracingConsumerSearch(
    response: HttpResponseBase,
  ): Observable<ConsumerSearchResponse> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = resultData200
          ? ConsumerSearchResponse.fromJS(resultData200)
          : <any>null
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<ConsumerSearchResponse>(<any>null)
  }

  tracingCommercialSearch(
    request: CompanySearchRequest,
  ): Observable<CompanySearchResponse> {
    let url_ = this.baseUrl + '/api/Tracing/TracingCommercialSearch'
    url_ = url_.replace(/[?&]$/, '')

    const content_ = JSON.stringify(request)

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('post', url_, options_)
      .flatMap((response_: any) => {
        return this.processTracingCommercialSearch(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processTracingCommercialSearch(<any>response_)
          } catch (e) {
            return <Observable<CompanySearchResponse>>(<any>Observable.throw(e))
          }
        } else
          return <Observable<CompanySearchResponse>>(
            (<any>Observable.throw(response_))
          )
      })
  }

  protected processTracingCommercialSearch(
    response: HttpResponseBase,
  ): Observable<CompanySearchResponse> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = resultData200
          ? CompanySearchResponse.fromJS(resultData200)
          : <any>null
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<CompanySearchResponse>(<any>null)
  }

  tracingAddressSearch(
    request: AddressSearchRequest,
  ): Observable<AddressSearchResponse> {
    let url_ = this.baseUrl + '/api/Tracing/TracingAddressSearch'
    url_ = url_.replace(/[?&]$/, '')

    const content_ = JSON.stringify(request)

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('post', url_, options_)
      .flatMap((response_: any) => {
        return this.processTracingAddressSearch(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processTracingAddressSearch(<any>response_)
          } catch (e) {
            return <Observable<AddressSearchResponse>>(<any>Observable.throw(e))
          }
        } else
          return <Observable<AddressSearchResponse>>(
            (<any>Observable.throw(response_))
          )
      })
  }

  protected processTracingAddressSearch(
    response: HttpResponseBase,
  ): Observable<AddressSearchResponse> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = resultData200
          ? AddressSearchResponse.fromJS(resultData200)
          : <any>null
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<AddressSearchResponse>(<any>null)
  }

  getPoints(userId: string, customerId: string): Observable<number> {
    
    let url_ = this.baseUrl + '/api/Tracing/GetPoints?'
    if (userId === undefined || userId === null)
      throw new Error(
        "The parameter 'userId' must be defined and cannot be null.",
      )
    else url_ += 'userId=' + encodeURIComponent('' + userId) + '&'
    if (customerId === undefined || customerId === null)
      throw new Error(
        "The parameter 'customerId' must be defined and cannot be null.",
      )
    else url_ += 'customerId=' + encodeURIComponent('' + customerId) + '&'
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('get', url_, options_)
      .flatMap((response_: any) => {
        // ISSUE CODE
        return this.processGetPoints(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processGetPoints(<any>response_)
          } catch (e) {
            return <Observable<number>>(<any>Observable.throw(e))
          }
        } else return <Observable<number>>(<any>Observable.throw(response_))
      })
  }

  protected processGetPoints(response: HttpResponseBase): Observable<number> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = resultData200 !== undefined ? resultData200 : <any>null
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<number>(<any>null)
  }

  getIsRestrictedCustomer(userId: string): Observable<number> {
    // const URL =
    //   'https://localhost:5001/api/Tracing/GetCustomerIsRestricted?Id=5E9B5E8E-B21C-42ED-A23D-566FEF2A6724'
    let url_ = this.baseUrl + '/api/Tracing/GetCustomerIsRestricted?'
    if (userId === undefined || userId === null)
      throw new Error(
        "The parameter 'userId' must be defined and cannot be null.",
      )
    else url_ += 'Id=' + encodeURIComponent('' + userId)
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('get', url_, options_)
      .flatMap((response_: any) => {
        return this.processGetIsRestrictedCustomer(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processGetIsRestrictedCustomer(<any>response_)
          } catch (e) {
            return <Observable<number>>(<any>Observable.throw(e))
          }
        } else return <Observable<number>>(<any>Observable.throw(response_))
      })
  }

  protected processGetIsRestrictedCustomer(
    response: HttpResponseBase,
  ): Observable<number> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = resultData200 !== undefined ? resultData200 : <any>null
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<number>(<any>null)
  }

  getIsRestrictedCustomerUser(customerId: string): Observable<number> {
    let url_ = this.baseUrl + '/api/Tracing/GetCustomerUserIsRestricted?'
    if (customerId === undefined || customerId === null)
      throw new Error(
        "The parameter 'customerId' must be defined and cannot be null.",
      )
    else url_ += 'Id=' + encodeURIComponent('' + customerId)
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('get', url_, options_)
      .flatMap((response_: any) => {
        return this.processGetIsRestrictedCustomerUser(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processGetIsRestrictedCustomerUser(<any>response_)
          } catch (e) {
            return <Observable<number>>(<any>Observable.throw(e))
          }
        } else return <Observable<number>>(<any>Observable.throw(response_))
      })
  }

  // selected enquiry reason by customer - by padmavati
  getCustomerEnquiryReason(customerId: string): Observable<number> {
    let url_ = this.baseUrl + '/api/Tracing/GetCustomerEnquiryReason?'
    if (customerId === undefined || customerId === null)
      throw new Error(
        "The parameter 'customerId' must be defined and cannot be null.",
      )
    else url_ += 'Id=' + encodeURIComponent('' + customerId)
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('get', url_, options_)
      .flatMap((response_: any) => { 
        return this.processGetIsRestrictedCustomerUser(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processGetIsRestrictedCustomerUser(<any>response_)
          } catch (e) {
            return <Observable<number>>(<any>Observable.throw(e))
          }
        } else return <Observable<number>>(<any>Observable.throw(response_))
      })
  }


  protected processGetIsRestrictedCustomerUser(
    response: HttpResponseBase,
  ): Observable<number> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = resultData200 !== undefined ? resultData200 : <any>null
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<number>(<any>null)
  }

  getEnquiryReasonLookupDatas(): Observable<LookupData[]> {
    let url_ = this.baseUrl + '/api/Tracing/GetEnquiryReasonLookupDatas'
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('get', url_, options_)
      .flatMap((response_: any) => {
        return this.processGetLookupDatas(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processGetLookupDatas(<any>response_)
          } catch (e) {
            return <Observable<LookupData[]>>(<any>Observable.throw(e))
          }
        } else
          return <Observable<LookupData[]>>(<any>Observable.throw(response_))
      })
  }

  protected processGetLookupDatas(
    response: HttpResponseBase,
  ): Observable<LookupData[]> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        if (resultData200 && resultData200.constructor === Array) {
          result200 = []
          for (let item of resultData200)
            result200.push(LookupData.fromJS(item))
        }
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<LookupData[]>(<any>null)
  }

}

export class CompanyRequest implements ICompanyRequest {
  id: number
  userId: string
  customerId: string
  searchType?: string
  searchCriteria?: string
  inputType?: string
  istrailuser: boolean

  constructor(data?: ICompanyRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.id = data['id']
      this.userId = data['userId']
      this.customerId = data['customerId']
      this.searchType = data['searchType']
      this.searchCriteria = data['searchCriteria']
      this.inputType = data['inputType']
      this.istrailuser = data['istrailuser']
    }
  }

  static fromJS(data: any): CompanyRequest {
    data = typeof data === 'object' ? data : {}
    let result = new CompanyRequest()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['id'] = this.id
    data['userId'] = this.userId
    data['customerId'] = this.customerId
    data['searchType'] = this.searchType
    data['searchCriteria'] = this.searchCriteria
    data['inputType'] = this.inputType
    data['istrailuser'] = this.istrailuser
    return data
  }
}

export interface ICompanyRequest {
  id: number
  userId: string
  customerId: string
  searchType?: string
  searchCriteria?: string
  inputType?: string
  istrailuser: boolean
}

export class CompanyProfile implements ICompanyProfile {
  commercialId: number
  registrationNo?: string
  registrationNoOld?: string
  commercialName?: string
  commercialShortName?: string
  commercialTranslatedName?: string
  previousBusinessname?: string
  registrationDate?: Date
  businessStartDate?: Date
  financialYearEnd?: number
  financialEffectiveDate?: Date
  lastUpdatedDate?: Date
  sICCode?: string
  businessDesc?: string
  commercialStatusCode?: string
  commercialTypeCode?: string
  vATNo?: number
  bussEmail?: string
  bussWebsite?: string
  createdOnDate?: Date
  noOfShares?: number
  amountPerShare?: number
  premium?: number
  addressTypeInd?: string
  originalAddress1?: string
  originalAddress2?: string
  originalAddress3?: string
  originalAddress4?: string
  originalPostalCode?: string
  tabSelected?: string
  client_logo?: string
  contacts?: ContactDetail[]
  addresses?: AddressDetail[]
  directorShips?: DirectorShip[]
  commercialJudgements?: CommercialJudgement[]
  propertyOwners?: PropertyDeedDetail[]
  commercialAuditors?: CommercialAuditorVm[]
  timelines?: TimeLine[]

  constructor(data?: ICompanyProfile) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.commercialId = data['commercialId']
      this.registrationNo = data['registrationNo']
      this.registrationNoOld = data['registrationNoOld']
      this.commercialName = data['commercialName']
      this.commercialShortName = data['commercialShortName']
      this.commercialTranslatedName = data['commercialTranslatedName']
      this.previousBusinessname = data['previousBusinessname']
      this.client_logo = data['client_logo']
      this.registrationDate = data['registrationDate']
        ? new Date(data['registrationDate'].toString())
        : <any>undefined
      this.businessStartDate = data['businessStartDate']
        ? new Date(data['businessStartDate'].toString())
        : <any>undefined
      this.financialYearEnd = data['financialYearEnd']
      this.financialEffectiveDate = data['financialEffectiveDate']
        ? new Date(data['financialEffectiveDate'].toString())
        : <any>undefined
      this.lastUpdatedDate = data['lastUpdatedDate']
        ? new Date(data['lastUpdatedDate'].toString())
        : <any>undefined
      this.sICCode = data['sICCode']
      this.businessDesc = data['businessDesc']
      this.commercialStatusCode = data['commercialStatusCode']
      this.commercialTypeCode = data['commercialTypeCode']
      this.vATNo = data['vATNo']
      this.bussEmail = data['bussEmail']
      this.bussWebsite = data['bussWebsite']
      this.createdOnDate = data['createdOnDate']
        ? new Date(data['createdOnDate'].toString())
        : <any>undefined
      this.noOfShares = data['noOfShares']
      this.amountPerShare = data['amountPerShare']
      this.premium = data['premium']
      this.addressTypeInd = data['addressTypeInd']
      this.originalAddress1 = data['originalAddress1']
      this.originalAddress2 = data['originalAddress2']
      this.originalAddress3 = data['originalAddress3']
      this.originalAddress4 = data['originalAddress4']
      this.originalPostalCode = data['originalPostalCode']
      this.tabSelected = data['tabSelected']
      if (data['contacts'] && data['contacts'].constructor === Array) {
        this.contacts = []
        for (let item of data['contacts'])
          this.contacts.push(ContactDetail.fromJS(item))
      }
      if (data['addresses'] && data['addresses'].constructor === Array) {
        this.addresses = []
        for (let item of data['addresses'])
          this.addresses.push(AddressDetail.fromJS(item))
      }
      if (
        data['directorShips'] &&
        data['directorShips'].constructor === Array
      ) {
        this.directorShips = []
        for (let item of data['directorShips'])
          this.directorShips.push(DirectorShip.fromJS(item))
      }
      if (
        data['commercialJudgements'] &&
        data['commercialJudgements'].constructor === Array
      ) {
        this.commercialJudgements = []
        for (let item of data['commercialJudgements'])
          this.commercialJudgements.push(CommercialJudgement.fromJS(item))
      }
      if (
        data['propertyOwners'] &&
        data['propertyOwners'].constructor === Array
      ) {
        this.propertyOwners = []
        for (let item of data['propertyOwners'])
          this.propertyOwners.push(PropertyDeedDetail.fromJS(item))
      }
      if (
        data['commercialAuditors'] &&
        data['commercialAuditors'].constructor === Array
      ) {
        this.commercialAuditors = []
        for (let item of data['commercialAuditors'])
          this.commercialAuditors.push(CommercialAuditorVm.fromJS(item))
      }
      if (data['timelines'] && data['timelines'].constructor === Array) {
        this.timelines = []
        for (let item of data['timelines'])
          this.timelines.push(TimeLine.fromJS(item))
      }
    }
  }

  static fromJS(data: any): CompanyProfile {
    data = typeof data === 'object' ? data : {}
    let result = new CompanyProfile()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['commercialId'] = this.commercialId
    data['registrationNo'] = this.registrationNo
    data['registrationNoOld'] = this.registrationNoOld
    data['commercialName'] = this.commercialName
    data['commercialShortName'] = this.commercialShortName
    data['commercialTranslatedName'] = this.commercialTranslatedName
    data['previousBusinessname'] = this.previousBusinessname
    data['registrationDate'] = this.registrationDate
    data['client_logo'] = this.client_logo
      ? this.registrationDate.toISOString()
      : <any>undefined
    data['businessStartDate'] = this.businessStartDate
      ? this.businessStartDate.toISOString()
      : <any>undefined
    data['financialYearEnd'] = this.financialYearEnd
    data['financialEffectiveDate'] = this.financialEffectiveDate
      ? this.financialEffectiveDate.toISOString()
      : <any>undefined
    data['lastUpdatedDate'] = this.lastUpdatedDate
      ? this.lastUpdatedDate.toISOString()
      : <any>undefined
    data['sICCode'] = this.sICCode
    data['businessDesc'] = this.businessDesc
    data['commercialStatusCode'] = this.commercialStatusCode
    data['commercialTypeCode'] = this.commercialTypeCode
    data['vATNo'] = this.vATNo
    data['bussEmail'] = this.bussEmail
    data['bussWebsite'] = this.bussWebsite
    data['createdOnDate'] = this.createdOnDate
      ? this.createdOnDate.toISOString()
      : <any>undefined
    data['noOfShares'] = this.noOfShares
    data['amountPerShare'] = this.amountPerShare
    data['premium'] = this.premium
    data['addressTypeInd'] = this.addressTypeInd
    data['originalAddress1'] = this.originalAddress1
    data['originalAddress2'] = this.originalAddress2
    data['originalAddress3'] = this.originalAddress3
    data['originalAddress4'] = this.originalAddress4
    data['originalPostalCode'] = this.originalPostalCode
    data['tabSelected'] = this.tabSelected
    if (this.contacts && this.contacts.constructor === Array) {
      data['contacts'] = []
      for (let item of this.contacts) data['contacts'].push(item.toJSON())
    }
    if (this.addresses && this.addresses.constructor === Array) {
      data['addresses'] = []
      for (let item of this.addresses) data['addresses'].push(item.toJSON())
    }
    if (this.directorShips && this.directorShips.constructor === Array) {
      data['directorShips'] = []
      for (let item of this.directorShips)
        data['directorShips'].push(item.toJSON())
    }
    if (
      this.commercialJudgements &&
      this.commercialJudgements.constructor === Array
    ) {
      data['commercialJudgements'] = []
      for (let item of this.commercialJudgements)
        data['commercialJudgements'].push(item.toJSON())
    }
    if (this.propertyOwners && this.propertyOwners.constructor === Array) {
      data['propertyOwners'] = []
      for (let item of this.propertyOwners)
        data['propertyOwners'].push(item.toJSON())
    }
    if (
      this.commercialAuditors &&
      this.commercialAuditors.constructor === Array
    ) {
      data['commercialAuditors'] = []
      for (let item of this.commercialAuditors)
        data['commercialAuditors'].push(item.toJSON())
    }
    if (this.timelines && this.timelines.constructor === Array) {
      data['timelines'] = []
      for (let item of this.timelines) data['timelines'].push(item.toJSON())
    }
    return data
  }
}

export interface ICompanyProfile {
  commercialId: number
  registrationNo?: string
  registrationNoOld?: string
  commercialName?: string
  commercialShortName?: string
  commercialTranslatedName?: string
  previousBusinessname?: string
  registrationDate?: Date
  businessStartDate?: Date
  financialYearEnd?: number
  financialEffectiveDate?: Date
  lastUpdatedDate?: Date
  sICCode?: string
  businessDesc?: string
  commercialStatusCode?: string
  commercialTypeCode?: string
  vATNo?: number
  bussEmail?: string
  bussWebsite?: string
  createdOnDate?: Date
  noOfShares?: number
  amountPerShare?: number
  premium?: number
  addressTypeInd?: string
  originalAddress1?: string
  originalAddress2?: string
  originalAddress3?: string
  originalAddress4?: string
  originalPostalCode?: string
  client_logo?: string
  tabSelected?: string
  contacts?: ContactDetail[]
  addresses?: AddressDetail[]
  directorShips?: DirectorShip[]
  commercialJudgements?: CommercialJudgement[]
  propertyOwners?: PropertyDeedDetail[]
  commercialAuditors?: CommercialAuditorVm[]
  timelines?: TimeLine[]
}

export class ContactDetail implements IContactDetail {
  id: number
  consumerID: number
  type?: string
  contact?: string
  date: Date
  internationalDialingCode?: string
  telephoneNo?: string
  telephoneCode?: string
  createdonDate?: Date
  lastUpdatedDate?: Date
  email?: string
  telephoneTypeInd?: string
  peopleLinked: number
  linkedDate?: Date
  recordstatusind: number
  changedonDate?: Date
  telephoneCodeInformation?: string
  codeType?: string
  codeRegion?: string
  existingTelephoneNo?: string

  constructor(data?: IContactDetail) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.id = data['id']
      this.consumerID = data['consumerID']
      this.type = data['type']
      this.contact = data['contact']
      this.date = data['date']
        ? new Date(data['date'].toString())
        : <any>undefined
      this.internationalDialingCode = data['internationalDialingCode']
      this.telephoneNo = data['telephoneNo']
      this.telephoneCode = data['telephoneCode']
      this.createdonDate = data['createdonDate']
        ? new Date(data['createdonDate'].toString())
        : <any>undefined
      this.lastUpdatedDate = data['lastUpdatedDate']
        ? new Date(data['lastUpdatedDate'].toString())
        : <any>undefined
      this.email = data['email']
      this.telephoneTypeInd = data['telephoneTypeInd']
      this.peopleLinked = data['peopleLinked']
      this.linkedDate = data['linkedDate']
        ? new Date(data['linkedDate'].toString())
        : <any>undefined
      this.recordstatusind = data['recordstatusind']
      this.changedonDate = data['changedonDate']
        ? new Date(data['changedonDate'].toString())
        : <any>undefined
      this.telephoneCodeInformation = data['telephoneCodeInformation']
      this.codeType = data['codeType']
      this.codeRegion = data['codeRegion']
      this.existingTelephoneNo = data['existingTelephoneNo']
    }
  }

  static fromJS(data: any): ContactDetail {
    data = typeof data === 'object' ? data : {}
    let result = new ContactDetail()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['id'] = this.id
    data['consumerID'] = this.consumerID
    data['type'] = this.type
    data['contact'] = this.contact
    data['date'] = this.date ? this.date.toISOString() : <any>undefined
    data['internationalDialingCode'] = this.internationalDialingCode
    data['telephoneNo'] = this.telephoneNo
    data['telephoneCode'] = this.telephoneCode
    data['createdonDate'] = this.createdonDate
      ? this.createdonDate.toISOString()
      : <any>undefined
    data['lastUpdatedDate'] = this.lastUpdatedDate
      ? this.lastUpdatedDate.toISOString()
      : <any>undefined
    data['email'] = this.email
    data['telephoneTypeInd'] = this.telephoneTypeInd
    data['peopleLinked'] = this.peopleLinked
    data['linkedDate'] = this.linkedDate
      ? this.linkedDate.toISOString()
      : <any>undefined
    data['recordstatusind'] = this.recordstatusind
    data['changedonDate'] = this.changedonDate
      ? this.changedonDate.toISOString()
      : <any>undefined
    data['telephoneCodeInformation'] = this.telephoneCodeInformation
    data['codeType'] = this.codeType
    data['codeRegion'] = this.codeRegion
    data['existingTelephoneNo'] = this.existingTelephoneNo
    return data
  }
}

export interface IContactDetail {
  id: number
  consumerID: number
  type?: string
  contact?: string
  date: Date
  internationalDialingCode?: string
  telephoneNo?: string
  telephoneCode?: string
  createdonDate?: Date
  lastUpdatedDate?: Date
  email?: string
  telephoneTypeInd?: string
  peopleLinked: number
  linkedDate?: Date
  recordstatusind: number
  changedonDate?: Date
  telephoneCodeInformation?: string
  codeType?: string
  codeRegion?: string
  existingTelephoneNo?: string
}

// krishna start
export class AKADetail implements IAKADetail {
  consumerid?: string
  lastUpdatedDate?: Date
  akas?: string

  constructor(data?: IAKADetail) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.consumerid = data['consumerId']
      this.lastUpdatedDate = data['lastUpdatedDate']
        ? new Date(data['lastUpdatedDate'].toString())
        : <any>undefined
      this.akas = data['akas']
    }
  }

  static fromJS(data: any): AKADetail {
    data = typeof data === 'object' ? data : {}
    let result = new AKADetail()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['consumerid'] = this.consumerid
    data['lastUpdatedDate'] = this.lastUpdatedDate
      ? this.lastUpdatedDate.toISOString()
      : <any>undefined
    data['akas'] = this.akas
    return data
  }
}

export interface IAKADetail {
  consumerid?: string
  lastUpdatedDate?: Date
  akas?: string
}

// krishna end

export class AddressDetail implements IAddressDetail {
  id?: string
  addressTypeInd?: string
  province?: string
  originalAddress1?: string
  originalAddress2?: string
  originalAddress3?: string
  originalAddress4?: string
  fullAddress?: string
  originalPostalCode?: string
  occupantTypeInd?: string
  lastUpdatedDate?: Date
  createdOnDate?: Date
  recordstatusind: number
  town?: string
  region?: string

  constructor(data?: IAddressDetail) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.id = data['id']
      this.addressTypeInd = data['addressTypeInd']
      this.province = data['province']
      this.originalAddress1 = data['originalAddress1']
      this.originalAddress2 = data['originalAddress2']
      this.originalAddress3 = data['originalAddress3']
      this.originalAddress4 = data['originalAddress4']
      this.fullAddress = data['fullAddress']
      this.originalPostalCode = data['originalPostalCode']
      this.occupantTypeInd = data['occupantTypeInd']
      this.lastUpdatedDate = data['lastUpdatedDate']
        ? new Date(data['lastUpdatedDate'].toString())
        : <any>undefined
      this.createdOnDate = data['createdOnDate']
        ? new Date(data['createdOnDate'].toString())
        : <any>undefined
      this.recordstatusind = data['recordstatusind']
      this.town = data['town']
      this.region = data['region']
    }
  }

  static fromJS(data: any): AddressDetail {
    data = typeof data === 'object' ? data : {}
    let result = new AddressDetail()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['id'] = this.id
    data['addressTypeInd'] = this.addressTypeInd
    data['province'] = this.province
    data['originalAddress1'] = this.originalAddress1
    data['originalAddress2'] = this.originalAddress2
    data['originalAddress3'] = this.originalAddress3
    data['originalAddress4'] = this.originalAddress4
    data['fullAddress'] = this.fullAddress
    data['originalPostalCode'] = this.originalPostalCode
    data['occupantTypeInd'] = this.occupantTypeInd
    data['lastUpdatedDate'] = this.lastUpdatedDate
      ? this.lastUpdatedDate.toISOString()
      : <any>undefined
    data['createdOnDate'] = this.createdOnDate
      ? this.createdOnDate.toISOString()
      : <any>undefined
    data['recordstatusind'] = this.recordstatusind
    data['town'] = this.town
    data['region'] = this.region
    return data
  }
}

export interface IAddressDetail {
  id?: string
  addressTypeInd?: string
  province?: string
  originalAddress1?: string
  originalAddress2?: string
  originalAddress3?: string
  originalAddress4?: string
  fullAddress?: string
  originalPostalCode?: string
  occupantTypeInd?: string
  lastUpdatedDate?: Date
  createdOnDate?: Date
  recordstatusind: number
  town?: string
  region?: string
}

export class DirectorShip implements IDirectorShip {
  directoraddresses?: DirectorAddressVm[]
  directortelephones?: DirectorTelephoneVM[]
  id?: string
  companyno?: string
  consumerId: number
  companyname?: string
  status?: string
  date?: Date
  companyid: number
  idNumber?: string
  fullName?: string
  firstInitial?: string
  secondname?: string
  secondInitial?: string
  gender?: string
  surname?: string
  surnamePrevious?: string
  birthDate?: Date
  appointmentDate?: Date
  directorStatusDate?: Date
  isRSAResidentYN?: string
  registerNo?: string
  trusteeOf?: string
  memberSize?: number
  memberControlPerc?: number
  directorSetDate?: Date
  profession?: string
  estate?: string
  lastUpdatedDate?: Date
  directorDesignationCode?: string
  directorStatusCode?: string
  directorTypeCode?: string
  createdOnDate?: Date
  commDirId?: string

  constructor(data?: IDirectorShip) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      if (
        data['directoraddresses'] &&
        data['directoraddresses'].constructor === Array
      ) {
        this.directoraddresses = []
        for (let item of data['directoraddresses'])
          this.directoraddresses.push(DirectorAddressVm.fromJS(item))
      }
      if (
        data['directortelephones'] &&
        data['directortelephones'].constructor === Array
      ) {
        this.directortelephones = []
        for (let item of data['directortelephones'])
          this.directortelephones.push(DirectorTelephoneVM.fromJS(item))
      }
      this.id = data['id']
      this.companyno = data['companyno']
      this.consumerId = data['consumerId']
      this.companyname = data['companyname']
      this.status = data['status']
      this.date = data['date']
        ? new Date(data['date'].toString())
        : <any>undefined
      this.companyid = data['companyid']
      this.idNumber = data['idNumber']
      this.fullName = data['fullName']
      this.firstInitial = data['firstInitial']
      this.secondname = data['secondname']
      this.secondInitial = data['secondInitial']
      this.gender = data['gender']
      this.surname = data['surname']
      this.surnamePrevious = data['surnamePrevious']
      this.birthDate = data['birthDate']
        ? new Date(data['birthDate'].toString())
        : <any>undefined
      this.appointmentDate = data['appointmentDate']
        ? new Date(data['appointmentDate'].toString())
        : <any>undefined
      this.directorStatusDate = data['directorStatusDate']
        ? new Date(data['directorStatusDate'].toString())
        : <any>undefined
      this.isRSAResidentYN = data['isRSAResidentYN']
      this.registerNo = data['registerNo']
      this.trusteeOf = data['trusteeOf']
      this.memberSize = data['memberSize']
      this.memberControlPerc = data['memberControlPerc']
      this.directorSetDate = data['directorSetDate']
        ? new Date(data['directorSetDate'].toString())
        : <any>undefined
      this.profession = data['profession']
      this.estate = data['estate']
      this.lastUpdatedDate = data['lastUpdatedDate']
        ? new Date(data['lastUpdatedDate'].toString())
        : <any>undefined
      this.directorDesignationCode = data['directorDesignationCode']
      this.directorStatusCode = data['directorStatusCode']
      this.directorTypeCode = data['directorTypeCode']
      this.createdOnDate = data['createdOnDate']
        ? new Date(data['createdOnDate'].toString())
        : <any>undefined
      this.commDirId = data['commDirId']
    }
  }

  static fromJS(data: any): DirectorShip {
    data = typeof data === 'object' ? data : {}
    let result = new DirectorShip()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    if (
      this.directoraddresses &&
      this.directoraddresses.constructor === Array
    ) {
      data['directoraddresses'] = []
      for (let item of this.directoraddresses)
        data['directoraddresses'].push(item.toJSON())
    }
    if (
      this.directortelephones &&
      this.directortelephones.constructor === Array
    ) {
      data['directortelephones'] = []
      for (let item of this.directortelephones)
        data['directortelephones'].push(item.toJSON())
    }
    data['id'] = this.id
    data['companyno'] = this.companyno
    data['consumerId'] = this.consumerId
    data['companyname'] = this.companyname
    data['status'] = this.status
    data['date'] = this.date ? this.date.toISOString() : <any>undefined
    data['companyid'] = this.companyid
    data['idNumber'] = this.idNumber
    data['fullName'] = this.fullName
    data['firstInitial'] = this.firstInitial
    data['secondname'] = this.secondname
    data['secondInitial'] = this.secondInitial
    data['gender'] = this.gender
    data['surname'] = this.surname
    data['surnamePrevious'] = this.surnamePrevious
    data['birthDate'] = this.birthDate
      ? this.birthDate.toISOString()
      : <any>undefined
    data['appointmentDate'] = this.appointmentDate
      ? this.appointmentDate.toISOString()
      : <any>undefined
    data['directorStatusDate'] = this.directorStatusDate
      ? this.directorStatusDate.toISOString()
      : <any>undefined
    data['isRSAResidentYN'] = this.isRSAResidentYN
    data['registerNo'] = this.registerNo
    data['trusteeOf'] = this.trusteeOf
    data['memberSize'] = this.memberSize
    data['memberControlPerc'] = this.memberControlPerc
    data['directorSetDate'] = this.directorSetDate
      ? this.directorSetDate.toISOString()
      : <any>undefined
    data['profession'] = this.profession
    data['estate'] = this.estate
    data['lastUpdatedDate'] = this.lastUpdatedDate
      ? this.lastUpdatedDate.toISOString()
      : <any>undefined
    data['directorDesignationCode'] = this.directorDesignationCode
    data['directorStatusCode'] = this.directorStatusCode
    data['directorTypeCode'] = this.directorTypeCode
    data['createdOnDate'] = this.createdOnDate
      ? this.createdOnDate.toISOString()
      : <any>undefined
    data['commDirId'] = this.commDirId
    return data
  }
}

export interface IDirectorShip {
  directoraddresses?: DirectorAddressVm[]
  directortelephones?: DirectorTelephoneVM[]
  id?: string
  companyno?: string
  consumerId: number
  companyname?: string
  status?: string
  date?: Date
  companyid: number
  idNumber?: string
  fullName?: string
  firstInitial?: string
  secondname?: string
  secondInitial?: string
  gender?: string
  surname?: string
  surnamePrevious?: string
  birthDate?: Date
  appointmentDate?: Date
  directorStatusDate?: Date
  isRSAResidentYN?: string
  registerNo?: string
  trusteeOf?: string
  memberSize?: number
  memberControlPerc?: number
  directorSetDate?: Date
  profession?: string
  estate?: string
  lastUpdatedDate?: Date
  directorDesignationCode?: string
  directorStatusCode?: string
  directorTypeCode?: string
  createdOnDate?: Date
  commDirId?: string
}

export class DirectorAddressVm implements IDirectorAddressVm {
  directorID: number
  director?: Director
  directorAddressID: number
  addressTypeInd?: string
  province?: string
  originalAddress1?: string
  originalAddress2?: string
  originalAddress3?: string
  originalAddress4?: string
  originalPostalCode?: string
  occupantTypeInd?: string
  lastUpdatedDate: Date
  createdOnDate: Date
  directorFullAddress?: string

  constructor(data?: IDirectorAddressVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.directorID = data['directorID']
      this.director = data['director']
        ? Director.fromJS(data['director'])
        : <any>undefined
      this.directorAddressID = data['directorAddressID']
      this.addressTypeInd = data['addressTypeInd']
      this.province = data['province']
      this.originalAddress1 = data['originalAddress1']
      this.originalAddress2 = data['originalAddress2']
      this.originalAddress3 = data['originalAddress3']
      this.originalAddress4 = data['originalAddress4']
      this.originalPostalCode = data['originalPostalCode']
      this.occupantTypeInd = data['occupantTypeInd']
      this.lastUpdatedDate = data['lastUpdatedDate']
        ? new Date(data['lastUpdatedDate'].toString())
        : <any>undefined
      this.createdOnDate = data['createdOnDate']
        ? new Date(data['createdOnDate'].toString())
        : <any>undefined
      this.directorFullAddress = data['directorFullAddress']
    }
  }

  static fromJS(data: any): DirectorAddressVm {
    data = typeof data === 'object' ? data : {}
    let result = new DirectorAddressVm()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['directorID'] = this.directorID
    data['director'] = this.director ? this.director.toJSON() : <any>undefined
    data['directorAddressID'] = this.directorAddressID
    data['addressTypeInd'] = this.addressTypeInd
    data['province'] = this.province
    data['originalAddress1'] = this.originalAddress1
    data['originalAddress2'] = this.originalAddress2
    data['originalAddress3'] = this.originalAddress3
    data['originalAddress4'] = this.originalAddress4
    data['originalPostalCode'] = this.originalPostalCode
    data['occupantTypeInd'] = this.occupantTypeInd
    data['lastUpdatedDate'] = this.lastUpdatedDate
      ? this.lastUpdatedDate.toISOString()
      : <any>undefined
    data['createdOnDate'] = this.createdOnDate
      ? this.createdOnDate.toISOString()
      : <any>undefined
    data['directorFullAddress'] = this.directorFullAddress
    return data
  }
}

export interface IDirectorAddressVm {
  directorID: number
  director?: Director
  directorAddressID: number
  addressTypeInd?: string
  province?: string
  originalAddress1?: string
  originalAddress2?: string
  originalAddress3?: string
  originalAddress4?: string
  originalPostalCode?: string
  occupantTypeInd?: string
  lastUpdatedDate: Date
  createdOnDate: Date
  directorFullAddress?: string
}

export class Director implements IDirector {
  directorID: number
  firstInitial?: string
  secondInitial?: string
  firstName?: string
  secondName?: string
  surname?: string
  surnameParticular?: string
  surnamePrevious?: string
  idNo?: string
  birthDate?: Date
  appointmentDate?: Date
  directorStatusDate?: Date
  isRSAResidentYN?: boolean
  registerNo?: string
  trusteeOf?: string
  memberSize?: number
  memberControlPerc?: number
  directorSetDate?: Date
  profession?: string
  estate?: string
  directorDesignationCode?: string
  directorStatusCode?: string
  directorTypeCode?: string
  lastUpdatedDate?: Date
  recordStatusInd?: string

  constructor(data?: IDirector) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.directorID = data['directorID']
      this.firstInitial = data['firstInitial']
      this.secondInitial = data['secondInitial']
      this.firstName = data['firstName']
      this.secondName = data['secondName']
      this.surname = data['surname']
      this.surnameParticular = data['surnameParticular']
      this.surnamePrevious = data['surnamePrevious']
      this.idNo = data['idNo']
      this.birthDate = data['birthDate']
        ? new Date(data['birthDate'].toString())
        : <any>undefined
      this.appointmentDate = data['appointmentDate']
        ? new Date(data['appointmentDate'].toString())
        : <any>undefined
      this.directorStatusDate = data['directorStatusDate']
        ? new Date(data['directorStatusDate'].toString())
        : <any>undefined
      this.isRSAResidentYN = data['isRSAResidentYN']
      this.registerNo = data['registerNo']
      this.trusteeOf = data['trusteeOf']
      this.memberSize = data['memberSize']
      this.memberControlPerc = data['memberControlPerc']
      this.directorSetDate = data['directorSetDate']
        ? new Date(data['directorSetDate'].toString())
        : <any>undefined
      this.profession = data['profession']
      this.estate = data['estate']
      this.directorDesignationCode = data['directorDesignationCode']
      this.directorStatusCode = data['directorStatusCode']
      this.directorTypeCode = data['directorTypeCode']
      this.lastUpdatedDate = data['lastUpdatedDate']
        ? new Date(data['lastUpdatedDate'].toString())
        : <any>undefined
      this.recordStatusInd = data['recordStatusInd']
    }
  }

  static fromJS(data: any): Director {
    data = typeof data === 'object' ? data : {}
    let result = new Director()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['directorID'] = this.directorID
    data['firstInitial'] = this.firstInitial
    data['secondInitial'] = this.secondInitial
    data['firstName'] = this.firstName
    data['secondName'] = this.secondName
    data['surname'] = this.surname
    data['surnameParticular'] = this.surnameParticular
    data['surnamePrevious'] = this.surnamePrevious
    data['idNo'] = this.idNo
    data['birthDate'] = this.birthDate
      ? this.birthDate.toISOString()
      : <any>undefined
    data['appointmentDate'] = this.appointmentDate
      ? this.appointmentDate.toISOString()
      : <any>undefined
    data['directorStatusDate'] = this.directorStatusDate
      ? this.directorStatusDate.toISOString()
      : <any>undefined
    data['isRSAResidentYN'] = this.isRSAResidentYN
    data['registerNo'] = this.registerNo
    data['trusteeOf'] = this.trusteeOf
    data['memberSize'] = this.memberSize
    data['memberControlPerc'] = this.memberControlPerc
    data['directorSetDate'] = this.directorSetDate
      ? this.directorSetDate.toISOString()
      : <any>undefined
    data['profession'] = this.profession
    data['estate'] = this.estate
    data['directorDesignationCode'] = this.directorDesignationCode
    data['directorStatusCode'] = this.directorStatusCode
    data['directorTypeCode'] = this.directorTypeCode
    data['lastUpdatedDate'] = this.lastUpdatedDate
      ? this.lastUpdatedDate.toISOString()
      : <any>undefined
    data['recordStatusInd'] = this.recordStatusInd
    return data
  }
}

export interface IDirector {
  directorID: number
  firstInitial?: string
  secondInitial?: string
  firstName?: string
  secondName?: string
  surname?: string
  surnameParticular?: string
  surnamePrevious?: string
  idNo?: string
  birthDate?: Date
  appointmentDate?: Date
  directorStatusDate?: Date
  isRSAResidentYN?: boolean
  registerNo?: string
  trusteeOf?: string
  memberSize?: number
  memberControlPerc?: number
  directorSetDate?: Date
  profession?: string
  estate?: string
  directorDesignationCode?: string
  directorStatusCode?: string
  directorTypeCode?: string
  lastUpdatedDate?: Date
  recordStatusInd?: string
}

export class DirectorTelephoneVM implements IDirectorTelephoneVM {
  telephoneTypeInd?: string
  telephoneCode?: string
  telephoneNo?: string
  deletedReason?: string
  lastUpdatedDate: Date
  createdOnDate: Date
  directorTelephone?: string

  constructor(data?: IDirectorTelephoneVM) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.telephoneTypeInd = data['telephoneTypeInd']
      this.telephoneCode = data['telephoneCode']
      this.telephoneNo = data['telephoneNo']
      this.deletedReason = data['deletedReason']
      this.lastUpdatedDate = data['lastUpdatedDate']
        ? new Date(data['lastUpdatedDate'].toString())
        : <any>undefined
      this.createdOnDate = data['createdOnDate']
        ? new Date(data['createdOnDate'].toString())
        : <any>undefined
      this.directorTelephone = data['directorTelephone']
    }
  }

  static fromJS(data: any): DirectorTelephoneVM {
    data = typeof data === 'object' ? data : {}
    let result = new DirectorTelephoneVM()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['telephoneTypeInd'] = this.telephoneTypeInd
    data['telephoneCode'] = this.telephoneCode
    data['telephoneNo'] = this.telephoneNo
    data['deletedReason'] = this.deletedReason
    data['lastUpdatedDate'] = this.lastUpdatedDate
      ? this.lastUpdatedDate.toISOString()
      : <any>undefined
    data['createdOnDate'] = this.createdOnDate
      ? this.createdOnDate.toISOString()
      : <any>undefined
    data['directorTelephone'] = this.directorTelephone
    return data
  }
}

export interface IDirectorTelephoneVM {
  telephoneTypeInd?: string
  telephoneCode?: string
  telephoneNo?: string
  deletedReason?: string
  lastUpdatedDate: Date
  createdOnDate: Date
  directorTelephone?: string
}

export class CommercialJudgement implements ICommercialJudgement {
  commercialID: number
  commercialJudgmentID: number
  commercialName?: string
  address1?: string
  address2?: string
  address3?: string
  address4?: string
  postalCode?: string
  homeTelephoneCode?: string
  homeTelephoneNo?: string
  workTelephoneCode?: string
  workTelephoneNo?: string
  cellularNo?: string
  faxCode?: string
  faxNo?: string
  caseNumber?: string
  caseFilingDate?: Date
  caseType?: string
  caseReason?: string
  disputeAmt?: number
  courtName?: string
  courtCity?: string
  courtType?: string
  courtCaseID?: number
  plaintiffName?: string
  plaintiff1Address?: string
  attorneyName?: string
  attorneyTelephoneCode?: string
  attorneyTelephoneNo?: string
  attorneyFaxCode?: string
  attorneyFaxNo?: string
  attorneyAddress1?: string
  attorneyAddress2?: string
  attorneyAddress3?: string
  attorneyAddress4?: string
  attorneyPostalCode?: string
  referenceNo?: string
  lastUpdatedDate?: Date
  createdOnDate?: Date
  disputeDate?: Date
  disputeResolvedDate?: Date
  rescinded?: boolean
  rescissionDate?: Date
  rescissionReason?: string
  rescindedAmount?: string

  constructor(data?: ICommercialJudgement) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.commercialID = data['commercialID']
      this.commercialJudgmentID = data['commercialJudgmentID']
      this.commercialName = data['commercialName']
      this.address1 = data['address1']
      this.address2 = data['address2']
      this.address3 = data['address3']
      this.address4 = data['address4']
      this.postalCode = data['postalCode']
      this.homeTelephoneCode = data['homeTelephoneCode']
      this.homeTelephoneNo = data['homeTelephoneNo']
      this.workTelephoneCode = data['workTelephoneCode']
      this.workTelephoneNo = data['workTelephoneNo']
      this.cellularNo = data['cellularNo']
      this.faxCode = data['faxCode']
      this.faxNo = data['faxNo']
      this.caseNumber = data['caseNumber']
      this.caseFilingDate = data['caseFilingDate']
        ? new Date(data['caseFilingDate'].toString())
        : <any>undefined
      this.caseType = data['caseType']
      this.caseReason = data['caseReason']
      this.disputeAmt = data['disputeAmt']
      this.courtName = data['courtName']
      this.courtCity = data['courtCity']
      this.courtType = data['courtType']
      this.courtCaseID = data['courtCaseID']
      this.plaintiffName = data['plaintiffName']
      this.plaintiff1Address = data['plaintiff1Address']
      this.attorneyName = data['attorneyName']
      this.attorneyTelephoneCode = data['attorneyTelephoneCode']
      this.attorneyTelephoneNo = data['attorneyTelephoneNo']
      this.attorneyFaxCode = data['attorneyFaxCode']
      this.attorneyFaxNo = data['attorneyFaxNo']
      this.attorneyAddress1 = data['attorneyAddress1']
      this.attorneyAddress2 = data['attorneyAddress2']
      this.attorneyAddress3 = data['attorneyAddress3']
      this.attorneyAddress4 = data['attorneyAddress4']
      this.attorneyPostalCode = data['attorneyPostalCode']
      this.referenceNo = data['referenceNo']
      this.lastUpdatedDate = data['lastUpdatedDate']
        ? new Date(data['lastUpdatedDate'].toString())
        : <any>undefined
      this.createdOnDate = data['createdOnDate']
        ? new Date(data['createdOnDate'].toString())
        : <any>undefined
      this.disputeDate = data['disputeDate']
        ? new Date(data['disputeDate'].toString())
        : <any>undefined
      this.disputeResolvedDate = data['disputeResolvedDate']
        ? new Date(data['disputeResolvedDate'].toString())
        : <any>undefined
      this.rescinded = data['rescinded']
      this.rescissionDate = data['rescissionDate']
        ? new Date(data['rescissionDate'].toString())
        : <any>undefined
      this.rescissionReason = data['rescissionReason']
      this.rescindedAmount = data['rescindedAmount']
    }
  }

  static fromJS(data: any): CommercialJudgement {
    data = typeof data === 'object' ? data : {}
    let result = new CommercialJudgement()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['commercialID'] = this.commercialID
    data['commercialJudgmentID'] = this.commercialJudgmentID
    data['commercialName'] = this.commercialName
    data['address1'] = this.address1
    data['address2'] = this.address2
    data['address3'] = this.address3
    data['address4'] = this.address4
    data['postalCode'] = this.postalCode
    data['homeTelephoneCode'] = this.homeTelephoneCode
    data['homeTelephoneNo'] = this.homeTelephoneNo
    data['workTelephoneCode'] = this.workTelephoneCode
    data['workTelephoneNo'] = this.workTelephoneNo
    data['cellularNo'] = this.cellularNo
    data['faxCode'] = this.faxCode
    data['faxNo'] = this.faxNo
    data['caseNumber'] = this.caseNumber
    data['caseFilingDate'] = this.caseFilingDate
      ? this.caseFilingDate.toISOString()
      : <any>undefined
    data['caseType'] = this.caseType
    data['caseReason'] = this.caseReason
    data['disputeAmt'] = this.disputeAmt
    data['courtName'] = this.courtName
    data['courtCity'] = this.courtCity
    data['courtType'] = this.courtType
    data['courtCaseID'] = this.courtCaseID
    data['plaintiffName'] = this.plaintiffName
    data['plaintiff1Address'] = this.plaintiff1Address
    data['attorneyName'] = this.attorneyName
    data['attorneyTelephoneCode'] = this.attorneyTelephoneCode
    data['attorneyTelephoneNo'] = this.attorneyTelephoneNo
    data['attorneyFaxCode'] = this.attorneyFaxCode
    data['attorneyFaxNo'] = this.attorneyFaxNo
    data['attorneyAddress1'] = this.attorneyAddress1
    data['attorneyAddress2'] = this.attorneyAddress2
    data['attorneyAddress3'] = this.attorneyAddress3
    data['attorneyAddress4'] = this.attorneyAddress4
    data['attorneyPostalCode'] = this.attorneyPostalCode
    data['referenceNo'] = this.referenceNo
    data['lastUpdatedDate'] = this.lastUpdatedDate
      ? this.lastUpdatedDate.toISOString()
      : <any>undefined
    data['createdOnDate'] = this.createdOnDate
      ? this.createdOnDate.toISOString()
      : <any>undefined
    data['disputeDate'] = this.disputeDate
      ? this.disputeDate.toISOString()
      : <any>undefined
    data['disputeResolvedDate'] = this.disputeResolvedDate
      ? this.disputeResolvedDate.toISOString()
      : <any>undefined
    data['rescinded'] = this.rescinded
    data['rescissionDate'] = this.rescissionDate
      ? this.rescissionDate.toISOString()
      : <any>undefined
    data['rescissionReason'] = this.rescissionReason
    data['rescindedAmount'] = this.rescindedAmount
    return data
  }
}

export interface ICommercialJudgement {
  commercialID: number
  commercialJudgmentID: number
  commercialName?: string
  address1?: string
  address2?: string
  address3?: string
  address4?: string
  postalCode?: string
  homeTelephoneCode?: string
  homeTelephoneNo?: string
  workTelephoneCode?: string
  workTelephoneNo?: string
  cellularNo?: string
  faxCode?: string
  faxNo?: string
  caseNumber?: string
  caseFilingDate?: Date
  caseType?: string
  caseReason?: string
  disputeAmt?: number
  courtName?: string
  courtCity?: string
  courtType?: string
  courtCaseID?: number
  plaintiffName?: string
  plaintiff1Address?: string
  attorneyName?: string
  attorneyTelephoneCode?: string
  attorneyTelephoneNo?: string
  attorneyFaxCode?: string
  attorneyFaxNo?: string
  attorneyAddress1?: string
  attorneyAddress2?: string
  attorneyAddress3?: string
  attorneyAddress4?: string
  attorneyPostalCode?: string
  referenceNo?: string
  lastUpdatedDate?: Date
  createdOnDate?: Date
  disputeDate?: Date
  disputeResolvedDate?: Date
  rescinded?: boolean
  rescissionDate?: Date
  rescissionReason?: string
  rescindedAmount?: string
}

export class PropertyDeedDetail implements IPropertyDeedDetail {
  id?: string
  consumerid?: string
  deedsOfficeId?: string
  type?: string
  saleDate: Date
  address?: string
  province?: string
  property?: string
  titleDeedNo?: string
  titleDeedNoOLD?: string
  titleDeedFee?: number
  datePurchase?: Date
  dateRegister?: Date
  purchaseAmount?: number
  streetAddress?: string
  streetNumber?: string
  streetName?: string
  streetType?: string
  y?: number
  x?: number
  suburbCode?: string
  suburbDeeds?: string
  town?: string
  authority?: string
  municipalityName?: string
  provinceId?: string
  isCurrentOwner?: boolean
  extent?: string
  attorneyFirmNumber?: string
  attorneyFileNumber?: string
  transferSeqNo?: number
  dateCaptured?: Date
  bondNumber?: string
  bondHolder?: string
  bondAmount?: number
  propertyType?: string
  propertyName?: string
  schemeId?: string
  suburbId?: number
  erf?: string
  portion?: number
  unit?: number
  createdOndate?: Date
  erfSize?: string
  standNo?: string
  portionNo?: string
  townShipNo?: number
  prevExtent?: string
  isCurrOwnerUpdated?: string
  propertyDeedId: number
  buyerIDNO?: string
  buyerid?: string
  buyerName?: string
  buyerType?: string
  buyerStatus?: string
  share?: string
  sellerIDNO?: string
  sellerName?: string
  sellerType?: string
  sellerStatus?: string
  endorsementNumber?: string
  endorsementHolder?: string
  endorsementAmount?: string
  sellarid?: string
  transferdate: Date
  transferid?: string
  fullAddress?: string

  constructor(data?: IPropertyDeedDetail) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.id = data['id']
      this.consumerid = data['consumerid']
      this.deedsOfficeId = data['deedsOfficeId']
      this.type = data['type']
      this.saleDate = data['saleDate']
        ? new Date(data['saleDate'].toString())
        : <any>undefined
      this.address = data['address']
      this.province = data['province']
      this.property = data['property']
      this.titleDeedNo = data['titleDeedNo']
      this.titleDeedNoOLD = data['titleDeedNoOLD']
      this.titleDeedFee = data['titleDeedFee']
      this.datePurchase = data['datePurchase']
        ? new Date(data['datePurchase'].toString())
        : <any>undefined
      this.dateRegister = data['dateRegister']
        ? new Date(data['dateRegister'].toString())
        : <any>undefined
      this.purchaseAmount = data['purchaseAmount']
      this.streetAddress = data['streetAddress']
      this.streetNumber = data['streetNumber']
      this.streetName = data['streetName']
      this.streetType = data['streetType']
      this.y = data['y']
      this.x = data['x']
      this.suburbCode = data['suburbCode']
      this.suburbDeeds = data['suburbDeeds']
      this.town = data['town']
      this.authority = data['authority']
      this.municipalityName = data['municipalityName']
      this.provinceId = data['provinceId']
      this.isCurrentOwner = data['isCurrentOwner']
      this.extent = data['extent']
      this.attorneyFirmNumber = data['attorneyFirmNumber']
      this.attorneyFileNumber = data['attorneyFileNumber']
      this.transferSeqNo = data['transferSeqNo']
      this.dateCaptured = data['dateCaptured']
        ? new Date(data['dateCaptured'].toString())
        : <any>undefined
      this.bondNumber = data['bondNumber']
      this.bondHolder = data['bondHolder']
      this.bondAmount = data['bondAmount']
      this.propertyType = data['propertyType']
      this.propertyName = data['propertyName']
      this.schemeId = data['schemeId']
      this.suburbId = data['suburbId']
      this.erf = data['erf']
      this.portion = data['portion']
      this.unit = data['unit']
      this.createdOndate = data['createdOndate']
        ? new Date(data['createdOndate'].toString())
        : <any>undefined
      this.erfSize = data['erfSize']
      this.standNo = data['standNo']
      this.portionNo = data['portionNo']
      this.townShipNo = data['townShipNo']
      this.prevExtent = data['prevExtent']
      this.isCurrOwnerUpdated = data['isCurrOwnerUpdated']
      this.propertyDeedId = data['propertyDeedId']
      this.buyerIDNO = data['buyerIDNO']
      this.buyerid = data['buyerid']
      this.buyerName = data['buyerName']
      this.buyerType = data['buyerType']
      this.buyerStatus = data['buyerStatus']
      this.share = data['share']
      this.sellerIDNO = data['sellerIDNO']
      this.sellerName = data['sellerName']
      this.sellerType = data['sellerType']
      this.sellerStatus = data['sellerStatus']
      this.endorsementNumber = data['endorsementNumber']
      this.endorsementHolder = data['endorsementHolder']
      this.endorsementAmount = data['endorsementAmount']
      this.sellarid = data['sellarid']
      this.transferdate = data['transferdate']
        ? new Date(data['transferdate'].toString())
        : <any>undefined
      this.transferid = data['transferid']
      this.fullAddress = data['fullAddress']
    }
  }

  static fromJS(data: any): PropertyDeedDetail {
    data = typeof data === 'object' ? data : {}
    let result = new PropertyDeedDetail()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['id'] = this.id
    data['consumerid'] = this.consumerid
    data['deedsOfficeId'] = this.deedsOfficeId
    data['type'] = this.type
    data['saleDate'] = this.saleDate
      ? this.saleDate.toISOString()
      : <any>undefined
    data['address'] = this.address
    data['province'] = this.province
    data['property'] = this.property
    data['titleDeedNo'] = this.titleDeedNo
    data['titleDeedNoOLD'] = this.titleDeedNoOLD
    data['titleDeedFee'] = this.titleDeedFee
    data['datePurchase'] = this.datePurchase
      ? this.datePurchase.toISOString()
      : <any>undefined
    data['dateRegister'] = this.dateRegister
      ? this.dateRegister.toISOString()
      : <any>undefined
    data['purchaseAmount'] = this.purchaseAmount
    data['streetAddress'] = this.streetAddress
    data['streetNumber'] = this.streetNumber
    data['streetName'] = this.streetName
    data['streetType'] = this.streetType
    data['y'] = this.y
    data['x'] = this.x
    data['suburbCode'] = this.suburbCode
    data['suburbDeeds'] = this.suburbDeeds
    data['town'] = this.town
    data['authority'] = this.authority
    data['municipalityName'] = this.municipalityName
    data['provinceId'] = this.provinceId
    data['isCurrentOwner'] = this.isCurrentOwner
    data['extent'] = this.extent
    data['attorneyFirmNumber'] = this.attorneyFirmNumber
    data['attorneyFileNumber'] = this.attorneyFileNumber
    data['transferSeqNo'] = this.transferSeqNo
    data['dateCaptured'] = this.dateCaptured
      ? this.dateCaptured.toISOString()
      : <any>undefined
    data['bondNumber'] = this.bondNumber
    data['bondHolder'] = this.bondHolder
    data['bondAmount'] = this.bondAmount
    data['propertyType'] = this.propertyType
    data['propertyName'] = this.propertyName
    data['schemeId'] = this.schemeId
    data['suburbId'] = this.suburbId
    data['erf'] = this.erf
    data['portion'] = this.portion
    data['unit'] = this.unit
    data['createdOndate'] = this.createdOndate
      ? this.createdOndate.toISOString()
      : <any>undefined
    data['erfSize'] = this.erfSize
    data['standNo'] = this.standNo
    data['portionNo'] = this.portionNo
    data['townShipNo'] = this.townShipNo
    data['prevExtent'] = this.prevExtent
    data['isCurrOwnerUpdated'] = this.isCurrOwnerUpdated
    data['propertyDeedId'] = this.propertyDeedId
    data['buyerIDNO'] = this.buyerIDNO
    data['buyerid'] = this.buyerid
    data['buyerName'] = this.buyerName
    data['buyerType'] = this.buyerType
    data['buyerStatus'] = this.buyerStatus
    data['share'] = this.share
    data['sellerIDNO'] = this.sellerIDNO
    data['sellerName'] = this.sellerName
    data['sellerType'] = this.sellerType
    data['sellerStatus'] = this.sellerStatus
    data['endorsementNumber'] = this.endorsementNumber
    data['endorsementHolder'] = this.endorsementHolder
    data['endorsementAmount'] = this.endorsementAmount
    data['sellarid'] = this.sellarid
    data['transferdate'] = this.transferdate
      ? this.transferdate.toISOString()
      : <any>undefined
    data['transferid'] = this.transferid
    data['fullAddress'] = this.fullAddress

    return data
  }
}

export interface IPropertyDeedDetail {
  id?: string
  consumerid?: string
  deedsOfficeId?: string
  type?: string
  saleDate: Date
  address?: string
  province?: string
  property?: string
  titleDeedNo?: string
  titleDeedNoOLD?: string
  titleDeedFee?: number
  datePurchase?: Date
  dateRegister?: Date
  purchaseAmount?: number
  streetAddress?: string
  streetNumber?: string
  streetName?: string
  streetType?: string
  y?: number
  x?: number
  suburbCode?: string
  suburbDeeds?: string
  town?: string
  authority?: string
  municipalityName?: string
  provinceId?: string
  isCurrentOwner?: boolean
  extent?: string
  attorneyFirmNumber?: string
  attorneyFileNumber?: string
  transferSeqNo?: number
  dateCaptured?: Date
  bondNumber?: string
  bondHolder?: string
  bondAmount?: number
  propertyType?: string
  propertyName?: string
  schemeId?: string
  suburbId?: number
  erf?: string
  portion?: number
  unit?: number
  createdOndate?: Date
  erfSize?: string
  standNo?: string
  portionNo?: string
  townShipNo?: number
  prevExtent?: string
  isCurrOwnerUpdated?: string
  propertyDeedId: number
  buyerIDNO?: string
  buyerid?: string
  buyerName?: string
  buyerType?: string
  buyerStatus?: string
  share?: string
  sellerIDNO?: string
  sellerName?: string
  sellerType?: string
  sellerStatus?: string
  endorsementNumber?: string
  endorsementHolder?: string
  endorsementAmount?: string
  sellarid?: string
  transferdate: Date
  transferid?: string
  fullAddress?: string
}

export class CommercialAuditorVm implements ICommercialAuditorVm {
  auditoraddresess?: AuditorAddressVM[]
  commercialID: number
  commercial?: Commercial
  commercialAuditorID: number
  auditorName?: string
  actStartDate?: Date
  actEndDate?: Date
  lastUpdatedDate?: Date
  professionCode?: string
  auditorTypeCode?: string
  auditorStatusCode?: string
  professionNo?: string
  auditorID?: number
  createdOnDate?: Date

  constructor(data?: ICommercialAuditorVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      if (
        data['auditoraddresess'] &&
        data['auditoraddresess'].constructor === Array
      ) {
        this.auditoraddresess = []
        for (let item of data['auditoraddresess'])
          this.auditoraddresess.push(AuditorAddressVM.fromJS(item))
      }
      this.commercialID = data['commercialID']
      this.commercial = data['commercial']
        ? Commercial.fromJS(data['commercial'])
        : <any>undefined
      this.commercialAuditorID = data['commercialAuditorID']
      this.auditorName = data['auditorName']
      this.actStartDate = data['actStartDate']
        ? new Date(data['actStartDate'].toString())
        : <any>undefined
      this.actEndDate = data['actEndDate']
        ? new Date(data['actEndDate'].toString())
        : <any>undefined
      this.lastUpdatedDate = data['lastUpdatedDate']
        ? new Date(data['lastUpdatedDate'].toString())
        : <any>undefined
      this.professionCode = data['professionCode']
      this.auditorTypeCode = data['auditorTypeCode']
      this.auditorStatusCode = data['auditorStatusCode']
      this.professionNo = data['professionNo']
      this.auditorID = data['auditorID']
      this.createdOnDate = data['createdOnDate']
        ? new Date(data['createdOnDate'].toString())
        : <any>undefined
    }
  }

  static fromJS(data: any): CommercialAuditorVm {
    data = typeof data === 'object' ? data : {}
    let result = new CommercialAuditorVm()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    if (this.auditoraddresess && this.auditoraddresess.constructor === Array) {
      data['auditoraddresess'] = []
      for (let item of this.auditoraddresess)
        data['auditoraddresess'].push(item.toJSON())
    }
    data['commercialID'] = this.commercialID
    data['commercial'] = this.commercial
      ? this.commercial.toJSON()
      : <any>undefined
    data['commercialAuditorID'] = this.commercialAuditorID
    data['auditorName'] = this.auditorName
    data['actStartDate'] = this.actStartDate
      ? this.actStartDate.toISOString()
      : <any>undefined
    data['actEndDate'] = this.actEndDate
      ? this.actEndDate.toISOString()
      : <any>undefined
    data['lastUpdatedDate'] = this.lastUpdatedDate
      ? this.lastUpdatedDate.toISOString()
      : <any>undefined
    data['professionCode'] = this.professionCode
    data['auditorTypeCode'] = this.auditorTypeCode
    data['auditorStatusCode'] = this.auditorStatusCode
    data['professionNo'] = this.professionNo
    data['auditorID'] = this.auditorID
    data['createdOnDate'] = this.createdOnDate
      ? this.createdOnDate.toISOString()
      : <any>undefined
    return data
  }
}

export interface ICommercialAuditorVm {
  auditoraddresess?: AuditorAddressVM[]
  commercialID: number
  commercial?: Commercial
  commercialAuditorID: number
  auditorName?: string
  actStartDate?: Date
  actEndDate?: Date
  lastUpdatedDate?: Date
  professionCode?: string
  auditorTypeCode?: string
  auditorStatusCode?: string
  professionNo?: string
  auditorID?: number
  createdOnDate?: Date
}

export class AuditorAddressVM implements IAuditorAddressVM {
  auditorID?: number
  auditor?: Auditor
  auditorAddressID: number
  addressTypeInd?: string
  originalAddress1?: string
  originalAddress2?: string
  originalAddress3?: string
  originalAddress4?: string
  originalPostalCode?: string
  auditorFullAddress?: string
  lastUpdatedDate?: Date
  createdOnDate?: Date

  constructor(data?: IAuditorAddressVM) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.auditorID = data['auditorID']
      this.auditor = data['auditor']
        ? Auditor.fromJS(data['auditor'])
        : <any>undefined
      this.auditorAddressID = data['auditorAddressID']
      this.addressTypeInd = data['addressTypeInd']
      this.originalAddress1 = data['originalAddress1']
      this.originalAddress2 = data['originalAddress2']
      this.originalAddress3 = data['originalAddress3']
      this.originalAddress4 = data['originalAddress4']
      this.originalPostalCode = data['originalPostalCode']
      this.auditorFullAddress = data['auditorFullAddress']
      this.lastUpdatedDate = data['lastUpdatedDate']
        ? new Date(data['lastUpdatedDate'].toString())
        : <any>undefined
      this.createdOnDate = data['createdOnDate']
        ? new Date(data['createdOnDate'].toString())
        : <any>undefined
    }
  }

  static fromJS(data: any): AuditorAddressVM {
    data = typeof data === 'object' ? data : {}
    let result = new AuditorAddressVM()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['auditorID'] = this.auditorID
    data['auditor'] = this.auditor ? this.auditor.toJSON() : <any>undefined
    data['auditorAddressID'] = this.auditorAddressID
    data['addressTypeInd'] = this.addressTypeInd
    data['originalAddress1'] = this.originalAddress1
    data['originalAddress2'] = this.originalAddress2
    data['originalAddress3'] = this.originalAddress3
    data['originalAddress4'] = this.originalAddress4
    data['originalPostalCode'] = this.originalPostalCode
    data['auditorFullAddress'] = this.auditorFullAddress
    data['lastUpdatedDate'] = this.lastUpdatedDate
      ? this.lastUpdatedDate.toISOString()
      : <any>undefined
    data['createdOnDate'] = this.createdOnDate
      ? this.createdOnDate.toISOString()
      : <any>undefined
    return data
  }
}

export interface IAuditorAddressVM {
  auditorID?: number
  auditor?: Auditor
  auditorAddressID: number
  addressTypeInd?: string
  originalAddress1?: string
  originalAddress2?: string
  originalAddress3?: string
  originalAddress4?: string
  originalPostalCode?: string
  auditorFullAddress?: string
  lastUpdatedDate?: Date
  createdOnDate?: Date
}

export class Auditor implements IAuditor {
  auditorID?: number
  auditorName?: string

  constructor(data?: IAuditor) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.auditorID = data['auditorID']
      this.auditorName = data['auditorName']
    }
  }

  static fromJS(data: any): Auditor {
    data = typeof data === 'object' ? data : {}
    let result = new Auditor()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['auditorID'] = this.auditorID
    data['auditorName'] = this.auditorName
    return data
  }
}

export interface IAuditor {
  auditorID?: number
  auditorName?: string
}

export class Commercial implements ICommercial {
  commercialID: number
  registrationNo?: string
  registrationNoOld?: string
  commercialName?: string
  commercialShortName?: string
  commercialTranslatedName?: string
  previousBusinessname?: string
  registrationDate?: Date
  businessStartDate?: Date
  financialYearEnd?: number
  financialEffectiveDate?: Date
  lastUpdatedDate?: Date
  sicCode?: string
  businessDesc?: string
  commercialStatusCode?: string
  commercialTypeCode?: string
  vatNo?: number
  bussEmail?: string
  bussWebsite?: string
  createdOnDate?: Date
  recordStatusInd?: string
  isESSynced: boolean
  noOfShares?: number
  amountPerShare?: number
  premium?: number
  idNo?: string
  commercialAddresses?: CommercialAddress[]
  commercialDirectors?: CommercialDirector[]
  commercialTelephones?: CommercialTelephone[]
  commercialAuditors?: CommercialAuditor[]
  commercialJudgements?: CommercialJudgement[]

  constructor(data?: ICommercial) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.commercialID = data['commercialID']
      this.registrationNo = data['registrationNo']
      this.registrationNoOld = data['registrationNoOld']
      this.commercialName = data['commercialName']
      this.commercialShortName = data['commercialShortName']
      this.commercialTranslatedName = data['commercialTranslatedName']
      this.previousBusinessname = data['previousBusinessname']
      this.registrationDate = data['registrationDate']
        ? new Date(data['registrationDate'].toString())
        : <any>undefined
      this.businessStartDate = data['businessStartDate']
        ? new Date(data['businessStartDate'].toString())
        : <any>undefined
      this.financialYearEnd = data['financialYearEnd']
      this.financialEffectiveDate = data['financialEffectiveDate']
        ? new Date(data['financialEffectiveDate'].toString())
        : <any>undefined
      this.lastUpdatedDate = data['lastUpdatedDate']
        ? new Date(data['lastUpdatedDate'].toString())
        : <any>undefined
      this.sicCode = data['sicCode']
      this.businessDesc = data['businessDesc']
      this.commercialStatusCode = data['commercialStatusCode']
      this.commercialTypeCode = data['commercialTypeCode']
      this.vatNo = data['vatNo']
      this.bussEmail = data['bussEmail']
      this.bussWebsite = data['bussWebsite']
      this.createdOnDate = data['createdOnDate']
        ? new Date(data['createdOnDate'].toString())
        : <any>undefined
      this.recordStatusInd = data['recordStatusInd']
      this.isESSynced = data['isESSynced']
      this.noOfShares = data['noOfShares']
      this.amountPerShare = data['amountPerShare']
      this.premium = data['premium']
      this.idNo = data['idNo']
      if (
        data['commercialAddresses'] &&
        data['commercialAddresses'].constructor === Array
      ) {
        this.commercialAddresses = []
        for (let item of data['commercialAddresses'])
          this.commercialAddresses.push(CommercialAddress.fromJS(item))
      }
      if (
        data['commercialDirectors'] &&
        data['commercialDirectors'].constructor === Array
      ) {
        this.commercialDirectors = []
        for (let item of data['commercialDirectors'])
          this.commercialDirectors.push(CommercialDirector.fromJS(item))
      }
      if (
        data['commercialTelephones'] &&
        data['commercialTelephones'].constructor === Array
      ) {
        this.commercialTelephones = []
        for (let item of data['commercialTelephones'])
          this.commercialTelephones.push(CommercialTelephone.fromJS(item))
      }
      if (
        data['commercialAuditors'] &&
        data['commercialAuditors'].constructor === Array
      ) {
        this.commercialAuditors = []
        for (let item of data['commercialAuditors'])
          this.commercialAuditors.push(CommercialAuditor.fromJS(item))
      }
      if (
        data['commercialJudgements'] &&
        data['commercialJudgements'].constructor === Array
      ) {
        this.commercialJudgements = []
        for (let item of data['commercialJudgements'])
          this.commercialJudgements.push(CommercialJudgement.fromJS(item))
      }
    }
  }

  static fromJS(data: any): Commercial {
    data = typeof data === 'object' ? data : {}
    let result = new Commercial()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['commercialID'] = this.commercialID
    data['registrationNo'] = this.registrationNo
    data['registrationNoOld'] = this.registrationNoOld
    data['commercialName'] = this.commercialName
    data['commercialShortName'] = this.commercialShortName
    data['commercialTranslatedName'] = this.commercialTranslatedName
    data['previousBusinessname'] = this.previousBusinessname
    data['registrationDate'] = this.registrationDate
      ? this.registrationDate.toISOString()
      : <any>undefined
    data['businessStartDate'] = this.businessStartDate
      ? this.businessStartDate.toISOString()
      : <any>undefined
    data['financialYearEnd'] = this.financialYearEnd
    data['financialEffectiveDate'] = this.financialEffectiveDate
      ? this.financialEffectiveDate.toISOString()
      : <any>undefined
    data['lastUpdatedDate'] = this.lastUpdatedDate
      ? this.lastUpdatedDate.toISOString()
      : <any>undefined
    data['sicCode'] = this.sicCode
    data['businessDesc'] = this.businessDesc
    data['commercialStatusCode'] = this.commercialStatusCode
    data['commercialTypeCode'] = this.commercialTypeCode
    data['vatNo'] = this.vatNo
    data['bussEmail'] = this.bussEmail
    data['bussWebsite'] = this.bussWebsite
    data['createdOnDate'] = this.createdOnDate
      ? this.createdOnDate.toISOString()
      : <any>undefined
    data['recordStatusInd'] = this.recordStatusInd
    data['isESSynced'] = this.isESSynced
    data['noOfShares'] = this.noOfShares
    data['amountPerShare'] = this.amountPerShare
    data['premium'] = this.premium
    data['idNo'] = this.idNo
    if (
      this.commercialAddresses &&
      this.commercialAddresses.constructor === Array
    ) {
      data['commercialAddresses'] = []
      for (let item of this.commercialAddresses)
        data['commercialAddresses'].push(item.toJSON())
    }
    if (
      this.commercialDirectors &&
      this.commercialDirectors.constructor === Array
    ) {
      data['commercialDirectors'] = []
      for (let item of this.commercialDirectors)
        data['commercialDirectors'].push(item.toJSON())
    }
    if (
      this.commercialTelephones &&
      this.commercialTelephones.constructor === Array
    ) {
      data['commercialTelephones'] = []
      for (let item of this.commercialTelephones)
        data['commercialTelephones'].push(item.toJSON())
    }
    if (
      this.commercialAuditors &&
      this.commercialAuditors.constructor === Array
    ) {
      data['commercialAuditors'] = []
      for (let item of this.commercialAuditors)
        data['commercialAuditors'].push(item.toJSON())
    }
    if (
      this.commercialJudgements &&
      this.commercialJudgements.constructor === Array
    ) {
      data['commercialJudgements'] = []
      for (let item of this.commercialJudgements)
        data['commercialJudgements'].push(item.toJSON())
    }
    return data
  }
}

export interface ICommercial {
  commercialID: number
  registrationNo?: string
  registrationNoOld?: string
  commercialName?: string
  commercialShortName?: string
  commercialTranslatedName?: string
  previousBusinessname?: string
  registrationDate?: Date
  businessStartDate?: Date
  financialYearEnd?: number
  financialEffectiveDate?: Date
  lastUpdatedDate?: Date
  sicCode?: string
  businessDesc?: string
  commercialStatusCode?: string
  commercialTypeCode?: string
  vatNo?: number
  bussEmail?: string
  bussWebsite?: string
  createdOnDate?: Date
  recordStatusInd?: string
  isESSynced: boolean
  noOfShares?: number
  amountPerShare?: number
  premium?: number
  idNo?: string
  commercialAddresses?: CommercialAddress[]
  commercialDirectors?: CommercialDirector[]
  commercialTelephones?: CommercialTelephone[]
  commercialAuditors?: CommercialAuditor[]
  commercialJudgements?: CommercialJudgement[]
}

export class CommercialAddress implements ICommercialAddress {
  commercialID: number
  commercial?: Commercial
  commercialAddressID: number
  addressTypeInd?: string
  province?: string
  originalAddress1?: string
  originalAddress2?: string
  originalAddress3?: string
  originalAddress4?: string
  originalPostalCode?: string
  occupantTypeInd?: string
  lastUpdatedDate?: Date
  createdOnDate?: Date

  constructor(data?: ICommercialAddress) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.commercialID = data['commercialID']
      this.commercial = data['commercial']
        ? Commercial.fromJS(data['commercial'])
        : <any>undefined
      this.commercialAddressID = data['commercialAddressID']
      this.addressTypeInd = data['addressTypeInd']
      this.province = data['province']
      this.originalAddress1 = data['originalAddress1']
      this.originalAddress2 = data['originalAddress2']
      this.originalAddress3 = data['originalAddress3']
      this.originalAddress4 = data['originalAddress4']
      this.originalPostalCode = data['originalPostalCode']
      this.occupantTypeInd = data['occupantTypeInd']
      this.lastUpdatedDate = data['lastUpdatedDate']
        ? new Date(data['lastUpdatedDate'].toString())
        : <any>undefined
      this.createdOnDate = data['createdOnDate']
        ? new Date(data['createdOnDate'].toString())
        : <any>undefined
    }
  }

  static fromJS(data: any): CommercialAddress {
    data = typeof data === 'object' ? data : {}
    let result = new CommercialAddress()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['commercialID'] = this.commercialID
    data['commercial'] = this.commercial
      ? this.commercial.toJSON()
      : <any>undefined
    data['commercialAddressID'] = this.commercialAddressID
    data['addressTypeInd'] = this.addressTypeInd
    data['province'] = this.province
    data['originalAddress1'] = this.originalAddress1
    data['originalAddress2'] = this.originalAddress2
    data['originalAddress3'] = this.originalAddress3
    data['originalAddress4'] = this.originalAddress4
    data['originalPostalCode'] = this.originalPostalCode
    data['occupantTypeInd'] = this.occupantTypeInd
    data['lastUpdatedDate'] = this.lastUpdatedDate
      ? this.lastUpdatedDate.toISOString()
      : <any>undefined
    data['createdOnDate'] = this.createdOnDate
      ? this.createdOnDate.toISOString()
      : <any>undefined
    return data
  }
}

export interface ICommercialAddress {
  commercialID: number
  commercial?: Commercial
  commercialAddressID: number
  addressTypeInd?: string
  province?: string
  originalAddress1?: string
  originalAddress2?: string
  originalAddress3?: string
  originalAddress4?: string
  originalPostalCode?: string
  occupantTypeInd?: string
  lastUpdatedDate?: Date
  createdOnDate?: Date
}

export class CommercialDirector implements ICommercialDirector {
  commercialID: number
  commercial?: Commercial
  commercialDirectorID: number
  directorID?: number
  director?: Director
  appointmentDate?: Date
  directorStatusDate?: Date
  isRSAResidentYN?: boolean
  registerNo?: string
  trusteeOf?: string
  memberSize?: number
  memberControlPerc?: number
  directorSetDate?: Date
  profession?: string
  estate?: string
  directorDesignationCode?: string
  directorStatusCode?: string
  directorTypeCode?: string
  createdOnDate?: Date
  recordStatusInd: string
  // krishna start
  commercialTelephoneNo? : any
  //krishna end


  constructor(data?: ICommercialDirector) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.commercialID = data['commercialID']
      this.commercial = data['commercial']
        ? Commercial.fromJS(data['commercial'])
        : <any>undefined
      this.commercialDirectorID = data['commercialDirectorID']
      this.directorID = data['directorID']
      this.director = data['director']
        ? Director.fromJS(data['director'])
        : <any>undefined
      this.appointmentDate = data['appointmentDate']
        ? new Date(data['appointmentDate'].toString())
        : <any>undefined
      this.directorStatusDate = data['directorStatusDate']
        ? new Date(data['directorStatusDate'].toString())
        : <any>undefined
      this.isRSAResidentYN = data['isRSAResidentYN']
      this.registerNo = data['registerNo']
      this.trusteeOf = data['trusteeOf']
      this.memberSize = data['memberSize']
      this.memberControlPerc = data['memberControlPerc']
      this.directorSetDate = data['directorSetDate']
        ? new Date(data['directorSetDate'].toString())
        : <any>undefined
      this.profession = data['profession']
      this.estate = data['estate']
      this.directorDesignationCode = data['directorDesignationCode']
      this.directorStatusCode = data['directorStatusCode']
      this.directorTypeCode = data['directorTypeCode']
      this.createdOnDate = data['createdOnDate']
        ? new Date(data['createdOnDate'].toString())
        : <any>undefined
      this.recordStatusInd = data['recordStatusInd']
      this.commercialTelephoneNo = data['commercialTelephoneNo']
    }
  }

  static fromJS(data: any): CommercialDirector {
    data = typeof data === 'object' ? data : {}
    let result = new CommercialDirector()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['commercialID'] = this.commercialID
    data['commercial'] = this.commercial
      ? this.commercial.toJSON()
      : <any>undefined
    data['commercialDirectorID'] = this.commercialDirectorID
    data['directorID'] = this.directorID
    data['director'] = this.director ? this.director.toJSON() : <any>undefined
    data['appointmentDate'] = this.appointmentDate
      ? this.appointmentDate.toISOString()
      : <any>undefined
    data['directorStatusDate'] = this.directorStatusDate
      ? this.directorStatusDate.toISOString()
      : <any>undefined
    data['isRSAResidentYN'] = this.isRSAResidentYN
    data['registerNo'] = this.registerNo
    data['trusteeOf'] = this.trusteeOf
    data['memberSize'] = this.memberSize
    data['memberControlPerc'] = this.memberControlPerc
    data['directorSetDate'] = this.directorSetDate
      ? this.directorSetDate.toISOString()
      : <any>undefined
    data['profession'] = this.profession
    data['estate'] = this.estate
    data['directorDesignationCode'] = this.directorDesignationCode
    data['directorStatusCode'] = this.directorStatusCode
    data['directorTypeCode'] = this.directorTypeCode
    data['createdOnDate'] = this.createdOnDate
      ? this.createdOnDate.toISOString()
      : <any>undefined
    data['recordStatusInd'] = this.recordStatusInd
    data['commercialTelephoneNo'] = this.commercialTelephoneNo

    return data
  }
}

export interface ICommercialDirector {
  commercialID: number
  commercial?: Commercial
  commercialDirectorID: number
  directorID?: number
  director?: Director
  appointmentDate?: Date
  directorStatusDate?: Date
  isRSAResidentYN?: boolean
  registerNo?: string
  trusteeOf?: string
  memberSize?: number
  memberControlPerc?: number
  directorSetDate?: Date
  profession?: string
  estate?: string
  directorDesignationCode?: string
  directorStatusCode?: string
  directorTypeCode?: string
  createdOnDate?: Date
  recordStatusInd: string

  // krishna start
  CommercialTelephoneNo?: any
  //krishna end

}

export class CommercialTelephone implements ICommercialTelephone {
  commercialID: number
  commercial?: Commercial
  commercialTelephoneID: number
  telephoneTypeInd?: string
  telephoneCode?: string
  telephoneNo?: string
  recordStatusInd?: string
  deletedReason?: string
  lastUpdatedDate: Date
  createdOnDate?: Date

  constructor(data?: ICommercialTelephone) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.commercialID = data['commercialID']
      this.commercial = data['commercial']
        ? Commercial.fromJS(data['commercial'])
        : <any>undefined
      this.commercialTelephoneID = data['commercialTelephoneID']
      this.telephoneTypeInd = data['telephoneTypeInd']
      this.telephoneCode = data['telephoneCode']
      this.telephoneNo = data['telephoneNo']
      this.recordStatusInd = data['recordStatusInd']
      this.deletedReason = data['deletedReason']
      this.lastUpdatedDate = data['lastUpdatedDate']
        ? new Date(data['lastUpdatedDate'].toString())
        : <any>undefined
      this.createdOnDate = data['createdOnDate']
        ? new Date(data['createdOnDate'].toString())
        : <any>undefined
    }
  }

  static fromJS(data: any): CommercialTelephone {
    data = typeof data === 'object' ? data : {}
    let result = new CommercialTelephone()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['commercialID'] = this.commercialID
    data['commercial'] = this.commercial
      ? this.commercial.toJSON()
      : <any>undefined
    data['commercialTelephoneID'] = this.commercialTelephoneID
    data['telephoneTypeInd'] = this.telephoneTypeInd
    data['telephoneCode'] = this.telephoneCode
    data['telephoneNo'] = this.telephoneNo
    data['recordStatusInd'] = this.recordStatusInd
    data['deletedReason'] = this.deletedReason
    data['lastUpdatedDate'] = this.lastUpdatedDate
      ? this.lastUpdatedDate.toISOString()
      : <any>undefined
    data['createdOnDate'] = this.createdOnDate
      ? this.createdOnDate.toISOString()
      : <any>undefined
    return data
  }
}

export interface ICommercialTelephone {
  commercialID: number
  commercial?: Commercial
  commercialTelephoneID: number
  telephoneTypeInd?: string
  telephoneCode?: string
  telephoneNo?: string
  recordStatusInd?: string
  deletedReason?: string
  lastUpdatedDate: Date
  createdOnDate?: Date
}

export class CommercialAuditor implements ICommercialAuditor {
  commercialID: number
  commercial?: Commercial
  commercialAuditorID: number
  auditorName?: string
  actStartDate?: Date
  actEndDate?: Date
  lastUpdatedDate?: Date
  professionCode?: string
  auditorTypeCode?: string
  auditorStatusCode?: string
  professionNo?: string
  auditorID?: number
  createdOnDate?: Date

  constructor(data?: ICommercialAuditor) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.commercialID = data['commercialID']
      this.commercial = data['commercial']
        ? Commercial.fromJS(data['commercial'])
        : <any>undefined
      this.commercialAuditorID = data['commercialAuditorID']
      this.auditorName = data['auditorName']
      this.actStartDate = data['actStartDate']
        ? new Date(data['actStartDate'].toString())
        : <any>undefined
      this.actEndDate = data['actEndDate']
        ? new Date(data['actEndDate'].toString())
        : <any>undefined
      this.lastUpdatedDate = data['lastUpdatedDate']
        ? new Date(data['lastUpdatedDate'].toString())
        : <any>undefined
      this.professionCode = data['professionCode']
      this.auditorTypeCode = data['auditorTypeCode']
      this.auditorStatusCode = data['auditorStatusCode']
      this.professionNo = data['professionNo']
      this.auditorID = data['auditorID']
      this.createdOnDate = data['createdOnDate']
        ? new Date(data['createdOnDate'].toString())
        : <any>undefined
    }
  }

  static fromJS(data: any): CommercialAuditor {
    data = typeof data === 'object' ? data : {}
    let result = new CommercialAuditor()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['commercialID'] = this.commercialID
    data['commercial'] = this.commercial
      ? this.commercial.toJSON()
      : <any>undefined
    data['commercialAuditorID'] = this.commercialAuditorID
    data['auditorName'] = this.auditorName
    data['actStartDate'] = this.actStartDate
      ? this.actStartDate.toISOString()
      : <any>undefined
    data['actEndDate'] = this.actEndDate
      ? this.actEndDate.toISOString()
      : <any>undefined
    data['lastUpdatedDate'] = this.lastUpdatedDate
      ? this.lastUpdatedDate.toISOString()
      : <any>undefined
    data['professionCode'] = this.professionCode
    data['auditorTypeCode'] = this.auditorTypeCode
    data['auditorStatusCode'] = this.auditorStatusCode
    data['professionNo'] = this.professionNo
    data['auditorID'] = this.auditorID
    data['createdOnDate'] = this.createdOnDate
      ? this.createdOnDate.toISOString()
      : <any>undefined
    return data
  }
}

export interface ICommercialAuditor {
  commercialID: number
  commercial?: Commercial
  commercialAuditorID: number
  auditorName?: string
  actStartDate?: Date
  actEndDate?: Date
  lastUpdatedDate?: Date
  professionCode?: string
  auditorTypeCode?: string
  auditorStatusCode?: string
  professionNo?: string
  auditorID?: number
  createdOnDate?: Date
}

export class TimeLine implements ITimeLine {
  lastupdatedDate: Date
  type?: string
  text?: string
  tableName?: string

  constructor(data?: ITimeLine) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.lastupdatedDate = data['lastupdatedDate']
        ? new Date(data['lastupdatedDate'].toString())
        : <any>undefined
      this.type = data['type']
      this.text = data['text']
      this.tableName = data['tableName']
    }
  }

  static fromJS(data: any): TimeLine {
    data = typeof data === 'object' ? data : {}
    let result = new TimeLine()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['lastupdatedDate'] = this.lastupdatedDate
      ? this.lastupdatedDate.toISOString()
      : <any>undefined
    data['type'] = this.type
    data['text'] = this.text
    data['tableName'] = this.tableName
    return data
  }
}

export interface ITimeLine {
  lastupdatedDate: Date
  type?: string
  text?: string
  tableName?: string
}

export class BatchTrace implements IBatchTrace {
  id: string
  customerUser?: CustomerUser
  customerUserID: string
  fileName?: string
  outPutFileName?: string
  batchNumber: number
  uploadDate: Date
  totalRecords: number
  foundRecords: number
  ageGroupGenders?: string
  profileGender?: string
  incomeBrackets?: string
  maritalStaus?: string
  riskCategories?: string
  alloyBreakDowns?: string
  locationServices?: string
  totalRecordsAvailable?: string
  isDataDownloaded: boolean
  proFormaInvoiceId?: string
  adminCertified: boolean
  customerId?: string
  approvedOnDate: Date
  approvedBy?: string
  idNumbers?: string

  constructor(data?: IBatchTrace) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.id = data['id']
      this.customerUser = data['customerUser']
        ? CustomerUser.fromJS(data['customerUser'])
        : <any>undefined
      this.customerUserID = data['customerUserID']
      this.fileName = data['fileName']
      this.outPutFileName = data['outPutFileName']
      this.batchNumber = data['batchNumber']
      this.uploadDate = data['uploadDate']
        ? new Date(data['uploadDate'].toString())
        : <any>undefined
      this.totalRecords = data['totalRecords']
      this.foundRecords = data['foundRecords']
      this.ageGroupGenders = data['ageGroupGenders']
      this.profileGender = data['profileGender']
      this.incomeBrackets = data['incomeBrackets']
      this.maritalStaus = data['maritalStaus']
      this.riskCategories = data['riskCategories']
      this.alloyBreakDowns = data['alloyBreakDowns']
      this.locationServices = data['locationServices']
      this.totalRecordsAvailable = data['totalRecordsAvailable']
      this.isDataDownloaded = data['isDataDownloaded']
      this.proFormaInvoiceId = data['proFormaInvoiceId']
      this.adminCertified = data['adminCertified']
      this.customerId = data['customerId']
      this.approvedOnDate = data['approvedOnDate']
        ? new Date(data['approvedOnDate'].toString())
        : <any>undefined
      this.approvedBy = data['approvedBy']
      this.idNumbers = data['idNumbers']
    }
  }

  static fromJS(data: any): BatchTrace {
    data = typeof data === 'object' ? data : {}
    let result = new BatchTrace()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['id'] = this.id
    data['customerUser'] = this.customerUser
      ? this.customerUser.toJSON()
      : <any>undefined
    data['customerUserID'] = this.customerUserID
    data['fileName'] = this.fileName
    data['outPutFileName'] = this.outPutFileName
    data['batchNumber'] = this.batchNumber
    data['uploadDate'] = this.uploadDate
      ? this.uploadDate.toISOString()
      : <any>undefined
    data['totalRecords'] = this.totalRecords
    data['foundRecords'] = this.foundRecords
    data['ageGroupGenders'] = this.ageGroupGenders
    data['profileGender'] = this.profileGender
    data['incomeBrackets'] = this.incomeBrackets
    data['maritalStaus'] = this.maritalStaus
    data['riskCategories'] = this.riskCategories
    data['alloyBreakDowns'] = this.alloyBreakDowns
    data['locationServices'] = this.locationServices
    data['totalRecordsAvailable'] = this.totalRecordsAvailable
    data['isDataDownloaded'] = this.isDataDownloaded
    data['proFormaInvoiceId'] = this.proFormaInvoiceId
    data['adminCertified'] = this.adminCertified
    data['customerId'] = this.customerId
    data['approvedOnDate'] = this.approvedOnDate
      ? this.approvedOnDate.toISOString()
      : <any>undefined
    data['approvedBy'] = this.approvedBy
    data['idNumbers'] = this.idNumbers
    return data
  }
}

export interface IBatchTrace {
  id: string
  customerUser?: CustomerUser
  customerUserID: string
  fileName?: string
  outPutFileName?: string
  batchNumber: number
  uploadDate: Date
  totalRecords: number
  foundRecords: number
  ageGroupGenders?: string
  profileGender?: string
  incomeBrackets?: string
  maritalStaus?: string
  riskCategories?: string
  alloyBreakDowns?: string
  locationServices?: string
  totalRecordsAvailable?: string
  isDataDownloaded: boolean
  proFormaInvoiceId?: string
  adminCertified: boolean
  customerId?: string
  approvedOnDate: Date
  approvedBy?: string
  idNumbers?: string
}

export class CustomerUser implements ICustomerUser {
  id: string
  firstName: string
  lastName: string
  title: string
  idNumber: string
  email: string
  password?: string
  isAdmin: boolean
  MAchAddressCHK?: boolean
  MacAddresses: string
  status?: string
  customerId: string
  customer?: Customer
  code?: string
  subscription?: Subscription
  subscriptionId?: string
  phoneNumber?: string
  message?: string
  createdDate?: Date
  createdBy?: string
  modifiedDate?: Date
  modifiedBy?: string
  activatedBy?: string
  activatedDate?: Date
  lastLoginDate?: Date
  batchwithoutSub?: boolean
  isUserLoggedIn?: boolean
  leadswithoutSub?: boolean
  LastPasswordResetDate: Date

  constructor(data?: ICustomerUser) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.id = data['id']
      this.firstName = data['firstName']
      this.lastName = data['lastName']
      this.title = data['title']
      this.idNumber = data['idNumber']
      this.email = data['email']
      this.password = data['password']
      this.isAdmin = data['isAdmin']
      this.MAchAddressCHK = data['MAchAddressCHK']
      this.MacAddresses = data['MacAddresses']
      this.status = data['status']
      this.customerId = data['customerId']
      this.customer = data['customer']
        ? Customer.fromJS(data['customer'])
        : <any>undefined
      this.code = data['code']
      this.subscription = data['subscription']
        ? Subscription.fromJS(data['subscription'])
        : <any>undefined
      this.subscriptionId = data['subscriptionId']
      this.phoneNumber = data['phoneNumber']
      this.message = data['message']
      this.createdDate = data['createdDate']
        ? new Date(data['createdDate'].toString())
        : <any>undefined
      this.createdBy = data['createdBy']
      this.modifiedDate = data['modifiedDate']
        ? new Date(data['modifiedDate'].toString())
        : <any>undefined
      this.modifiedBy = data['modifiedBy']
      this.activatedBy = data['activatedBy']
      this.activatedDate = data['activatedDate']
        ? new Date(data['activatedDate'].toString())
        : <any>undefined
      this.lastLoginDate = data['lastLoginDate']
        ? new Date(data['lastLoginDate'].toString())
        : <any>undefined
      this.batchwithoutSub = data['batchwithoutSub']
      this.isUserLoggedIn = data['isUserLoggedIn']
      this.leadswithoutSub = data['leadswithoutSub']
      this.LastPasswordResetDate = data['LastPasswordResetDate']
    }
  }

  static fromJS(data: any): CustomerUser {
    data = typeof data === 'object' ? data : {}
    let result = new CustomerUser()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['id'] = this.id
    data['firstName'] = this.firstName
    data['lastName'] = this.lastName
    data['title'] = this.title
    data['idNumber'] = this.idNumber
    data['email'] = this.email
    data['password'] = this.password
    data['isAdmin'] = this.isAdmin
    data['MAchAddressCHK'] = this.MAchAddressCHK
    data['MacAddresses'] = this.MacAddresses
    data['status'] = this.status
    data['customerId'] = this.customerId
    data['customer'] = this.customer ? this.customer.toJSON() : <any>undefined
    data['code'] = this.code
    data['subscription'] = this.subscription
      ? this.subscription.toJSON()
      : <any>undefined
    data['subscriptionId'] = this.subscriptionId
    data['phoneNumber'] = this.phoneNumber
    data['message'] = this.message
    data['createdDate'] = this.createdDate
      ? this.createdDate.toISOString()
      : <any>undefined
    data['createdBy'] = this.createdBy
    data['modifiedDate'] = this.modifiedDate
      ? this.modifiedDate.toISOString()
      : <any>undefined
    data['modifiedBy'] = this.modifiedBy
    data['activatedBy'] = this.activatedBy
    data['activatedDate'] = this.activatedDate
      ? this.activatedDate.toISOString()
      : <any>undefined
    data['lastLoginDate'] = this.lastLoginDate
      ? this.lastLoginDate.toISOString()
      : <any>undefined
    data['batchwithoutSub'] = this.batchwithoutSub
    data['isUserLoggedIn'] = this.isUserLoggedIn
    data['leadswithoutSub'] = this.leadswithoutSub
    data['LastPasswordResetDate'] = this.LastPasswordResetDate
    return data
  }
}

export interface ICustomerUser {
  id: string
  firstName: string
  lastName: string
  title: string
  idNumber: string
  email: string
  password?: string
  isAdmin: boolean
  MAchAddressCHK?: boolean
  MacAddresses: string
  status?: string
  customerId: string
  customer?: Customer
  code?: string
  subscription?: Subscription
  subscriptionId?: string
  phoneNumber?: string
  message?: string
  createdDate?: Date
  createdBy?: string
  modifiedDate?: Date
  modifiedBy?: string
  activatedBy?: string
  activatedDate?: Date
  lastLoginDate?: Date
  batchwithoutSub?: boolean
  isUserLoggedIn?: boolean
  leadswithoutSub?: boolean
  LastPasswordResetDate: Date
}

export class Customer implements ICustomer {
  id: string
  tradingName: string
  registrationName: string
  registrationNumber: string
  vatNumber?: string
  branchLocation?: string
  physicalAddress: string
  typeOfBusiness: string
  telephoneNumber: string
  faxNumber?: string
  billingEmail?: string
  status?: string
  billingType?: string
  code?: string
  turnover: boolean
  custOwnIDNumber?: string
  postalAddress?: string
  webAddress?: string
  accountDeptContactPerson?: string
  accountDeptTelephoneNumber?: string
  accountDeptFaxNumber?: string
  authIDNumber?: string
  authPosition?: string
  accountDeptEmail?: string
  authFirstName?: string
  authSurName?: string
  authCellNumber: string
  authEmail?: string
  businessDescription?: string
  creditBureauInformation?: string
  purpose?: string
  createdDate?: Date
  createdBy?: string
  modifiedDate?: Date
  modifiedBy?: string
  activatedBy?: string
  activatedDate?: Date
  customerUsers?: CustomerUser[]
  customerProducts?: CustomerProduct[]
  tabSelected?: string
  client_logo?: string

  constructor(data?: ICustomer) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.id = data['id']
      this.tradingName = data['tradingName']
      this.registrationName = data['registrationName']
      this.registrationNumber = data['registrationNumber']
      this.vatNumber = data['vatNumber']
      this.branchLocation = data['branchLocation']
      this.physicalAddress = data['physicalAddress']
      this.typeOfBusiness = data['typeOfBusiness']
      this.telephoneNumber = data['telephoneNumber']
      this.faxNumber = data['faxNumber']
      this.billingEmail = data['billingEmail']
      this.status = data['status']
      this.billingType = data['billingType']
      this.code = data['code']
      this.turnover = data['turnover']
      this.custOwnIDNumber = data['custOwnIDNumber']
      this.postalAddress = data['postalAddress']
      this.webAddress = data['webAddress']
      this.accountDeptContactPerson = data['accountDeptContactPerson']
      this.accountDeptTelephoneNumber = data['accountDeptTelephoneNumber']
      this.accountDeptFaxNumber = data['accountDeptFaxNumber']
      this.authIDNumber = data['authIDNumber']
      this.authPosition = data['authPosition']
      this.accountDeptEmail = data['accountDeptEmail']
      this.authFirstName = data['authFirstName']
      this.authSurName = data['authSurName']
      this.authCellNumber = data['authCellNumber']
      this.authEmail = data['authEmail']
      this.businessDescription = data['businessDescription']
      this.creditBureauInformation = data['creditBureauInformation']
      this.purpose = data['purpose']
      this.createdDate = data['createdDate']
        ? new Date(data['createdDate'].toString())
        : <any>undefined
      this.createdBy = data['createdBy']
      this.modifiedDate = data['modifiedDate']
        ? new Date(data['modifiedDate'].toString())
        : <any>undefined
      this.modifiedBy = data['modifiedBy']
      this.activatedBy = data['activatedBy']
      this.activatedDate = data['activatedDate']
        ? new Date(data['activatedDate'].toString())
        : <any>undefined
      if (
        data['customerUsers'] &&
        data['customerUsers'].constructor === Array
      ) {
        this.customerUsers = []
        for (let item of data['customerUsers'])
          this.customerUsers.push(CustomerUser.fromJS(item))
      }
      if (
        data['customerProducts'] &&
        data['customerProducts'].constructor === Array
      ) {
        this.customerProducts = []
        for (let item of data['customerProducts'])
          this.customerProducts.push(CustomerProduct.fromJS(item))
      }
      this.tabSelected = data['tabSelected']
      this.client_logo = data['client_logo']
    }
  }

  static fromJS(data: any): Customer {
    data = typeof data === 'object' ? data : {}
    let result = new Customer()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['id'] = this.id
    data['tradingName'] = this.tradingName
    data['registrationName'] = this.registrationName
    data['registrationNumber'] = this.registrationNumber
    data['vatNumber'] = this.vatNumber
    data['branchLocation'] = this.branchLocation
    data['physicalAddress'] = this.physicalAddress
    data['typeOfBusiness'] = this.typeOfBusiness
    data['telephoneNumber'] = this.telephoneNumber
    data['faxNumber'] = this.faxNumber
    data['billingEmail'] = this.billingEmail
    data['status'] = this.status
    data['billingType'] = this.billingType
    data['code'] = this.code
    data['turnover'] = this.turnover
    data['custOwnIDNumber'] = this.custOwnIDNumber
    data['postalAddress'] = this.postalAddress
    data['webAddress'] = this.webAddress
    data['accountDeptContactPerson'] = this.accountDeptContactPerson
    data['accountDeptTelephoneNumber'] = this.accountDeptTelephoneNumber
    data['accountDeptFaxNumber'] = this.accountDeptFaxNumber
    data['authIDNumber'] = this.authIDNumber
    data['authPosition'] = this.authPosition
    data['accountDeptEmail'] = this.accountDeptEmail
    data['authFirstName'] = this.authFirstName
    data['authSurName'] = this.authSurName
    data['authCellNumber'] = this.authCellNumber
    data['authEmail'] = this.authEmail
    data['businessDescription'] = this.businessDescription
    data['creditBureauInformation'] = this.creditBureauInformation
    data['purpose'] = this.purpose
    data['createdDate'] = this.createdDate
      ? this.createdDate.toISOString()
      : <any>undefined
    data['createdBy'] = this.createdBy
    data['modifiedDate'] = this.modifiedDate
      ? this.modifiedDate.toISOString()
      : <any>undefined
    data['modifiedBy'] = this.modifiedBy
    data['activatedBy'] = this.activatedBy
    data['activatedDate'] = this.activatedDate
      ? this.activatedDate.toISOString()
      : <any>undefined
    if (this.customerUsers && this.customerUsers.constructor === Array) {
      data['customerUsers'] = []
      for (let item of this.customerUsers)
        data['customerUsers'].push(item.toJSON())
    }
    if (this.customerProducts && this.customerProducts.constructor === Array) {
      data['customerProducts'] = []
      for (let item of this.customerProducts)
        data['customerProducts'].push(item.toJSON())
    }
    data['tabSelected'] = this.tabSelected
    data['client_logo'] = this.client_logo
    return data
  }
}

export interface ICustomer {
  id: string
  tradingName: string
  registrationName: string
  registrationNumber: string
  vatNumber?: string
  branchLocation?: string
  physicalAddress: string
  typeOfBusiness: string
  telephoneNumber: string
  faxNumber?: string
  billingEmail?: string
  status?: string
  billingType?: string
  code?: string
  turnover: boolean
  custOwnIDNumber?: string
  postalAddress?: string
  webAddress?: string
  accountDeptContactPerson?: string
  accountDeptTelephoneNumber?: string
  accountDeptFaxNumber?: string
  authIDNumber?: string
  authPosition?: string
  accountDeptEmail?: string
  authFirstName?: string
  authSurName?: string
  authCellNumber: string
  authEmail?: string
  businessDescription?: string
  creditBureauInformation?: string
  purpose?: string
  createdDate?: Date
  createdBy?: string
  modifiedDate?: Date
  modifiedBy?: string
  activatedBy?: string
  activatedDate?: Date
  customerUsers?: CustomerUser[]
  customerProducts?: CustomerProduct[]
  tabSelected?: string
  client_logo?: string
}

export class CustomerProduct implements ICustomerProduct {
  id: string
  customerId: string
  productId: string
  product?: Product
  active?: boolean
  createdDate?: Date
  modifiedDate?: Date
  createdBy?: string
  modifiedBy?: string

  constructor(data?: ICustomerProduct) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.id = data['id']
      this.customerId = data['customerId']
      this.productId = data['productId']
      this.product = data['product']
        ? Product.fromJS(data['product'])
        : <any>undefined
      this.active = data['active']
      this.createdDate = data['createdDate']
        ? new Date(data['createdDate'].toString())
        : <any>undefined
      this.modifiedDate = data['modifiedDate']
        ? new Date(data['modifiedDate'].toString())
        : <any>undefined
      this.createdBy = data['createdBy']
      this.modifiedBy = data['modifiedBy']
    }
  }

  static fromJS(data: any): CustomerProduct {
    data = typeof data === 'object' ? data : {}
    let result = new CustomerProduct()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['id'] = this.id
    data['customerId'] = this.customerId
    data['productId'] = this.productId
    data['product'] = this.product ? this.product.toJSON() : <any>undefined
    data['active'] = this.active
    data['createdDate'] = this.createdDate
      ? this.createdDate.toISOString()
      : <any>undefined
    data['modifiedDate'] = this.modifiedDate
      ? this.modifiedDate.toISOString()
      : <any>undefined
    data['createdBy'] = this.createdBy
    data['modifiedBy'] = this.modifiedBy
    return data
  }
}

export interface ICustomerProduct {
  id: string
  customerId: string
  productId: string
  product?: Product
  active?: boolean
  createdDate?: Date
  modifiedDate?: Date
  createdBy?: string
  modifiedBy?: string
}

export class Product implements IProduct {
  id: string
  name?: string
  packageRates?: ProductPackageRate[]
  status: boolean
  createdOn: Date
  activatedDate: Date
  deactivatedDate: Date
  lastUpdatedDate: Date
  service?: Service
  serviceId: string
  usageType?: string
  isPostpaid: boolean
  code?: string
  batchProduct?: boolean
  leadProduct?: boolean

  constructor(data?: IProduct) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.id = data['id']
      this.name = data['name']
      if (data['packageRates'] && data['packageRates'].constructor === Array) {
        this.packageRates = []
        for (let item of data['packageRates'])
          this.packageRates.push(ProductPackageRate.fromJS(item))
      }
      this.status = data['status']
      this.createdOn = data['createdOn']
        ? new Date(data['createdOn'].toString())
        : <any>undefined
      this.activatedDate = data['activatedDate']
        ? new Date(data['activatedDate'].toString())
        : <any>undefined
      this.deactivatedDate = data['deactivatedDate']
        ? new Date(data['deactivatedDate'].toString())
        : <any>undefined
      this.lastUpdatedDate = data['lastUpdatedDate']
        ? new Date(data['lastUpdatedDate'].toString())
        : <any>undefined
      this.service = data['service']
        ? Service.fromJS(data['service'])
        : <any>undefined
      this.serviceId = data['serviceId']
      this.usageType = data['usageType']
      this.isPostpaid = data['isPostpaid']
      this.code = data['code']
      this.batchProduct = data['batchProduct']
      this.leadProduct = data['leadProduct']
    }
  }

  static fromJS(data: any): Product {
    data = typeof data === 'object' ? data : {}
    let result = new Product()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['id'] = this.id
    data['name'] = this.name
    if (this.packageRates && this.packageRates.constructor === Array) {
      data['packageRates'] = []
      for (let item of this.packageRates)
        data['packageRates'].push(item.toJSON())
    }
    data['status'] = this.status
    data['createdOn'] = this.createdOn
      ? this.createdOn.toISOString()
      : <any>undefined
    data['activatedDate'] = this.activatedDate
      ? this.activatedDate.toISOString()
      : <any>undefined
    data['deactivatedDate'] = this.deactivatedDate
      ? this.deactivatedDate.toISOString()
      : <any>undefined
    data['lastUpdatedDate'] = this.lastUpdatedDate
      ? this.lastUpdatedDate.toISOString()
      : <any>undefined
    data['service'] = this.service ? this.service.toJSON() : <any>undefined
    data['serviceId'] = this.serviceId
    data['usageType'] = this.usageType
    data['isPostpaid'] = this.isPostpaid
    data['code'] = this.code
    data['batchProduct'] = this.batchProduct
    data['leadProduct'] = this.leadProduct
    return data
  }
}

export interface IProduct {
  id: string
  name?: string
  packageRates?: ProductPackageRate[]
  status: boolean
  createdOn: Date
  activatedDate: Date
  deactivatedDate: Date
  lastUpdatedDate: Date
  service?: Service
  serviceId: string
  usageType?: string
  isPostpaid: boolean
  code?: string
  batchProduct?: boolean
  leadProduct?: boolean
}

export class ProductPackageRate implements IProductPackageRate {
  id: string
  product?: Product
  productId: string
  minLimit: number
  maxLimit: number
  isDeleted: number
  unitPrice: number

  constructor(data?: IProductPackageRate) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.id = data['id']
      this.product = data['product']
        ? Product.fromJS(data['product'])
        : <any>undefined
      this.productId = data['productId']
      this.minLimit = data['minLimit']
      this.maxLimit = data['maxLimit']
      this.isDeleted = data['isDeleted']
      this.unitPrice = data['unitPrice']
    }
  }

  static fromJS(data: any): ProductPackageRate {
    data = typeof data === 'object' ? data : {}
    let result = new ProductPackageRate()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['id'] = this.id
    data['product'] = this.product ? this.product.toJSON() : <any>undefined
    data['productId'] = this.productId
    data['minLimit'] = this.minLimit
    data['maxLimit'] = this.maxLimit
    data['isDeleted'] = this.isDeleted
    data['unitPrice'] = this.unitPrice
    return data
  }
}

export interface IProductPackageRate {
  id: string
  product?: Product
  productId: string
  minLimit: number
  maxLimit: number
  isDeleted: number
  unitPrice: number
}

export class Service implements IService {
  id: string
  name?: string
  code?: string
  isActive: boolean
  createdDate?: Date
  createdBy?: string
  modifiedDate?: Date
  modifiedBy?: string

  constructor(data?: IService) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.id = data['id']
      this.name = data['name']
      this.code = data['code']
      this.isActive = data['isActive']
      this.createdDate = data['createdDate']
        ? new Date(data['createdDate'].toString())
        : <any>undefined
      this.createdBy = data['createdBy']
      this.modifiedDate = data['modifiedDate']
        ? new Date(data['modifiedDate'].toString())
        : <any>undefined
      this.modifiedBy = data['modifiedBy']
    }
  }

  static fromJS(data: any): Service {
    data = typeof data === 'object' ? data : {}
    let result = new Service()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['id'] = this.id
    data['name'] = this.name
    data['code'] = this.code
    data['isActive'] = this.isActive
    data['createdDate'] = this.createdDate
      ? this.createdDate.toISOString()
      : <any>undefined
    data['createdBy'] = this.createdBy
    data['modifiedDate'] = this.modifiedDate
      ? this.modifiedDate.toISOString()
      : <any>undefined
    data['modifiedBy'] = this.modifiedBy
    return data
  }
}

export interface IService {
  id: string
  name?: string
  code?: string
  isActive: boolean
  createdDate?: Date
  createdBy?: string
  modifiedDate?: Date
  modifiedBy?: string
}

export class Subscription implements ISubscription {
  id: string
  customer?: Customer
  customerId: string
  number: number
  date: Date
  subDisplayNumber?: string
  isAutoBilled: boolean
  subscriptionItems?: SubscriptionItem[]

  constructor(data?: ISubscription) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.id = data['id']
      this.customer = data['customer']
        ? Customer.fromJS(data['customer'])
        : <any>undefined
      this.customerId = data['customerId']
      this.number = data['number']
      this.date = data['date']
        ? new Date(data['date'].toString())
        : <any>undefined
      this.subDisplayNumber = data['subDisplayNumber']
      this.isAutoBilled = data['isAutoBilled']
      if (
        data['subscriptionItems'] &&
        data['subscriptionItems'].constructor === Array
      ) {
        this.subscriptionItems = []
        for (let item of data['subscriptionItems'])
          this.subscriptionItems.push(SubscriptionItem.fromJS(item))
      }
    }
  }

  static fromJS(data: any): Subscription {
    data = typeof data === 'object' ? data : {}
    let result = new Subscription()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['id'] = this.id
    data['customer'] = this.customer ? this.customer.toJSON() : <any>undefined
    data['customerId'] = this.customerId
    data['number'] = this.number
    data['date'] = this.date ? this.date.toISOString() : <any>undefined
    data['subDisplayNumber'] = this.subDisplayNumber
    data['isAutoBilled'] = this.isAutoBilled
    if (
      this.subscriptionItems &&
      this.subscriptionItems.constructor === Array
    ) {
      data['subscriptionItems'] = []
      for (let item of this.subscriptionItems)
        data['subscriptionItems'].push(item.toJSON())
    }
    return data
  }
}

export interface ISubscription {
  id: string
  customer?: Customer
  customerId: string
  number: number
  date: Date
  subDisplayNumber?: string
  isAutoBilled: boolean
  subscriptionItems?: SubscriptionItem[]
}

export class SubscriptionItem implements ISubscriptionItem {
  id: string
  productPackage?: ProductPackageRate
  productPackageId: string
  status?: string
  startDate: Date
  endDate: Date
  billingType?: string
  duration: number
  quantity: number
  rate: number
  subscription?: Subscription
  subscriptionId: string
  isBilled?: boolean
  proRataPrice: number
  proRataNetAmount: number

  constructor(data?: ISubscriptionItem) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.id = data['id']
      this.productPackage = data['productPackage']
        ? ProductPackageRate.fromJS(data['productPackage'])
        : <any>undefined
      this.productPackageId = data['productPackageId']
      this.status = data['status']
      this.startDate = data['startDate']
        ? new Date(data['startDate'].toString())
        : <any>undefined
      this.endDate = data['endDate']
        ? new Date(data['endDate'].toString())
        : <any>undefined
      this.billingType = data['billingType']
      this.duration = data['duration']
      this.quantity = data['quantity']
      this.rate = data['rate']
      this.subscription = data['subscription']
        ? Subscription.fromJS(data['subscription'])
        : <any>undefined
      this.subscriptionId = data['subscriptionId']
      this.isBilled = data['isBilled']
      this.proRataPrice = data['proRataPrice']
      this.proRataNetAmount = data['proRataNetAmount']
    }
  }

  static fromJS(data: any): SubscriptionItem {
    data = typeof data === 'object' ? data : {}
    let result = new SubscriptionItem()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['id'] = this.id
    data['productPackage'] = this.productPackage
      ? this.productPackage.toJSON()
      : <any>undefined
    data['productPackageId'] = this.productPackageId
    data['status'] = this.status
    data['startDate'] = this.startDate
      ? this.startDate.toISOString()
      : <any>undefined
    data['endDate'] = this.endDate ? this.endDate.toISOString() : <any>undefined
    data['billingType'] = this.billingType
    data['duration'] = this.duration
    data['quantity'] = this.quantity
    data['rate'] = this.rate
    data['subscription'] = this.subscription
      ? this.subscription.toJSON()
      : <any>undefined
    data['subscriptionId'] = this.subscriptionId
    data['isBilled'] = this.isBilled
    data['proRataPrice'] = this.proRataPrice
    data['proRataNetAmount'] = this.proRataNetAmount
    return data
  }
}

export interface ISubscriptionItem {
  id: string
  productPackage?: ProductPackageRate
  productPackageId: string
  status?: string
  startDate: Date
  endDate: Date
  billingType?: string
  duration: number
  quantity: number
  rate: number
  subscription?: Subscription
  subscriptionId: string
  isBilled?: boolean
  proRataPrice: number
  proRataNetAmount: number
}

export class BatchTraceServices implements IBatchTraceServices {
  batchId: string
  id: string
  proFormaInvoiceId?: string
  customer?: Customer
  batchTrace?: BatchTrace
  customerID: string
  customerUser?: CustomerUser
  customerUserID: string
  fileName?: string
  outPutFileName?: string
  batchNumber?: string
  uploadDate?: string
  excelValidation: boolean
  fetchingData: boolean
  processingData: boolean
  preparingChart: boolean
  morrisGenders?: MorrisGender[]
  morrisMaritalStaus?: MorrisMaritalStaus[]
  morrisRiskCategories?: MorrisRiskCategories[]
  morrisAlloyBreakDowns?: MorrisAlloyBreakDown[]
  locationDistributorAgeGroups?: LocationDistributorAgeGroup[]
  ageGrouGenders?: AgeGrouGenders
  incomeBrackets?: IncomeBrackets
  totalRecordsAvailables?: TotalRecordsAvailable[]
  totalRecords: number
  foundRecords: number
  isDataDownloaded: boolean
  adminCertified: boolean
  message?: string
  batchTraceList?: BatchTrace[]
  consumers?: Consumer[]
  batchTracingConsumers?: BatchTracingConsumer[]
  columns?: string[]
  rows?: string[]
  excelModelResponseList?: ExcelModelResponse[]
  idnos?: string
  idnumberlst?: string[]

  constructor(data?: IBatchTraceServices) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.batchId = data['batchId']
      this.id = data['id']
      this.proFormaInvoiceId = data['proFormaInvoiceId']
      this.customer = data['customer']
        ? Customer.fromJS(data['customer'])
        : <any>undefined
      this.batchTrace = data['batchTrace']
        ? BatchTrace.fromJS(data['batchTrace'])
        : <any>undefined
      this.customerID = data['customerID']
      this.customerUser = data['customerUser']
        ? CustomerUser.fromJS(data['customerUser'])
        : <any>undefined
      this.customerUserID = data['customerUserID']
      this.fileName = data['fileName']
      this.outPutFileName = data['outPutFileName']
      this.batchNumber = data['batchNumber']
      this.uploadDate = data['uploadDate']
      this.excelValidation = data['excelValidation']
      this.fetchingData = data['fetchingData']
      this.processingData = data['processingData']
      this.preparingChart = data['preparingChart']
      if (
        data['morrisGenders'] &&
        data['morrisGenders'].constructor === Array
      ) {
        this.morrisGenders = []
        for (let item of data['morrisGenders'])
          this.morrisGenders.push(MorrisGender.fromJS(item))
      }
      if (
        data['morrisMaritalStaus'] &&
        data['morrisMaritalStaus'].constructor === Array
      ) {
        this.morrisMaritalStaus = []
        for (let item of data['morrisMaritalStaus'])
          this.morrisMaritalStaus.push(MorrisMaritalStaus.fromJS(item))
      }
      if (
        data['morrisRiskCategories'] &&
        data['morrisRiskCategories'].constructor === Array
      ) {
        this.morrisRiskCategories = []
        for (let item of data['morrisRiskCategories'])
          this.morrisRiskCategories.push(MorrisRiskCategories.fromJS(item))
      }
      if (
        data['morrisAlloyBreakDowns'] &&
        data['morrisAlloyBreakDowns'].constructor === Array
      ) {
        this.morrisAlloyBreakDowns = []
        for (let item of data['morrisAlloyBreakDowns'])
          this.morrisAlloyBreakDowns.push(MorrisAlloyBreakDown.fromJS(item))
      }
      if (
        data['locationDistributorAgeGroups'] &&
        data['locationDistributorAgeGroups'].constructor === Array
      ) {
        this.locationDistributorAgeGroups = []
        for (let item of data['locationDistributorAgeGroups'])
          this.locationDistributorAgeGroups.push(
            LocationDistributorAgeGroup.fromJS(item),
          )
      }
      this.ageGrouGenders = data['ageGrouGenders']
        ? AgeGrouGenders.fromJS(data['ageGrouGenders'])
        : <any>undefined
      this.incomeBrackets = data['incomeBrackets']
        ? IncomeBrackets.fromJS(data['incomeBrackets'])
        : <any>undefined
      if (
        data['totalRecordsAvailables'] &&
        data['totalRecordsAvailables'].constructor === Array
      ) {
        this.totalRecordsAvailables = []
        for (let item of data['totalRecordsAvailables'])
          this.totalRecordsAvailables.push(TotalRecordsAvailable.fromJS(item))
      }
      this.totalRecords = data['totalRecords']
      this.foundRecords = data['foundRecords']
      this.isDataDownloaded = data['isDataDownloaded']
      this.adminCertified = data['adminCertified']
      this.message = data['message']
      if (
        data['batchTraceList'] &&
        data['batchTraceList'].constructor === Array
      ) {
        this.batchTraceList = []
        for (let item of data['batchTraceList'])
          this.batchTraceList.push(BatchTrace.fromJS(item))
      }
      if (data['consumers'] && data['consumers'].constructor === Array) {
        this.consumers = []
        for (let item of data['consumers'])
          this.consumers.push(Consumer.fromJS(item))
      }
      if (
        data['batchTracingConsumers'] &&
        data['batchTracingConsumers'].constructor === Array
      ) {
        this.batchTracingConsumers = []
        for (let item of data['batchTracingConsumers'])
          this.batchTracingConsumers.push(BatchTracingConsumer.fromJS(item))
      }
      if (data['columns'] && data['columns'].constructor === Array) {
        this.columns = []
        for (let item of data['columns']) this.columns.push(item)
      }
      if (data['rows'] && data['rows'].constructor === Array) {
        this.rows = []
        for (let item of data['rows']) this.rows.push(item)
      }
      if (
        data['excelModelResponseList'] &&
        data['excelModelResponseList'].constructor === Array
      ) {
        this.excelModelResponseList = []
        for (let item of data['excelModelResponseList'])
          this.excelModelResponseList.push(ExcelModelResponse.fromJS(item))
      }
      this.idnos = data['idnos']
      if (data['idnumberlst'] && data['idnumberlst'].constructor === Array) {
        this.idnumberlst = []
        for (let item of data['idnumberlst']) this.idnumberlst.push(item)
      }
    }
  }

  static fromJS(data: any): BatchTraceServices {
    data = typeof data === 'object' ? data : {}
    let result = new BatchTraceServices()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['batchId'] = this.batchId
    data['id'] = this.id
    data['proFormaInvoiceId'] = this.proFormaInvoiceId
    data['customer'] = this.customer ? this.customer.toJSON() : <any>undefined
    data['batchTrace'] = this.batchTrace
      ? this.batchTrace.toJSON()
      : <any>undefined
    data['customerID'] = this.customerID
    data['customerUser'] = this.customerUser
      ? this.customerUser.toJSON()
      : <any>undefined
    data['customerUserID'] = this.customerUserID
    data['fileName'] = this.fileName
    data['outPutFileName'] = this.outPutFileName
    data['batchNumber'] = this.batchNumber
    data['uploadDate'] = this.uploadDate
    data['excelValidation'] = this.excelValidation
    data['fetchingData'] = this.fetchingData
    data['processingData'] = this.processingData
    data['preparingChart'] = this.preparingChart
    if (this.morrisGenders && this.morrisGenders.constructor === Array) {
      data['morrisGenders'] = []
      for (let item of this.morrisGenders)
        data['morrisGenders'].push(item.toJSON())
    }
    if (
      this.morrisMaritalStaus &&
      this.morrisMaritalStaus.constructor === Array
    ) {
      data['morrisMaritalStaus'] = []
      for (let item of this.morrisMaritalStaus)
        data['morrisMaritalStaus'].push(item.toJSON())
    }
    if (
      this.morrisRiskCategories &&
      this.morrisRiskCategories.constructor === Array
    ) {
      data['morrisRiskCategories'] = []
      for (let item of this.morrisRiskCategories)
        data['morrisRiskCategories'].push(item.toJSON())
    }
    if (
      this.morrisAlloyBreakDowns &&
      this.morrisAlloyBreakDowns.constructor === Array
    ) {
      data['morrisAlloyBreakDowns'] = []
      for (let item of this.morrisAlloyBreakDowns)
        data['morrisAlloyBreakDowns'].push(item.toJSON())
    }
    if (
      this.locationDistributorAgeGroups &&
      this.locationDistributorAgeGroups.constructor === Array
    ) {
      data['locationDistributorAgeGroups'] = []
      for (let item of this.locationDistributorAgeGroups)
        data['locationDistributorAgeGroups'].push(item.toJSON())
    }
    data['ageGrouGenders'] = this.ageGrouGenders
      ? this.ageGrouGenders.toJSON()
      : <any>undefined
    data['incomeBrackets'] = this.incomeBrackets
      ? this.incomeBrackets.toJSON()
      : <any>undefined
    if (
      this.totalRecordsAvailables &&
      this.totalRecordsAvailables.constructor === Array
    ) {
      data['totalRecordsAvailables'] = []
      for (let item of this.totalRecordsAvailables)
        data['totalRecordsAvailables'].push(item.toJSON())
    }
    data['totalRecords'] = this.totalRecords
    data['foundRecords'] = this.foundRecords
    data['isDataDownloaded'] = this.isDataDownloaded
    data['adminCertified'] = this.adminCertified
    data['message'] = this.message
    if (this.batchTraceList && this.batchTraceList.constructor === Array) {
      data['batchTraceList'] = []
      for (let item of this.batchTraceList)
        data['batchTraceList'].push(item.toJSON())
    }
    if (this.consumers && this.consumers.constructor === Array) {
      data['consumers'] = []
      for (let item of this.consumers) data['consumers'].push(item.toJSON())
    }
    if (
      this.batchTracingConsumers &&
      this.batchTracingConsumers.constructor === Array
    ) {
      data['batchTracingConsumers'] = []
      for (let item of this.batchTracingConsumers)
        data['batchTracingConsumers'].push(item.toJSON())
    }
    if (this.columns && this.columns.constructor === Array) {
      data['columns'] = []
      for (let item of this.columns) data['columns'].push(item)
    }
    if (this.rows && this.rows.constructor === Array) {
      data['rows'] = []
      for (let item of this.rows) data['rows'].push(item)
    }
    if (
      this.excelModelResponseList &&
      this.excelModelResponseList.constructor === Array
    ) {
      data['excelModelResponseList'] = []
      for (let item of this.excelModelResponseList)
        data['excelModelResponseList'].push(item.toJSON())
    }
    data['idnos'] = this.idnos
    if (this.idnumberlst && this.idnumberlst.constructor === Array) {
      data['idnumberlst'] = []
      for (let item of this.idnumberlst) data['idnumberlst'].push(item)
    }
    return data
  }
}

export interface IBatchTraceServices {
  batchId: string
  id: string
  proFormaInvoiceId?: string
  customer?: Customer
  batchTrace?: BatchTrace
  customerID: string
  customerUser?: CustomerUser
  customerUserID: string
  fileName?: string
  outPutFileName?: string
  batchNumber?: string
  uploadDate?: string
  excelValidation: boolean
  fetchingData: boolean
  processingData: boolean
  preparingChart: boolean
  morrisGenders?: MorrisGender[]
  morrisMaritalStaus?: MorrisMaritalStaus[]
  morrisRiskCategories?: MorrisRiskCategories[]
  morrisAlloyBreakDowns?: MorrisAlloyBreakDown[]
  locationDistributorAgeGroups?: LocationDistributorAgeGroup[]
  ageGrouGenders?: AgeGrouGenders
  incomeBrackets?: IncomeBrackets
  totalRecordsAvailables?: TotalRecordsAvailable[]
  totalRecords: number
  foundRecords: number
  isDataDownloaded: boolean
  adminCertified: boolean
  message?: string
  batchTraceList?: BatchTrace[]
  consumers?: Consumer[]
  batchTracingConsumers?: BatchTracingConsumer[]
  columns?: string[]
  rows?: string[]
  excelModelResponseList?: ExcelModelResponse[]
  idnos?: string
  idnumberlst?: string[]
}

export class MorrisGender implements IMorrisGender {
  label?: string
  value: number
  color?: string

  constructor(data?: IMorrisGender) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.label = data['label']
      this.value = data['value']
      this.color = data['color']
    }
  }

  static fromJS(data: any): MorrisGender {
    data = typeof data === 'object' ? data : {}
    let result = new MorrisGender()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['label'] = this.label
    data['value'] = this.value
    data['color'] = this.color
    return data
  }
}

export interface IMorrisGender {
  label?: string
  value: number
  color?: string
}

export class MorrisMaritalStaus implements IMorrisMaritalStaus {
  label?: string
  value: number
  color?: string

  constructor(data?: IMorrisMaritalStaus) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.label = data['label']
      this.value = data['value']
      this.color = data['color']
    }
  }

  static fromJS(data: any): MorrisMaritalStaus {
    data = typeof data === 'object' ? data : {}
    let result = new MorrisMaritalStaus()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['label'] = this.label
    data['value'] = this.value
    data['color'] = this.color
    return data
  }
}

export interface IMorrisMaritalStaus {
  label?: string
  value: number
  color?: string
}

export class MorrisRiskCategories implements IMorrisRiskCategories {
  label?: string
  value: number
  color?: string

  constructor(data?: IMorrisRiskCategories) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.label = data['label']
      this.value = data['value']
      this.color = data['color']
    }
  }

  static fromJS(data: any): MorrisRiskCategories {
    data = typeof data === 'object' ? data : {}
    let result = new MorrisRiskCategories()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['label'] = this.label
    data['value'] = this.value
    data['color'] = this.color
    return data
  }
}

export interface IMorrisRiskCategories {
  label?: string
  value: number
  color?: string
}

export class MorrisAlloyBreakDown implements IMorrisAlloyBreakDown {
  label?: string
  value: number
  color?: string

  constructor(data?: IMorrisAlloyBreakDown) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.label = data['label']
      this.value = data['value']
      this.color = data['color']
    }
  }

  static fromJS(data: any): MorrisAlloyBreakDown {
    data = typeof data === 'object' ? data : {}
    let result = new MorrisAlloyBreakDown()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['label'] = this.label
    data['value'] = this.value
    data['color'] = this.color
    return data
  }
}

export interface IMorrisAlloyBreakDown {
  label?: string
  value: number
  color?: string
}

export class LocationDistributorAgeGroup
  implements ILocationDistributorAgeGroup {
  state?: string
  male18_34: number
  male35_40: number
  male41_60: number
  maleabove61: number
  female18_34: number
  female35_40: number
  female41_60: number
  femaleabove61: number

  constructor(data?: ILocationDistributorAgeGroup) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.state = data['state']
      this.male18_34 = data['male18_34']
      this.male35_40 = data['male35_40']
      this.male41_60 = data['male41_60']
      this.maleabove61 = data['maleabove61']
      this.female18_34 = data['female18_34']
      this.female35_40 = data['female35_40']
      this.female41_60 = data['female41_60']
      this.femaleabove61 = data['femaleabove61']
    }
  }

  static fromJS(data: any): LocationDistributorAgeGroup {
    data = typeof data === 'object' ? data : {}
    let result = new LocationDistributorAgeGroup()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['state'] = this.state
    data['male18_34'] = this.male18_34
    data['male35_40'] = this.male35_40
    data['male41_60'] = this.male41_60
    data['maleabove61'] = this.maleabove61
    data['female18_34'] = this.female18_34
    data['female35_40'] = this.female35_40
    data['female41_60'] = this.female41_60
    data['femaleabove61'] = this.femaleabove61
    return data
  }
}

export interface ILocationDistributorAgeGroup {
  state?: string
  male18_34: number
  male35_40: number
  male41_60: number
  maleabove61: number
  female18_34: number
  female35_40: number
  female41_60: number
  femaleabove61: number
}

export class AgeGrouGenders implements IAgeGrouGenders {
  male?: number[]
  feMale?: number[]

  constructor(data?: IAgeGrouGenders) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      if (data['male'] && data['male'].constructor === Array) {
        this.male = []
        for (let item of data['male']) this.male.push(item)
      }
      if (data['feMale'] && data['feMale'].constructor === Array) {
        this.feMale = []
        for (let item of data['feMale']) this.feMale.push(item)
      }
    }
  }

  static fromJS(data: any): AgeGrouGenders {
    data = typeof data === 'object' ? data : {}
    let result = new AgeGrouGenders()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    if (this.male && this.male.constructor === Array) {
      data['male'] = []
      for (let item of this.male) data['male'].push(item)
    }
    if (this.feMale && this.feMale.constructor === Array) {
      data['feMale'] = []
      for (let item of this.feMale) data['feMale'].push(item)
    }
    return data
  }
}

export interface IAgeGrouGenders {
  male?: number[]
  feMale?: number[]
}

export class IncomeBrackets implements IIncomeBrackets {
  incomeBracketColumns?: string[]
  incomeBracketMale?: number[]
  incomeBracketFeMale?: number[]

  constructor(data?: IIncomeBrackets) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      if (
        data['incomeBracketColumns'] &&
        data['incomeBracketColumns'].constructor === Array
      ) {
        this.incomeBracketColumns = []
        for (let item of data['incomeBracketColumns'])
          this.incomeBracketColumns.push(item)
      }
      if (
        data['incomeBracketMale'] &&
        data['incomeBracketMale'].constructor === Array
      ) {
        this.incomeBracketMale = []
        for (let item of data['incomeBracketMale'])
          this.incomeBracketMale.push(item)
      }
      if (
        data['incomeBracketFeMale'] &&
        data['incomeBracketFeMale'].constructor === Array
      ) {
        this.incomeBracketFeMale = []
        for (let item of data['incomeBracketFeMale'])
          this.incomeBracketFeMale.push(item)
      }
    }
  }

  static fromJS(data: any): IncomeBrackets {
    data = typeof data === 'object' ? data : {}
    let result = new IncomeBrackets()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    if (
      this.incomeBracketColumns &&
      this.incomeBracketColumns.constructor === Array
    ) {
      data['incomeBracketColumns'] = []
      for (let item of this.incomeBracketColumns)
        data['incomeBracketColumns'].push(item)
    }
    if (
      this.incomeBracketMale &&
      this.incomeBracketMale.constructor === Array
    ) {
      data['incomeBracketMale'] = []
      for (let item of this.incomeBracketMale)
        data['incomeBracketMale'].push(item)
    }
    if (
      this.incomeBracketFeMale &&
      this.incomeBracketFeMale.constructor === Array
    ) {
      data['incomeBracketFeMale'] = []
      for (let item of this.incomeBracketFeMale)
        data['incomeBracketFeMale'].push(item)
    }
    return data
  }
}

export interface IIncomeBrackets {
  incomeBracketColumns?: string[]
  incomeBracketMale?: number[]
  incomeBracketFeMale?: number[]
}

export class TotalRecordsAvailable implements ITotalRecordsAvailable {
  recordsvalue?: string
  maritalindicator: number
  emailaddress: number
  directorshipindicator: number
  deceasedindicator: number
  deedsindicator: number
  adverseindicator: number

  constructor(data?: ITotalRecordsAvailable) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.recordsvalue = data['recordsvalue']
      this.maritalindicator = data['maritalindicator']
      this.emailaddress = data['emailaddress']
      this.directorshipindicator = data['directorshipindicator']
      this.deceasedindicator = data['deceasedindicator']
      this.deedsindicator = data['deedsindicator']
      this.adverseindicator = data['adverseindicator']
    }
  }

  static fromJS(data: any): TotalRecordsAvailable {
    data = typeof data === 'object' ? data : {}
    let result = new TotalRecordsAvailable()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['recordsvalue'] = this.recordsvalue
    data['maritalindicator'] = this.maritalindicator
    data['emailaddress'] = this.emailaddress
    data['directorshipindicator'] = this.directorshipindicator
    data['deceasedindicator'] = this.deceasedindicator
    data['deedsindicator'] = this.deedsindicator
    data['adverseindicator'] = this.adverseindicator
    return data
  }
}

export interface ITotalRecordsAvailable {
  recordsvalue?: string
  maritalindicator: number
  emailaddress: number
  directorshipindicator: number
  deceasedindicator: number
  deedsindicator: number
  adverseindicator: number
}

export class Consumer implements IConsumer {
  consumerID: number
  idno?: string
  passportNo?: string
  firstName?: string
  secondName?: string
  thirdName?: string
  surname?: string
  birthDate?: Date
  maidenName?: string
  genderInd?: number
  recordStatusInd: number
  titleCode?: string
  createdOnDate?: Date
  firstInitial?: string
  lastUpdatedDate: Date
  alloy?: string
  lsm?: string
  consumerHomeAffairs?: ConsumerHomeAffair[]
  consumerAddress?: ConsumerAddress[]
  consumerEmploymentOccupations?: ConsumerEmploymentOccupation[]
  consumerTelephone?: ConsumerTelephone[]
  consumerEmails?: ConsumerEmailConfirmed[]
  consumerDebtReviews?: ConsumerDebtReview[]
  consumerJudgements?: ConsumerJudgement[]
  isESSynced: boolean

  constructor(data?: IConsumer) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.consumerID = data['consumerID']
      this.idno = data['idno']
      this.passportNo = data['passportNo']
      this.firstName = data['firstName']
      this.secondName = data['secondName']
      this.thirdName = data['thirdName']
      this.surname = data['surname']
      this.birthDate = data['birthDate']
        ? new Date(data['birthDate'].toString())
        : <any>undefined
      this.maidenName = data['maidenName']
      this.genderInd = data['genderInd']
      this.recordStatusInd = data['recordStatusInd']
      this.titleCode = data['titleCode']
      this.createdOnDate = data['createdOnDate']
        ? new Date(data['createdOnDate'].toString())
        : <any>undefined
      this.firstInitial = data['firstInitial']
      this.lastUpdatedDate = data['lastUpdatedDate']
        ? new Date(data['lastUpdatedDate'].toString())
        : <any>undefined
      this.alloy = data['alloy']
      this.lsm = data['lsm']
      if (
        data['consumerHomeAffairs'] &&
        data['consumerHomeAffairs'].constructor === Array
      ) {
        this.consumerHomeAffairs = []
        for (let item of data['consumerHomeAffairs'])
          this.consumerHomeAffairs.push(ConsumerHomeAffair.fromJS(item))
      }
      if (
        data['consumerAddress'] &&
        data['consumerAddress'].constructor === Array
      ) {
        this.consumerAddress = []
        for (let item of data['consumerAddress'])
          this.consumerAddress.push(ConsumerAddress.fromJS(item))
      }
      if (
        data['consumerEmploymentOccupations'] &&
        data['consumerEmploymentOccupations'].constructor === Array
      ) {
        this.consumerEmploymentOccupations = []
        for (let item of data['consumerEmploymentOccupations'])
          this.consumerEmploymentOccupations.push(
            ConsumerEmploymentOccupation.fromJS(item),
          )
      }
      if (
        data['consumerTelephone'] &&
        data['consumerTelephone'].constructor === Array
      ) {
        this.consumerTelephone = []
        for (let item of data['consumerTelephone'])
          this.consumerTelephone.push(ConsumerTelephone.fromJS(item))
      }
      if (
        data['consumerEmails'] &&
        data['consumerEmails'].constructor === Array
      ) {
        this.consumerEmails = []
        for (let item of data['consumerEmails'])
          this.consumerEmails.push(ConsumerEmailConfirmed.fromJS(item))
      }
      if (
        data['consumerDebtReviews'] &&
        data['consumerDebtReviews'].constructor === Array
      ) {
        this.consumerDebtReviews = []
        for (let item of data['consumerDebtReviews'])
          this.consumerDebtReviews.push(ConsumerDebtReview.fromJS(item))
      }
      if (
        data['consumerJudgements'] &&
        data['consumerJudgements'].constructor === Array
      ) {
        this.consumerJudgements = []
        for (let item of data['consumerJudgements'])
          this.consumerJudgements.push(ConsumerJudgement.fromJS(item))
      }
      this.isESSynced = data['isESSynced']
    }
  }

  static fromJS(data: any): Consumer {
    data = typeof data === 'object' ? data : {}
    let result = new Consumer()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['consumerID'] = this.consumerID
    data['idno'] = this.idno
    data['passportNo'] = this.passportNo
    data['firstName'] = this.firstName
    data['secondName'] = this.secondName
    data['thirdName'] = this.thirdName
    data['surname'] = this.surname
    data['birthDate'] = this.birthDate
      ? this.birthDate.toISOString()
      : <any>undefined
    data['maidenName'] = this.maidenName
    data['genderInd'] = this.genderInd
    data['recordStatusInd'] = this.recordStatusInd
    data['titleCode'] = this.titleCode
    data['createdOnDate'] = this.createdOnDate
      ? this.createdOnDate.toISOString()
      : <any>undefined
    data['firstInitial'] = this.firstInitial
    data['lastUpdatedDate'] = this.lastUpdatedDate
      ? this.lastUpdatedDate.toISOString()
      : <any>undefined
    data['alloy'] = this.alloy
    data['lsm'] = this.lsm
    if (
      this.consumerHomeAffairs &&
      this.consumerHomeAffairs.constructor === Array
    ) {
      data['consumerHomeAffairs'] = []
      for (let item of this.consumerHomeAffairs)
        data['consumerHomeAffairs'].push(item.toJSON())
    }
    if (this.consumerAddress && this.consumerAddress.constructor === Array) {
      data['consumerAddress'] = []
      for (let item of this.consumerAddress)
        data['consumerAddress'].push(item.toJSON())
    }
    if (
      this.consumerEmploymentOccupations &&
      this.consumerEmploymentOccupations.constructor === Array
    ) {
      data['consumerEmploymentOccupations'] = []
      for (let item of this.consumerEmploymentOccupations)
        data['consumerEmploymentOccupations'].push(item.toJSON())
    }
    if (
      this.consumerTelephone &&
      this.consumerTelephone.constructor === Array
    ) {
      data['consumerTelephone'] = []
      for (let item of this.consumerTelephone)
        data['consumerTelephone'].push(item.toJSON())
    }
    if (this.consumerEmails && this.consumerEmails.constructor === Array) {
      data['consumerEmails'] = []
      for (let item of this.consumerEmails)
        data['consumerEmails'].push(item.toJSON())
    }
    if (
      this.consumerDebtReviews &&
      this.consumerDebtReviews.constructor === Array
    ) {
      data['consumerDebtReviews'] = []
      for (let item of this.consumerDebtReviews)
        data['consumerDebtReviews'].push(item.toJSON())
    }
    if (
      this.consumerJudgements &&
      this.consumerJudgements.constructor === Array
    ) {
      data['consumerJudgements'] = []
      for (let item of this.consumerJudgements)
        data['consumerJudgements'].push(item.toJSON())
    }
    data['isESSynced'] = this.isESSynced
    return data
  }
}

export interface IConsumer {
  consumerID: number
  idno?: string
  passportNo?: string
  firstName?: string
  secondName?: string
  thirdName?: string
  surname?: string
  birthDate?: Date
  maidenName?: string
  genderInd?: number
  recordStatusInd: number
  titleCode?: string
  createdOnDate?: Date
  firstInitial?: string
  lastUpdatedDate: Date
  alloy?: string
  lsm?: string
  consumerHomeAffairs?: ConsumerHomeAffair[]
  consumerAddress?: ConsumerAddress[]
  consumerEmploymentOccupations?: ConsumerEmploymentOccupation[]
  consumerTelephone?: ConsumerTelephone[]
  consumerEmails?: ConsumerEmailConfirmed[]
  consumerDebtReviews?: ConsumerDebtReview[]
  consumerJudgements?: ConsumerJudgement[]
  isESSynced: boolean
}

export class ConsumerHomeAffair implements IConsumerHomeAffair {
  homeAffairsID: number
  idNo?: string
  firstName?: string
  secondName?: string
  thirdName?: string
  surname?: string
  nameCombo?: string
  birthDate?: Date
  homeAffairsRunYN: boolean
  homeAffairsMessage?: string
  recordStatusInd?: string
  deletedReason?: string
  lastUpdatedDate?: Date
  haRecordChecksum?: number
  subscriberID?: number
  loaderID?: number
  consumerID: number
  consumer?: Consumer
  createdByUser?: string
  createdOnDate?: Date
  changedByUser?: string
  changedOnDate?: Date
  isPossibleDuplicateRecordYN?: boolean
  isPossibleNameConflictYN?: boolean
  maidenName?: string
  idIssuedDate?: Date
  marriageDate?: Date
  placeOfMarriage?: string
  spouseIdnoOrDOB?: string
  spouseSurName?: string
  spouseForeNames?: string
  divorceDate?: Date
  divorceIssuedCourt?: string
  deceasedDate?: Date
  deceasedStatus?: string
  placeOfDeath?: string
  causeOfDeath?: string

  constructor(data?: IConsumerHomeAffair) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.homeAffairsID = data['homeAffairsID']
      this.idNo = data['idNo']
      this.firstName = data['firstName']
      this.secondName = data['secondName']
      this.thirdName = data['thirdName']
      this.surname = data['surname']
      this.nameCombo = data['nameCombo']
      this.birthDate = data['birthDate']
        ? new Date(data['birthDate'].toString())
        : <any>undefined
      this.homeAffairsRunYN = data['homeAffairsRunYN']
      this.homeAffairsMessage = data['homeAffairsMessage']
      this.recordStatusInd = data['recordStatusInd']
      this.deletedReason = data['deletedReason']
      this.lastUpdatedDate = data['lastUpdatedDate']
        ? new Date(data['lastUpdatedDate'].toString())
        : <any>undefined
      this.haRecordChecksum = data['haRecordChecksum']
      this.subscriberID = data['subscriberID']
      this.loaderID = data['loaderID']
      this.consumerID = data['consumerID']
      this.consumer = data['consumer']
        ? Consumer.fromJS(data['consumer'])
        : <any>undefined
      this.createdByUser = data['createdByUser']
      this.createdOnDate = data['createdOnDate']
        ? new Date(data['createdOnDate'].toString())
        : <any>undefined
      this.changedByUser = data['changedByUser']
      this.changedOnDate = data['changedOnDate']
        ? new Date(data['changedOnDate'].toString())
        : <any>undefined
      this.isPossibleDuplicateRecordYN = data['isPossibleDuplicateRecordYN']
      this.isPossibleNameConflictYN = data['isPossibleNameConflictYN']
      this.maidenName = data['maidenName']
      this.idIssuedDate = data['idIssuedDate']
        ? new Date(data['idIssuedDate'].toString())
        : <any>undefined
      this.marriageDate = data['marriageDate']
        ? new Date(data['marriageDate'].toString())
        : <any>undefined
      this.placeOfMarriage = data['placeOfMarriage']
      this.spouseIdnoOrDOB = data['spouseIdnoOrDOB']
      this.spouseSurName = data['spouseSurName']
      this.spouseForeNames = data['spouseForeNames']
      this.divorceDate = data['divorceDate']
        ? new Date(data['divorceDate'].toString())
        : <any>undefined
      this.divorceIssuedCourt = data['divorceIssuedCourt']
      this.deceasedDate = data['deceasedDate']
        ? new Date(data['deceasedDate'].toString())
        : <any>undefined
      this.deceasedStatus = data['deceasedStatus']
      this.placeOfDeath = data['placeOfDeath']
      this.causeOfDeath = data['causeOfDeath']
    }
  }

  static fromJS(data: any): ConsumerHomeAffair {
    data = typeof data === 'object' ? data : {}
    let result = new ConsumerHomeAffair()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['homeAffairsID'] = this.homeAffairsID
    data['idNo'] = this.idNo
    data['firstName'] = this.firstName
    data['secondName'] = this.secondName
    data['thirdName'] = this.thirdName
    data['surname'] = this.surname
    data['nameCombo'] = this.nameCombo
    data['birthDate'] = this.birthDate
      ? this.birthDate.toISOString()
      : <any>undefined
    data['homeAffairsRunYN'] = this.homeAffairsRunYN
    data['homeAffairsMessage'] = this.homeAffairsMessage
    data['recordStatusInd'] = this.recordStatusInd
    data['deletedReason'] = this.deletedReason
    data['lastUpdatedDate'] = this.lastUpdatedDate
      ? this.lastUpdatedDate.toISOString()
      : <any>undefined
    data['haRecordChecksum'] = this.haRecordChecksum
    data['subscriberID'] = this.subscriberID
    data['loaderID'] = this.loaderID
    data['consumerID'] = this.consumerID
    data['consumer'] = this.consumer ? this.consumer.toJSON() : <any>undefined
    data['createdByUser'] = this.createdByUser
    data['createdOnDate'] = this.createdOnDate
      ? this.createdOnDate.toISOString()
      : <any>undefined
    data['changedByUser'] = this.changedByUser
    data['changedOnDate'] = this.changedOnDate
      ? this.changedOnDate.toISOString()
      : <any>undefined
    data['isPossibleDuplicateRecordYN'] = this.isPossibleDuplicateRecordYN
    data['isPossibleNameConflictYN'] = this.isPossibleNameConflictYN
    data['maidenName'] = this.maidenName
    data['idIssuedDate'] = this.idIssuedDate
      ? this.idIssuedDate.toISOString()
      : <any>undefined
    data['marriageDate'] = this.marriageDate
      ? this.marriageDate.toISOString()
      : <any>undefined
    data['placeOfMarriage'] = this.placeOfMarriage
    data['spouseIdnoOrDOB'] = this.spouseIdnoOrDOB
    data['spouseSurName'] = this.spouseSurName
    data['spouseForeNames'] = this.spouseForeNames
    data['divorceDate'] = this.divorceDate
      ? this.divorceDate.toISOString()
      : <any>undefined
    data['divorceIssuedCourt'] = this.divorceIssuedCourt
    data['deceasedDate'] = this.deceasedDate
      ? this.deceasedDate.toISOString()
      : <any>undefined
    data['deceasedStatus'] = this.deceasedStatus
    data['placeOfDeath'] = this.placeOfDeath
    data['causeOfDeath'] = this.causeOfDeath
    return data
  }
}

export interface IConsumerHomeAffair {
  homeAffairsID: number
  idNo?: string
  firstName?: string
  secondName?: string
  thirdName?: string
  surname?: string
  nameCombo?: string
  birthDate?: Date
  homeAffairsRunYN: boolean
  homeAffairsMessage?: string
  recordStatusInd?: string
  deletedReason?: string
  lastUpdatedDate?: Date
  haRecordChecksum?: number
  subscriberID?: number
  loaderID?: number
  consumerID: number
  consumer?: Consumer
  createdByUser?: string
  createdOnDate?: Date
  changedByUser?: string
  changedOnDate?: Date
  isPossibleDuplicateRecordYN?: boolean
  isPossibleNameConflictYN?: boolean
  maidenName?: string
  idIssuedDate?: Date
  marriageDate?: Date
  placeOfMarriage?: string
  spouseIdnoOrDOB?: string
  spouseSurName?: string
  spouseForeNames?: string
  divorceDate?: Date
  divorceIssuedCourt?: string
  deceasedDate?: Date
  deceasedStatus?: string
  placeOfDeath?: string
  causeOfDeath?: string
}

export class ConsumerAddress implements IConsumerAddress {
  consumerAddressID: number
  consumerID: number
  consumer?: Consumer
  addressTypeInd: number
  originalAddress1?: string
  originalAddress2?: string
  originalAddress3?: string
  originalAddress4?: string
  originalPostalCode?: string
  occupantTypeInd?: string
  recordStatusInd: number
  lastUpdatedDate: Date
  createdOnDate?: Date
  town?: string
  region?: string
  province?: string
  changedOnDate?: Date

  constructor(data?: IConsumerAddress) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.consumerAddressID = data['consumerAddressID']
      this.consumerID = data['consumerID']
      this.consumer = data['consumer']
        ? Consumer.fromJS(data['consumer'])
        : <any>undefined
      this.addressTypeInd = data['addressTypeInd']
      this.originalAddress1 = data['originalAddress1']
      this.originalAddress2 = data['originalAddress2']
      this.originalAddress3 = data['originalAddress3']
      this.originalAddress4 = data['originalAddress4']
      this.originalPostalCode = data['originalPostalCode']
      this.occupantTypeInd = data['occupantTypeInd']
      this.recordStatusInd = data['recordStatusInd']
      this.lastUpdatedDate = data['lastUpdatedDate']
        ? new Date(data['lastUpdatedDate'].toString())
        : <any>undefined
      this.createdOnDate = data['createdOnDate']
        ? new Date(data['createdOnDate'].toString())
        : <any>undefined
      this.town = data['town']
      this.region = data['region']
      this.province = data['province']
      this.changedOnDate = data['changedOnDate']
        ? new Date(data['changedOnDate'].toString())
        : <any>undefined
    }
  }

  static fromJS(data: any): ConsumerAddress {
    data = typeof data === 'object' ? data : {}
    let result = new ConsumerAddress()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['consumerAddressID'] = this.consumerAddressID
    data['consumerID'] = this.consumerID
    data['consumer'] = this.consumer ? this.consumer.toJSON() : <any>undefined
    data['addressTypeInd'] = this.addressTypeInd
    data['originalAddress1'] = this.originalAddress1
    data['originalAddress2'] = this.originalAddress2
    data['originalAddress3'] = this.originalAddress3
    data['originalAddress4'] = this.originalAddress4
    data['originalPostalCode'] = this.originalPostalCode
    data['occupantTypeInd'] = this.occupantTypeInd
    data['recordStatusInd'] = this.recordStatusInd
    data['lastUpdatedDate'] = this.lastUpdatedDate
      ? this.lastUpdatedDate.toISOString()
      : <any>undefined
    data['createdOnDate'] = this.createdOnDate
      ? this.createdOnDate.toISOString()
      : <any>undefined
    data['town'] = this.town
    data['region'] = this.region
    data['province'] = this.province
    data['changedOnDate'] = this.changedOnDate
      ? this.changedOnDate.toISOString()
      : <any>undefined
    return data
  }
}

export interface IConsumerAddress {
  consumerAddressID: number
  consumerID: number
  consumer?: Consumer
  addressTypeInd: number
  originalAddress1?: string
  originalAddress2?: string
  originalAddress3?: string
  originalAddress4?: string
  originalPostalCode?: string
  occupantTypeInd?: string
  recordStatusInd: number
  lastUpdatedDate: Date
  createdOnDate?: Date
  town?: string
  region?: string
  province?: string
  changedOnDate?: Date
}

export class ConsumerEmploymentOccupation
  implements IConsumerEmploymentOccupation {
  consumerEmploymentOccupationID: number
  consumerID?: number
  consumer?: Consumer
  consumerEmploymentID?: number
  occupation?: string
  employer?: string
  lastUpdatedDate?: Date
  createdOnDate?: Date

  constructor(data?: IConsumerEmploymentOccupation) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.consumerEmploymentOccupationID =
        data['consumerEmploymentOccupationID']
      this.consumerID = data['consumerID']
      this.consumer = data['consumer']
        ? Consumer.fromJS(data['consumer'])
        : <any>undefined
      this.consumerEmploymentID = data['consumerEmploymentID']
      this.occupation = data['occupation']
      this.employer = data['employer']
      this.lastUpdatedDate = data['lastUpdatedDate']
        ? new Date(data['lastUpdatedDate'].toString())
        : <any>undefined
      this.createdOnDate = data['createdOnDate']
        ? new Date(data['createdOnDate'].toString())
        : <any>undefined
    }
  }

  static fromJS(data: any): ConsumerEmploymentOccupation {
    data = typeof data === 'object' ? data : {}
    let result = new ConsumerEmploymentOccupation()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['consumerEmploymentOccupationID'] = this.consumerEmploymentOccupationID
    data['consumerID'] = this.consumerID
    data['consumer'] = this.consumer ? this.consumer.toJSON() : <any>undefined
    data['consumerEmploymentID'] = this.consumerEmploymentID
    data['occupation'] = this.occupation
    data['employer'] = this.employer
    data['lastUpdatedDate'] = this.lastUpdatedDate
      ? this.lastUpdatedDate.toISOString()
      : <any>undefined
    data['createdOnDate'] = this.createdOnDate
      ? this.createdOnDate.toISOString()
      : <any>undefined
    return data
  }
}

export interface IConsumerEmploymentOccupation {
  consumerEmploymentOccupationID: number
  consumerID?: number
  consumer?: Consumer
  consumerEmploymentID?: number
  occupation?: string
  employer?: string
  lastUpdatedDate?: Date
  createdOnDate?: Date
}

export class ConsumerTelephone implements IConsumerTelephone {
  consumerTelephoneID: number
  consumerID: number
  consumer?: Consumer
  telephoneID: number
  telephone?: Telephone
  telephoneTypeInd?: number
  recordStatusInd: number
  createdonDate: Date
  changedonDate?: Date
  lastUpdatedDate: Date

  constructor(data?: IConsumerTelephone) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.consumerTelephoneID = data['consumerTelephoneID']
      this.consumerID = data['consumerID']
      this.consumer = data['consumer']
        ? Consumer.fromJS(data['consumer'])
        : <any>undefined
      this.telephoneID = data['telephoneID']
      this.telephone = data['telephone']
        ? Telephone.fromJS(data['telephone'])
        : <any>undefined
      this.telephoneTypeInd = data['telephoneTypeInd']
      this.recordStatusInd = data['recordStatusInd']
      this.createdonDate = data['createdonDate']
        ? new Date(data['createdonDate'].toString())
        : <any>undefined
      this.changedonDate = data['changedonDate']
        ? new Date(data['changedonDate'].toString())
        : <any>undefined
      this.lastUpdatedDate = data['lastUpdatedDate']
        ? new Date(data['lastUpdatedDate'].toString())
        : <any>undefined
    }
  }

  static fromJS(data: any): ConsumerTelephone {
    data = typeof data === 'object' ? data : {}
    let result = new ConsumerTelephone()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['consumerTelephoneID'] = this.consumerTelephoneID
    data['consumerID'] = this.consumerID
    data['consumer'] = this.consumer ? this.consumer.toJSON() : <any>undefined
    data['telephoneID'] = this.telephoneID
    data['telephone'] = this.telephone
      ? this.telephone.toJSON()
      : <any>undefined
    data['telephoneTypeInd'] = this.telephoneTypeInd
    data['recordStatusInd'] = this.recordStatusInd
    data['createdonDate'] = this.createdonDate
      ? this.createdonDate.toISOString()
      : <any>undefined
    data['changedonDate'] = this.changedonDate
      ? this.changedonDate.toISOString()
      : <any>undefined
    data['lastUpdatedDate'] = this.lastUpdatedDate
      ? this.lastUpdatedDate.toISOString()
      : <any>undefined
    return data
  }
}

export interface IConsumerTelephone {
  consumerTelephoneID: number
  consumerID: number
  consumer?: Consumer
  telephoneID: number
  telephone?: Telephone
  telephoneTypeInd?: number
  recordStatusInd: number
  createdonDate: Date
  changedonDate?: Date
  lastUpdatedDate: Date
}

export class Telephone implements ITelephone {
  telephoneID: number
  internationalDialingCode?: string
  telephoneCode?: string
  telephoneNo: number
  recordStatusInd: number
  createdonDate?: Date

  constructor(data?: ITelephone) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.telephoneID = data['telephoneID']
      this.internationalDialingCode = data['internationalDialingCode']
      this.telephoneCode = data['telephoneCode']
      this.telephoneNo = data['telephoneNo']
      this.recordStatusInd = data['recordStatusInd']
      this.createdonDate = data['createdonDate']
        ? new Date(data['createdonDate'].toString())
        : <any>undefined
    }
  }

  static fromJS(data: any): Telephone {
    data = typeof data === 'object' ? data : {}
    let result = new Telephone()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['telephoneID'] = this.telephoneID
    data['internationalDialingCode'] = this.internationalDialingCode
    data['telephoneCode'] = this.telephoneCode
    data['telephoneNo'] = this.telephoneNo
    data['recordStatusInd'] = this.recordStatusInd
    data['createdonDate'] = this.createdonDate
      ? this.createdonDate.toISOString()
      : <any>undefined
    return data
  }
}

export interface ITelephone {
  telephoneID: number
  internationalDialingCode?: string
  telephoneCode?: string
  telephoneNo: number
  recordStatusInd: number
  createdonDate?: Date
}

export class ConsumerEmailConfirmed implements IConsumerEmailConfirmed {
  id: number
  emailID?: string
  lastUpdatedDate?: Date
  createdOnDate?: Date
  consumerID: number
  consumer?: Consumer
  recordStatusInd: number

  constructor(data?: IConsumerEmailConfirmed) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.id = data['id']
      this.emailID = data['emailID']
      this.lastUpdatedDate = data['lastUpdatedDate']
        ? new Date(data['lastUpdatedDate'].toString())
        : <any>undefined
      this.createdOnDate = data['createdOnDate']
        ? new Date(data['createdOnDate'].toString())
        : <any>undefined
      this.consumerID = data['consumerID']
      this.consumer = data['consumer']
        ? Consumer.fromJS(data['consumer'])
        : <any>undefined
      this.recordStatusInd = data['recordStatusInd']
    }
  }

  static fromJS(data: any): ConsumerEmailConfirmed {
    data = typeof data === 'object' ? data : {}
    let result = new ConsumerEmailConfirmed()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['id'] = this.id
    data['emailID'] = this.emailID
    data['lastUpdatedDate'] = this.lastUpdatedDate
      ? this.lastUpdatedDate.toISOString()
      : <any>undefined
    data['createdOnDate'] = this.createdOnDate
      ? this.createdOnDate.toISOString()
      : <any>undefined
    data['consumerID'] = this.consumerID
    data['consumer'] = this.consumer ? this.consumer.toJSON() : <any>undefined
    data['recordStatusInd'] = this.recordStatusInd
    return data
  }
}

export interface IConsumerEmailConfirmed {
  id: number
  emailID?: string
  lastUpdatedDate?: Date
  createdOnDate?: Date
  consumerID: number
  consumer?: Consumer
  recordStatusInd: number
}

export class ConsumerDebtReview implements IConsumerDebtReview {
  consumerDebtReviewID: number
  consumerID: number
  consumer?: Consumer
  debtCounsellorRegistrationNo?: string
  debtCounsellorFirstName?: string
  debtCounsellorSurname?: string
  debtCounsellorTelephoneCode?: string
  debtCounsellorTelephoneNo?: string
  applicationCreationDate?: Date
  debtReviewStatusDate?: Date
  recordStatusInd: number
  lastUpdatedDate: Date
  debtReviewStatusCode?: string

  constructor(data?: IConsumerDebtReview) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.consumerDebtReviewID = data['consumerDebtReviewID']
      this.consumerID = data['consumerID']
      this.consumer = data['consumer']
        ? Consumer.fromJS(data['consumer'])
        : <any>undefined
      this.debtCounsellorRegistrationNo = data['debtCounsellorRegistrationNo']
      this.debtCounsellorFirstName = data['debtCounsellorFirstName']
      this.debtCounsellorSurname = data['debtCounsellorSurname']
      this.debtCounsellorTelephoneCode = data['debtCounsellorTelephoneCode']
      this.debtCounsellorTelephoneNo = data['debtCounsellorTelephoneNo']
      this.applicationCreationDate = data['applicationCreationDate']
        ? new Date(data['applicationCreationDate'].toString())
        : <any>undefined
      this.debtReviewStatusDate = data['debtReviewStatusDate']
        ? new Date(data['debtReviewStatusDate'].toString())
        : <any>undefined
      this.recordStatusInd = data['recordStatusInd']
      this.lastUpdatedDate = data['lastUpdatedDate']
        ? new Date(data['lastUpdatedDate'].toString())
        : <any>undefined
      this.debtReviewStatusCode = data['debtReviewStatusCode']
    }
  }

  static fromJS(data: any): ConsumerDebtReview {
    data = typeof data === 'object' ? data : {}
    let result = new ConsumerDebtReview()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['consumerDebtReviewID'] = this.consumerDebtReviewID
    data['consumerID'] = this.consumerID
    data['consumer'] = this.consumer ? this.consumer.toJSON() : <any>undefined
    data['debtCounsellorRegistrationNo'] = this.debtCounsellorRegistrationNo
    data['debtCounsellorFirstName'] = this.debtCounsellorFirstName
    data['debtCounsellorSurname'] = this.debtCounsellorSurname
    data['debtCounsellorTelephoneCode'] = this.debtCounsellorTelephoneCode
    data['debtCounsellorTelephoneNo'] = this.debtCounsellorTelephoneNo
    data['applicationCreationDate'] = this.applicationCreationDate
      ? this.applicationCreationDate.toISOString()
      : <any>undefined
    data['debtReviewStatusDate'] = this.debtReviewStatusDate
      ? this.debtReviewStatusDate.toISOString()
      : <any>undefined
    data['recordStatusInd'] = this.recordStatusInd
    data['lastUpdatedDate'] = this.lastUpdatedDate
      ? this.lastUpdatedDate.toISOString()
      : <any>undefined
    data['debtReviewStatusCode'] = this.debtReviewStatusCode
    return data
  }
}

export interface IConsumerDebtReview {
  consumerDebtReviewID: number
  consumerID: number
  consumer?: Consumer
  debtCounsellorRegistrationNo?: string
  debtCounsellorFirstName?: string
  debtCounsellorSurname?: string
  debtCounsellorTelephoneCode?: string
  debtCounsellorTelephoneNo?: string
  applicationCreationDate?: Date
  debtReviewStatusDate?: Date
  recordStatusInd: number
  lastUpdatedDate: Date
  debtReviewStatusCode?: string
}

export class ConsumerJudgement implements IConsumerJudgement {
  consumerJudgementID: number
  consumerID: number
  idNo?: string
  caseNumber: string
  caseFilingDate?: Date
  caseReason?: string
  caseType?: string
  disputeAmt?: number
  courtName?: string
  courtCity?: string
  courtType?: string
  plaintiffName?: string
  plaintiffAddress1?: string
  plaintiffAddress2?: string
  plaintiffAddress3?: string
  plaintiffAddress4?: string
  plaintiffPostalCode?: string
  attorneyName?: string
  attorneyTelephoneCode?: string
  attorneyTelephoneNo?: string
  attorneyFaxCode?: string
  attorneyFaxNo?: string
  attorneyAddress1?: string
  attorneyAddress2?: string
  attorneyAddress3?: string
  attorneyAddress4?: string
  attorneyPostalCode?: string
  lastUpdatedDate: Date
  createdOnDate?: Date
  judgementTypeCode?: string
  disputeDate?: Date
  disputeResolvedDate?: Date
  rescinded?: boolean
  rescissionDate?: Date
  rescissionReason?: string
  rescindedAmount?: string

  constructor(data?: IConsumerJudgement) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.consumerJudgementID = data['consumerJudgementID']
      this.consumerID = data['consumerID']
      this.idNo = data['idNo']
      this.caseNumber = data['caseNumber']
      this.caseFilingDate = data['caseFilingDate']
        ? new Date(data['caseFilingDate'].toString())
        : <any>undefined
      this.caseReason = data['caseReason']
      this.caseType = data['caseType']
      this.disputeAmt = data['disputeAmt']
      this.courtName = data['courtName']
      this.courtCity = data['courtCity']
      this.courtType = data['courtType']
      this.plaintiffName = data['plaintiffName']
      this.plaintiffAddress1 = data['plaintiffAddress1']
      this.plaintiffAddress2 = data['plaintiffAddress2']
      this.plaintiffAddress3 = data['plaintiffAddress3']
      this.plaintiffAddress4 = data['plaintiffAddress4']
      this.plaintiffPostalCode = data['plaintiffPostalCode']
      this.attorneyName = data['attorneyName']
      this.attorneyTelephoneCode = data['attorneyTelephoneCode']
      this.attorneyTelephoneNo = data['attorneyTelephoneNo']
      this.attorneyFaxCode = data['attorneyFaxCode']
      this.attorneyFaxNo = data['attorneyFaxNo']
      this.attorneyAddress1 = data['attorneyAddress1']
      this.attorneyAddress2 = data['attorneyAddress2']
      this.attorneyAddress3 = data['attorneyAddress3']
      this.attorneyAddress4 = data['attorneyAddress4']
      this.attorneyPostalCode = data['attorneyPostalCode']
      this.lastUpdatedDate = data['lastUpdatedDate']
        ? new Date(data['lastUpdatedDate'].toString())
        : <any>undefined
      this.createdOnDate = data['createdOnDate']
        ? new Date(data['createdOnDate'].toString())
        : <any>undefined
      this.judgementTypeCode = data['judgementTypeCode']
      this.disputeDate = data['disputeDate']
        ? new Date(data['disputeDate'].toString())
        : <any>undefined
      this.disputeResolvedDate = data['disputeResolvedDate']
        ? new Date(data['disputeResolvedDate'].toString())
        : <any>undefined
      this.rescinded = data['rescinded']
      this.rescissionDate = data['rescissionDate']
        ? new Date(data['rescissionDate'].toString())
        : <any>undefined
      this.rescissionReason = data['rescissionReason']
      this.rescindedAmount = data['rescindedAmount']
    }
  }

  static fromJS(data: any): ConsumerJudgement {
    data = typeof data === 'object' ? data : {}
    let result = new ConsumerJudgement()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['consumerJudgementID'] = this.consumerJudgementID
    data['consumerID'] = this.consumerID
    data['idNo'] = this.idNo
    data['caseNumber'] = this.caseNumber
    data['caseFilingDate'] = this.caseFilingDate
      ? this.caseFilingDate.toISOString()
      : <any>undefined
    data['caseReason'] = this.caseReason
    data['caseType'] = this.caseType
    data['disputeAmt'] = this.disputeAmt
    data['courtName'] = this.courtName
    data['courtCity'] = this.courtCity
    data['courtType'] = this.courtType
    data['plaintiffName'] = this.plaintiffName
    data['plaintiffAddress1'] = this.plaintiffAddress1
    data['plaintiffAddress2'] = this.plaintiffAddress2
    data['plaintiffAddress3'] = this.plaintiffAddress3
    data['plaintiffAddress4'] = this.plaintiffAddress4
    data['plaintiffPostalCode'] = this.plaintiffPostalCode
    data['attorneyName'] = this.attorneyName
    data['attorneyTelephoneCode'] = this.attorneyTelephoneCode
    data['attorneyTelephoneNo'] = this.attorneyTelephoneNo
    data['attorneyFaxCode'] = this.attorneyFaxCode
    data['attorneyFaxNo'] = this.attorneyFaxNo
    data['attorneyAddress1'] = this.attorneyAddress1
    data['attorneyAddress2'] = this.attorneyAddress2
    data['attorneyAddress3'] = this.attorneyAddress3
    data['attorneyAddress4'] = this.attorneyAddress4
    data['attorneyPostalCode'] = this.attorneyPostalCode
    data['lastUpdatedDate'] = this.lastUpdatedDate
      ? this.lastUpdatedDate.toISOString()
      : <any>undefined
    data['createdOnDate'] = this.createdOnDate
      ? this.createdOnDate.toISOString()
      : <any>undefined
    data['judgementTypeCode'] = this.judgementTypeCode
    data['disputeDate'] = this.disputeDate
      ? this.disputeDate.toISOString()
      : <any>undefined
    data['disputeResolvedDate'] = this.disputeResolvedDate
      ? this.disputeResolvedDate.toISOString()
      : <any>undefined
    data['rescinded'] = this.rescinded
    data['rescissionDate'] = this.rescissionDate
      ? this.rescissionDate.toISOString()
      : <any>undefined
    data['rescissionReason'] = this.rescissionReason
    data['rescindedAmount'] = this.rescindedAmount
    return data
  }
}

export interface IConsumerJudgement {
  consumerJudgementID: number
  consumerID: number
  idNo?: string
  caseNumber: string
  caseFilingDate?: Date
  caseReason?: string
  caseType?: string
  disputeAmt?: number
  courtName?: string
  courtCity?: string
  courtType?: string
  plaintiffName?: string
  plaintiffAddress1?: string
  plaintiffAddress2?: string
  plaintiffAddress3?: string
  plaintiffAddress4?: string
  plaintiffPostalCode?: string
  attorneyName?: string
  attorneyTelephoneCode?: string
  attorneyTelephoneNo?: string
  attorneyFaxCode?: string
  attorneyFaxNo?: string
  attorneyAddress1?: string
  attorneyAddress2?: string
  attorneyAddress3?: string
  attorneyAddress4?: string
  attorneyPostalCode?: string
  lastUpdatedDate: Date
  createdOnDate?: Date
  judgementTypeCode?: string
  disputeDate?: Date
  disputeResolvedDate?: Date
  rescinded?: boolean
  rescissionDate?: Date
  rescissionReason?: string
  rescindedAmount?: string
}

export class BatchTracingConsumer implements IBatchTracingConsumer {
  idnumber?: string
  dob?: string
  title?: string
  initials?: string
  name?: string
  suR_NAME?: string
  firsT_NAME?: string
  otheR_NAMES?: string
  spousE_NAME?: string
  profilE_GENDER?: string
  profilE_AGE_GROUP?: string
  profilE_MARITAL_STATUS?: string
  lsm?: string
  contacT_SCORE?: string
  income?: string
  profilE_HOMEOWNERSHIP?: string
  profilE_DIRECTORSHIP?: string
  profilE_CONTACT_ABILITY?: string
  risK_SCORE?: string
  judgE_INDICATOR?: string
  deceaseD_IND?: string
  x_DATEOFDEATH?: string
  occupation?: string
  employmenT_DATE?: string
  homE_ADDRESS_LINE_1?: string
  homE_ADDRESS_LINE_2?: string
  homE_ADDRESS_TOWNSHIP?: string
  homE_ADDRESS_REGION?: string
  homE_ADDRESS_PROVINCE?: string
  homE_ADDRESS_POSTAL_CODE?: string
  homE_ADDRESS_DATE?: string
  postaL_ADDRESS_LINE_1?: string
  postaL_ADDRESS_LINE_2?: string
  postaL_ADDRESS_TOWNSHIP?: string
  postaL_ADDRESS_REGION?: string
  postaL_ADDRESS_PROVINCE?: string
  postaL_ADDRESS_POSTAL_CODE?: string
  postaL_ADDRESS_DATE?: string
  homE_1_PHONE_NUMBER?: string
  homE_1_DATE?: string
  worK_1_PHONE_NUMBER?: string
  worK_1_DATE?: string
  celL_1_PHONE_NUMBER?: string
  celL_1_DATE?: string
  homE_2_PHONE_NUMBER?: string
  homE_2_DATE?: string
  worK_2_PHONE_NUMBER?: string
  worK_2_DATE?: string
  celL_2_PHONE_NUMBER?: string
  celL_2_DATE?: string
  homE_3_PHONE_NUMBER?: string
  homE_3_DATE?: string
  worK_3_PHONE_NUMBER?: string
  worK_3_DATE?: string
  celL_3_PHONE_NUMBER?: string
  celL_3_DATE?: string
  homE_4_PHONE_NUMBER?: string
  homE_4_DATE?: string
  worK_4_PHONE_NUMBER?: string
  worK_4_DATE?: string
  celL_4_PHONE_NUMBER?: string
  celL_4_DATE?: string
  homE_5_PHONE_NUMBER?: string
  homE_5_DATE?: string
  worK_5_PHONE_NUMBER?: string
  worK_5_DATE?: string
  celL_5_PHONE_NUMBER?: string
  celL_5_DATE?: string
  d_O_NUMBER_TYPE_1?: string
  d_O_PHONE_NUMBER_1?: string
  d_O_DATE_1?: string
  d_O_NUMBER_TYPE_2?: string
  d_O_PHONE_NUMBER_2?: string
  d_O_DATE_2?: string
  d_O_NUMBER_TYPE_3?: string
  d_O_PHONE_NUMBER_3?: string
  d_O_DATE_3?: string
  d_O_NUMBER_TYPE_4?: string
  d_O_PHONE_NUMBER_4?: string
  d_O_DATE_4?: string
  d_O_NUMBER_TYPE_5?: string
  d_O_PHONE_NUMBER_5?: string
  d_O_DATE_5?: string
  d_O_NUMBER_TYPE_6?: string
  d_O_PHONE_NUMBER_6?: string
  d_O_DATE_6?: string
  d_O_NUMBER_TYPE_7?: string
  d_O_PHONE_NUMBER_7?: string
  d_O_DATE_7?: string
  d_O_NUMBER_TYPE_8?: string
  d_O_PHONE_NUMBER_8?: string
  d_O_DATE_8?: string
  d_O_NUMBER_TYPE_9?: string
  d_O_PHONE_NUMBER_9?: string
  d_O_DATE_9?: string
  d_O_NUMBER_TYPE_10?: string
  d_O_PHONE_NUMBER_10?: string
  d_O_DATE_10?: string
  d_O_NUMBER_TYPE_11?: string
  d_O_PHONE_NUMBER_11?: string
  d_O_DATE_11?: string
  d_O_NUMBER_TYPE_12?: string
  d_O_PHONE_NUMBER_12?: string
  d_O_DATE_12?: string
  d_O_NUMBER_TYPE_13?: string
  d_O_PHONE_NUMBER_13?: string
  d_O_DATE_13?: string
  d_O_NUMBER_TYPE_14?: string
  d_O_PHONE_NUMBER_14?: string
  d_O_DATE_14?: string
  d_O_NUMBER_TYPE_15?: string
  d_O_PHONE_NUMBER_15?: string
  d_O_DATE_15?: string
  x_EMAIL?: string
  x_EMPLOYMENT_1?: string
  x_EMPLOYMENT_1_DATE?: string
  x_EMPLOYMENT_2?: string
  x_EMPLOYMENT_2_DATE?: string
  x_EMPLOYMENT_3?: string
  x_EMPLOYMENT_3_DATE?: string
  x_EMPLOYMENT_4?: string
  x_EMPLOYMENT_4_DATE?: string
  x_EMPLOYMENT_5?: string
  x_EMPLOYMENT_5_DATE?: string

  constructor(data?: IBatchTracingConsumer) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.idnumber = data['idnumber']
      this.dob = data['dob']
      this.title = data['title']
      this.initials = data['initials']
      this.name = data['name']
      this.suR_NAME = data['suR_NAME']
      this.firsT_NAME = data['firsT_NAME']
      this.otheR_NAMES = data['otheR_NAMES']
      this.spousE_NAME = data['spousE_NAME']
      this.profilE_GENDER = data['profilE_GENDER']
      this.profilE_AGE_GROUP = data['profilE_AGE_GROUP']
      this.profilE_MARITAL_STATUS = data['profilE_MARITAL_STATUS']
      this.lsm = data['lsm']
      this.contacT_SCORE = data['contacT_SCORE']
      this.income = data['income']
      this.profilE_HOMEOWNERSHIP = data['profilE_HOMEOWNERSHIP']
      this.profilE_DIRECTORSHIP = data['profilE_DIRECTORSHIP']
      this.profilE_CONTACT_ABILITY = data['profilE_CONTACT_ABILITY']
      this.risK_SCORE = data['risK_SCORE']
      this.judgE_INDICATOR = data['judgE_INDICATOR']
      this.deceaseD_IND = data['deceaseD_IND']
      this.x_DATEOFDEATH = data['x_DATEOFDEATH']
      this.occupation = data['occupation']
      this.employmenT_DATE = data['employmenT_DATE']
      this.homE_ADDRESS_LINE_1 = data['homE_ADDRESS_LINE_1']
      this.homE_ADDRESS_LINE_2 = data['homE_ADDRESS_LINE_2']
      this.homE_ADDRESS_TOWNSHIP = data['homE_ADDRESS_TOWNSHIP']
      this.homE_ADDRESS_REGION = data['homE_ADDRESS_REGION']
      this.homE_ADDRESS_PROVINCE = data['homE_ADDRESS_PROVINCE']
      this.homE_ADDRESS_POSTAL_CODE = data['homE_ADDRESS_POSTAL_CODE']
      this.homE_ADDRESS_DATE = data['homE_ADDRESS_DATE']
      this.postaL_ADDRESS_LINE_1 = data['postaL_ADDRESS_LINE_1']
      this.postaL_ADDRESS_LINE_2 = data['postaL_ADDRESS_LINE_2']
      this.postaL_ADDRESS_TOWNSHIP = data['postaL_ADDRESS_TOWNSHIP']
      this.postaL_ADDRESS_REGION = data['postaL_ADDRESS_REGION']
      this.postaL_ADDRESS_PROVINCE = data['postaL_ADDRESS_PROVINCE']
      this.postaL_ADDRESS_POSTAL_CODE = data['postaL_ADDRESS_POSTAL_CODE']
      this.postaL_ADDRESS_DATE = data['postaL_ADDRESS_DATE']
      this.homE_1_PHONE_NUMBER = data['homE_1_PHONE_NUMBER']
      this.homE_1_DATE = data['homE_1_DATE']
      this.worK_1_PHONE_NUMBER = data['worK_1_PHONE_NUMBER']
      this.worK_1_DATE = data['worK_1_DATE']
      this.celL_1_PHONE_NUMBER = data['celL_1_PHONE_NUMBER']
      this.celL_1_DATE = data['celL_1_DATE']
      this.homE_2_PHONE_NUMBER = data['homE_2_PHONE_NUMBER']
      this.homE_2_DATE = data['homE_2_DATE']
      this.worK_2_PHONE_NUMBER = data['worK_2_PHONE_NUMBER']
      this.worK_2_DATE = data['worK_2_DATE']
      this.celL_2_PHONE_NUMBER = data['celL_2_PHONE_NUMBER']
      this.celL_2_DATE = data['celL_2_DATE']
      this.homE_3_PHONE_NUMBER = data['homE_3_PHONE_NUMBER']
      this.homE_3_DATE = data['homE_3_DATE']
      this.worK_3_PHONE_NUMBER = data['worK_3_PHONE_NUMBER']
      this.worK_3_DATE = data['worK_3_DATE']
      this.celL_3_PHONE_NUMBER = data['celL_3_PHONE_NUMBER']
      this.celL_3_DATE = data['celL_3_DATE']
      this.homE_4_PHONE_NUMBER = data['homE_4_PHONE_NUMBER']
      this.homE_4_DATE = data['homE_4_DATE']
      this.worK_4_PHONE_NUMBER = data['worK_4_PHONE_NUMBER']
      this.worK_4_DATE = data['worK_4_DATE']
      this.celL_4_PHONE_NUMBER = data['celL_4_PHONE_NUMBER']
      this.celL_4_DATE = data['celL_4_DATE']
      this.homE_5_PHONE_NUMBER = data['homE_5_PHONE_NUMBER']
      this.homE_5_DATE = data['homE_5_DATE']
      this.worK_5_PHONE_NUMBER = data['worK_5_PHONE_NUMBER']
      this.worK_5_DATE = data['worK_5_DATE']
      this.celL_5_PHONE_NUMBER = data['celL_5_PHONE_NUMBER']
      this.celL_5_DATE = data['celL_5_DATE']
      this.d_O_NUMBER_TYPE_1 = data['d_O_NUMBER_TYPE_1']
      this.d_O_PHONE_NUMBER_1 = data['d_O_PHONE_NUMBER_1']
      this.d_O_DATE_1 = data['d_O_DATE_1']
      this.d_O_NUMBER_TYPE_2 = data['d_O_NUMBER_TYPE_2']
      this.d_O_PHONE_NUMBER_2 = data['d_O_PHONE_NUMBER_2']
      this.d_O_DATE_2 = data['d_O_DATE_2']
      this.d_O_NUMBER_TYPE_3 = data['d_O_NUMBER_TYPE_3']
      this.d_O_PHONE_NUMBER_3 = data['d_O_PHONE_NUMBER_3']
      this.d_O_DATE_3 = data['d_O_DATE_3']
      this.d_O_NUMBER_TYPE_4 = data['d_O_NUMBER_TYPE_4']
      this.d_O_PHONE_NUMBER_4 = data['d_O_PHONE_NUMBER_4']
      this.d_O_DATE_4 = data['d_O_DATE_4']
      this.d_O_NUMBER_TYPE_5 = data['d_O_NUMBER_TYPE_5']
      this.d_O_PHONE_NUMBER_5 = data['d_O_PHONE_NUMBER_5']
      this.d_O_DATE_5 = data['d_O_DATE_5']
      this.d_O_NUMBER_TYPE_6 = data['d_O_NUMBER_TYPE_6']
      this.d_O_PHONE_NUMBER_6 = data['d_O_PHONE_NUMBER_6']
      this.d_O_DATE_6 = data['d_O_DATE_6']
      this.d_O_NUMBER_TYPE_7 = data['d_O_NUMBER_TYPE_7']
      this.d_O_PHONE_NUMBER_7 = data['d_O_PHONE_NUMBER_7']
      this.d_O_DATE_7 = data['d_O_DATE_7']
      this.d_O_NUMBER_TYPE_8 = data['d_O_NUMBER_TYPE_8']
      this.d_O_PHONE_NUMBER_8 = data['d_O_PHONE_NUMBER_8']
      this.d_O_DATE_8 = data['d_O_DATE_8']
      this.d_O_NUMBER_TYPE_9 = data['d_O_NUMBER_TYPE_9']
      this.d_O_PHONE_NUMBER_9 = data['d_O_PHONE_NUMBER_9']
      this.d_O_DATE_9 = data['d_O_DATE_9']
      this.d_O_NUMBER_TYPE_10 = data['d_O_NUMBER_TYPE_10']
      this.d_O_PHONE_NUMBER_10 = data['d_O_PHONE_NUMBER_10']
      this.d_O_DATE_10 = data['d_O_DATE_10']
      this.d_O_NUMBER_TYPE_11 = data['d_O_NUMBER_TYPE_11']
      this.d_O_PHONE_NUMBER_11 = data['d_O_PHONE_NUMBER_11']
      this.d_O_DATE_11 = data['d_O_DATE_11']
      this.d_O_NUMBER_TYPE_12 = data['d_O_NUMBER_TYPE_12']
      this.d_O_PHONE_NUMBER_12 = data['d_O_PHONE_NUMBER_12']
      this.d_O_DATE_12 = data['d_O_DATE_12']
      this.d_O_NUMBER_TYPE_13 = data['d_O_NUMBER_TYPE_13']
      this.d_O_PHONE_NUMBER_13 = data['d_O_PHONE_NUMBER_13']
      this.d_O_DATE_13 = data['d_O_DATE_13']
      this.d_O_NUMBER_TYPE_14 = data['d_O_NUMBER_TYPE_14']
      this.d_O_PHONE_NUMBER_14 = data['d_O_PHONE_NUMBER_14']
      this.d_O_DATE_14 = data['d_O_DATE_14']
      this.d_O_NUMBER_TYPE_15 = data['d_O_NUMBER_TYPE_15']
      this.d_O_PHONE_NUMBER_15 = data['d_O_PHONE_NUMBER_15']
      this.d_O_DATE_15 = data['d_O_DATE_15']
      this.x_EMAIL = data['x_EMAIL']
      this.x_EMPLOYMENT_1 = data['x_EMPLOYMENT_1']
      this.x_EMPLOYMENT_1_DATE = data['x_EMPLOYMENT_1_DATE']
      this.x_EMPLOYMENT_2 = data['x_EMPLOYMENT_2']
      this.x_EMPLOYMENT_2_DATE = data['x_EMPLOYMENT_2_DATE']
      this.x_EMPLOYMENT_3 = data['x_EMPLOYMENT_3']
      this.x_EMPLOYMENT_3_DATE = data['x_EMPLOYMENT_3_DATE']
      this.x_EMPLOYMENT_4 = data['x_EMPLOYMENT_4']
      this.x_EMPLOYMENT_4_DATE = data['x_EMPLOYMENT_4_DATE']
      this.x_EMPLOYMENT_5 = data['x_EMPLOYMENT_5']
      this.x_EMPLOYMENT_5_DATE = data['x_EMPLOYMENT_5_DATE']
    }
  }

  static fromJS(data: any): BatchTracingConsumer {
    data = typeof data === 'object' ? data : {}
    let result = new BatchTracingConsumer()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['idnumber'] = this.idnumber
    data['dob'] = this.dob
    data['title'] = this.title
    data['initials'] = this.initials
    data['name'] = this.name
    data['suR_NAME'] = this.suR_NAME
    data['firsT_NAME'] = this.firsT_NAME
    data['otheR_NAMES'] = this.otheR_NAMES
    data['spousE_NAME'] = this.spousE_NAME
    data['profilE_GENDER'] = this.profilE_GENDER
    data['profilE_AGE_GROUP'] = this.profilE_AGE_GROUP
    data['profilE_MARITAL_STATUS'] = this.profilE_MARITAL_STATUS
    data['lsm'] = this.lsm
    data['contacT_SCORE'] = this.contacT_SCORE
    data['income'] = this.income
    data['profilE_HOMEOWNERSHIP'] = this.profilE_HOMEOWNERSHIP
    data['profilE_DIRECTORSHIP'] = this.profilE_DIRECTORSHIP
    data['profilE_CONTACT_ABILITY'] = this.profilE_CONTACT_ABILITY
    data['risK_SCORE'] = this.risK_SCORE
    data['judgE_INDICATOR'] = this.judgE_INDICATOR
    data['deceaseD_IND'] = this.deceaseD_IND
    data['x_DATEOFDEATH'] = this.x_DATEOFDEATH
    data['occupation'] = this.occupation
    data['employmenT_DATE'] = this.employmenT_DATE
    data['homE_ADDRESS_LINE_1'] = this.homE_ADDRESS_LINE_1
    data['homE_ADDRESS_LINE_2'] = this.homE_ADDRESS_LINE_2
    data['homE_ADDRESS_TOWNSHIP'] = this.homE_ADDRESS_TOWNSHIP
    data['homE_ADDRESS_REGION'] = this.homE_ADDRESS_REGION
    data['homE_ADDRESS_PROVINCE'] = this.homE_ADDRESS_PROVINCE
    data['homE_ADDRESS_POSTAL_CODE'] = this.homE_ADDRESS_POSTAL_CODE
    data['homE_ADDRESS_DATE'] = this.homE_ADDRESS_DATE
    data['postaL_ADDRESS_LINE_1'] = this.postaL_ADDRESS_LINE_1
    data['postaL_ADDRESS_LINE_2'] = this.postaL_ADDRESS_LINE_2
    data['postaL_ADDRESS_TOWNSHIP'] = this.postaL_ADDRESS_TOWNSHIP
    data['postaL_ADDRESS_REGION'] = this.postaL_ADDRESS_REGION
    data['postaL_ADDRESS_PROVINCE'] = this.postaL_ADDRESS_PROVINCE
    data['postaL_ADDRESS_POSTAL_CODE'] = this.postaL_ADDRESS_POSTAL_CODE
    data['postaL_ADDRESS_DATE'] = this.postaL_ADDRESS_DATE
    data['homE_1_PHONE_NUMBER'] = this.homE_1_PHONE_NUMBER
    data['homE_1_DATE'] = this.homE_1_DATE
    data['worK_1_PHONE_NUMBER'] = this.worK_1_PHONE_NUMBER
    data['worK_1_DATE'] = this.worK_1_DATE
    data['celL_1_PHONE_NUMBER'] = this.celL_1_PHONE_NUMBER
    data['celL_1_DATE'] = this.celL_1_DATE
    data['homE_2_PHONE_NUMBER'] = this.homE_2_PHONE_NUMBER
    data['homE_2_DATE'] = this.homE_2_DATE
    data['worK_2_PHONE_NUMBER'] = this.worK_2_PHONE_NUMBER
    data['worK_2_DATE'] = this.worK_2_DATE
    data['celL_2_PHONE_NUMBER'] = this.celL_2_PHONE_NUMBER
    data['celL_2_DATE'] = this.celL_2_DATE
    data['homE_3_PHONE_NUMBER'] = this.homE_3_PHONE_NUMBER
    data['homE_3_DATE'] = this.homE_3_DATE
    data['worK_3_PHONE_NUMBER'] = this.worK_3_PHONE_NUMBER
    data['worK_3_DATE'] = this.worK_3_DATE
    data['celL_3_PHONE_NUMBER'] = this.celL_3_PHONE_NUMBER
    data['celL_3_DATE'] = this.celL_3_DATE
    data['homE_4_PHONE_NUMBER'] = this.homE_4_PHONE_NUMBER
    data['homE_4_DATE'] = this.homE_4_DATE
    data['worK_4_PHONE_NUMBER'] = this.worK_4_PHONE_NUMBER
    data['worK_4_DATE'] = this.worK_4_DATE
    data['celL_4_PHONE_NUMBER'] = this.celL_4_PHONE_NUMBER
    data['celL_4_DATE'] = this.celL_4_DATE
    data['homE_5_PHONE_NUMBER'] = this.homE_5_PHONE_NUMBER
    data['homE_5_DATE'] = this.homE_5_DATE
    data['worK_5_PHONE_NUMBER'] = this.worK_5_PHONE_NUMBER
    data['worK_5_DATE'] = this.worK_5_DATE
    data['celL_5_PHONE_NUMBER'] = this.celL_5_PHONE_NUMBER
    data['celL_5_DATE'] = this.celL_5_DATE
    data['d_O_NUMBER_TYPE_1'] = this.d_O_NUMBER_TYPE_1
    data['d_O_PHONE_NUMBER_1'] = this.d_O_PHONE_NUMBER_1
    data['d_O_DATE_1'] = this.d_O_DATE_1
    data['d_O_NUMBER_TYPE_2'] = this.d_O_NUMBER_TYPE_2
    data['d_O_PHONE_NUMBER_2'] = this.d_O_PHONE_NUMBER_2
    data['d_O_DATE_2'] = this.d_O_DATE_2
    data['d_O_NUMBER_TYPE_3'] = this.d_O_NUMBER_TYPE_3
    data['d_O_PHONE_NUMBER_3'] = this.d_O_PHONE_NUMBER_3
    data['d_O_DATE_3'] = this.d_O_DATE_3
    data['d_O_NUMBER_TYPE_4'] = this.d_O_NUMBER_TYPE_4
    data['d_O_PHONE_NUMBER_4'] = this.d_O_PHONE_NUMBER_4
    data['d_O_DATE_4'] = this.d_O_DATE_4
    data['d_O_NUMBER_TYPE_5'] = this.d_O_NUMBER_TYPE_5
    data['d_O_PHONE_NUMBER_5'] = this.d_O_PHONE_NUMBER_5
    data['d_O_DATE_5'] = this.d_O_DATE_5
    data['d_O_NUMBER_TYPE_6'] = this.d_O_NUMBER_TYPE_6
    data['d_O_PHONE_NUMBER_6'] = this.d_O_PHONE_NUMBER_6
    data['d_O_DATE_6'] = this.d_O_DATE_6
    data['d_O_NUMBER_TYPE_7'] = this.d_O_NUMBER_TYPE_7
    data['d_O_PHONE_NUMBER_7'] = this.d_O_PHONE_NUMBER_7
    data['d_O_DATE_7'] = this.d_O_DATE_7
    data['d_O_NUMBER_TYPE_8'] = this.d_O_NUMBER_TYPE_8
    data['d_O_PHONE_NUMBER_8'] = this.d_O_PHONE_NUMBER_8
    data['d_O_DATE_8'] = this.d_O_DATE_8
    data['d_O_NUMBER_TYPE_9'] = this.d_O_NUMBER_TYPE_9
    data['d_O_PHONE_NUMBER_9'] = this.d_O_PHONE_NUMBER_9
    data['d_O_DATE_9'] = this.d_O_DATE_9
    data['d_O_NUMBER_TYPE_10'] = this.d_O_NUMBER_TYPE_10
    data['d_O_PHONE_NUMBER_10'] = this.d_O_PHONE_NUMBER_10
    data['d_O_DATE_10'] = this.d_O_DATE_10
    data['d_O_NUMBER_TYPE_11'] = this.d_O_NUMBER_TYPE_11
    data['d_O_PHONE_NUMBER_11'] = this.d_O_PHONE_NUMBER_11
    data['d_O_DATE_11'] = this.d_O_DATE_11
    data['d_O_NUMBER_TYPE_12'] = this.d_O_NUMBER_TYPE_12
    data['d_O_PHONE_NUMBER_12'] = this.d_O_PHONE_NUMBER_12
    data['d_O_DATE_12'] = this.d_O_DATE_12
    data['d_O_NUMBER_TYPE_13'] = this.d_O_NUMBER_TYPE_13
    data['d_O_PHONE_NUMBER_13'] = this.d_O_PHONE_NUMBER_13
    data['d_O_DATE_13'] = this.d_O_DATE_13
    data['d_O_NUMBER_TYPE_14'] = this.d_O_NUMBER_TYPE_14
    data['d_O_PHONE_NUMBER_14'] = this.d_O_PHONE_NUMBER_14
    data['d_O_DATE_14'] = this.d_O_DATE_14
    data['d_O_NUMBER_TYPE_15'] = this.d_O_NUMBER_TYPE_15
    data['d_O_PHONE_NUMBER_15'] = this.d_O_PHONE_NUMBER_15
    data['d_O_DATE_15'] = this.d_O_DATE_15
    data['x_EMAIL'] = this.x_EMAIL
    data['x_EMPLOYMENT_1'] = this.x_EMPLOYMENT_1
    data['x_EMPLOYMENT_1_DATE'] = this.x_EMPLOYMENT_1_DATE
    data['x_EMPLOYMENT_2'] = this.x_EMPLOYMENT_2
    data['x_EMPLOYMENT_2_DATE'] = this.x_EMPLOYMENT_2_DATE
    data['x_EMPLOYMENT_3'] = this.x_EMPLOYMENT_3
    data['x_EMPLOYMENT_3_DATE'] = this.x_EMPLOYMENT_3_DATE
    data['x_EMPLOYMENT_4'] = this.x_EMPLOYMENT_4
    data['x_EMPLOYMENT_4_DATE'] = this.x_EMPLOYMENT_4_DATE
    data['x_EMPLOYMENT_5'] = this.x_EMPLOYMENT_5
    data['x_EMPLOYMENT_5_DATE'] = this.x_EMPLOYMENT_5_DATE
    return data
  }
}

export interface IBatchTracingConsumer {
  idnumber?: string
  dob?: string
  title?: string
  initials?: string
  name?: string
  suR_NAME?: string
  firsT_NAME?: string
  otheR_NAMES?: string
  spousE_NAME?: string
  profilE_GENDER?: string
  profilE_AGE_GROUP?: string
  profilE_MARITAL_STATUS?: string
  lsm?: string
  contacT_SCORE?: string
  income?: string
  profilE_HOMEOWNERSHIP?: string
  profilE_DIRECTORSHIP?: string
  profilE_CONTACT_ABILITY?: string
  risK_SCORE?: string
  judgE_INDICATOR?: string
  deceaseD_IND?: string
  x_DATEOFDEATH?: string
  occupation?: string
  employmenT_DATE?: string
  homE_ADDRESS_LINE_1?: string
  homE_ADDRESS_LINE_2?: string
  homE_ADDRESS_TOWNSHIP?: string
  homE_ADDRESS_REGION?: string
  homE_ADDRESS_PROVINCE?: string
  homE_ADDRESS_POSTAL_CODE?: string
  homE_ADDRESS_DATE?: string
  postaL_ADDRESS_LINE_1?: string
  postaL_ADDRESS_LINE_2?: string
  postaL_ADDRESS_TOWNSHIP?: string
  postaL_ADDRESS_REGION?: string
  postaL_ADDRESS_PROVINCE?: string
  postaL_ADDRESS_POSTAL_CODE?: string
  postaL_ADDRESS_DATE?: string
  homE_1_PHONE_NUMBER?: string
  homE_1_DATE?: string
  worK_1_PHONE_NUMBER?: string
  worK_1_DATE?: string
  celL_1_PHONE_NUMBER?: string
  celL_1_DATE?: string
  homE_2_PHONE_NUMBER?: string
  homE_2_DATE?: string
  worK_2_PHONE_NUMBER?: string
  worK_2_DATE?: string
  celL_2_PHONE_NUMBER?: string
  celL_2_DATE?: string
  homE_3_PHONE_NUMBER?: string
  homE_3_DATE?: string
  worK_3_PHONE_NUMBER?: string
  worK_3_DATE?: string
  celL_3_PHONE_NUMBER?: string
  celL_3_DATE?: string
  homE_4_PHONE_NUMBER?: string
  homE_4_DATE?: string
  worK_4_PHONE_NUMBER?: string
  worK_4_DATE?: string
  celL_4_PHONE_NUMBER?: string
  celL_4_DATE?: string
  homE_5_PHONE_NUMBER?: string
  homE_5_DATE?: string
  worK_5_PHONE_NUMBER?: string
  worK_5_DATE?: string
  celL_5_PHONE_NUMBER?: string
  celL_5_DATE?: string
  d_O_NUMBER_TYPE_1?: string
  d_O_PHONE_NUMBER_1?: string
  d_O_DATE_1?: string
  d_O_NUMBER_TYPE_2?: string
  d_O_PHONE_NUMBER_2?: string
  d_O_DATE_2?: string
  d_O_NUMBER_TYPE_3?: string
  d_O_PHONE_NUMBER_3?: string
  d_O_DATE_3?: string
  d_O_NUMBER_TYPE_4?: string
  d_O_PHONE_NUMBER_4?: string
  d_O_DATE_4?: string
  d_O_NUMBER_TYPE_5?: string
  d_O_PHONE_NUMBER_5?: string
  d_O_DATE_5?: string
  d_O_NUMBER_TYPE_6?: string
  d_O_PHONE_NUMBER_6?: string
  d_O_DATE_6?: string
  d_O_NUMBER_TYPE_7?: string
  d_O_PHONE_NUMBER_7?: string
  d_O_DATE_7?: string
  d_O_NUMBER_TYPE_8?: string
  d_O_PHONE_NUMBER_8?: string
  d_O_DATE_8?: string
  d_O_NUMBER_TYPE_9?: string
  d_O_PHONE_NUMBER_9?: string
  d_O_DATE_9?: string
  d_O_NUMBER_TYPE_10?: string
  d_O_PHONE_NUMBER_10?: string
  d_O_DATE_10?: string
  d_O_NUMBER_TYPE_11?: string
  d_O_PHONE_NUMBER_11?: string
  d_O_DATE_11?: string
  d_O_NUMBER_TYPE_12?: string
  d_O_PHONE_NUMBER_12?: string
  d_O_DATE_12?: string
  d_O_NUMBER_TYPE_13?: string
  d_O_PHONE_NUMBER_13?: string
  d_O_DATE_13?: string
  d_O_NUMBER_TYPE_14?: string
  d_O_PHONE_NUMBER_14?: string
  d_O_DATE_14?: string
  d_O_NUMBER_TYPE_15?: string
  d_O_PHONE_NUMBER_15?: string
  d_O_DATE_15?: string
  x_EMAIL?: string
  x_EMPLOYMENT_1?: string
  x_EMPLOYMENT_1_DATE?: string
  x_EMPLOYMENT_2?: string
  x_EMPLOYMENT_2_DATE?: string
  x_EMPLOYMENT_3?: string
  x_EMPLOYMENT_3_DATE?: string
  x_EMPLOYMENT_4?: string
  x_EMPLOYMENT_4_DATE?: string
  x_EMPLOYMENT_5?: string
  x_EMPLOYMENT_5_DATE?: string
}

export class ExcelModelResponse implements IExcelModelResponse {
  idNumber?: string
  passportNo?: string
  columnNames?: string[]

  constructor(data?: IExcelModelResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.idNumber = data['idNumber']
      this.passportNo = data['passportNo']
      if (data['columnNames'] && data['columnNames'].constructor === Array) {
        this.columnNames = []
        for (let item of data['columnNames']) this.columnNames.push(item)
      }
    }
  }

  static fromJS(data: any): ExcelModelResponse {
    data = typeof data === 'object' ? data : {}
    let result = new ExcelModelResponse()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['idNumber'] = this.idNumber
    data['passportNo'] = this.passportNo
    if (this.columnNames && this.columnNames.constructor === Array) {
      data['columnNames'] = []
      for (let item of this.columnNames) data['columnNames'].push(item)
    }
    return data
  }
}

export interface IExcelModelResponse {
  idNumber?: string
  passportNo?: string
  columnNames?: string[]
}

export class BatchTracingServiceRequest implements IBatchTracingServiceRequest {
  customerId: string
  customerUserId: string
  fromdate?: string
  todate?: string
  dtRequest?: DataTableRequest

  constructor(data?: IBatchTracingServiceRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.customerId = data['customerId']
      this.customerUserId = data['customerUserId']
      this.fromdate = data['fromdate']
      this.todate = data['todate']
      this.dtRequest = data['dtRequest']
        ? DataTableRequest.fromJS(data['dtRequest'])
        : <any>undefined
    }
  }

  static fromJS(data: any): BatchTracingServiceRequest {
    data = typeof data === 'object' ? data : {}
    let result = new BatchTracingServiceRequest()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['customerId'] = this.customerId
    data['customerUserId'] = this.customerUserId
    data['fromdate'] = this.fromdate
    data['todate'] = this.todate
    data['dtRequest'] = this.dtRequest
      ? this.dtRequest.toJSON()
      : <any>undefined
    return data
  }
}

export interface IBatchTracingServiceRequest {
  customerId: string
  customerUserId: string
  fromdate?: string
  todate?: string
  dtRequest?: DataTableRequest
}

export class DataTableRequest implements IDataTableRequest {
  draw: number
  start: number
  length: number
  search?: Search
  order?: OrderColumn[]
  columns?: Column[]

  constructor(data?: IDataTableRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.draw = data['draw']
      this.start = data['start']
      this.length = data['length']
      this.search = data['search']
        ? Search.fromJS(data['search'])
        : <any>undefined
      if (data['order'] && data['order'].constructor === Array) {
        this.order = []
        for (let item of data['order'])
          this.order.push(OrderColumn.fromJS(item))
      }
      if (data['columns'] && data['columns'].constructor === Array) {
        this.columns = []
        for (let item of data['columns']) this.columns.push(Column.fromJS(item))
      }
    }
  }

  static fromJS(data: any): DataTableRequest {
    data = typeof data === 'object' ? data : {}
    let result = new DataTableRequest()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['draw'] = this.draw
    data['start'] = this.start
    data['length'] = this.length
    data['search'] = this.search ? this.search.toJSON() : <any>undefined
    if (this.order && this.order.constructor === Array) {
      data['order'] = []
      for (let item of this.order) data['order'].push(item.toJSON())
    }
    if (this.columns && this.columns.constructor === Array) {
      data['columns'] = []
      for (let item of this.columns) data['columns'].push(item.toJSON())
    }
    return data
  }
}

export interface IDataTableRequest {
  draw: number
  start: number
  length: number
  search?: Search
  order?: OrderColumn[]
  columns?: Column[]
}

export class Search implements ISearch {
  value?: string
  regex?: string

  constructor(data?: ISearch) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.value = data['value']
      this.regex = data['regex']
    }
  }

  static fromJS(data: any): Search {
    data = typeof data === 'object' ? data : {}
    let result = new Search()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['value'] = this.value
    data['regex'] = this.regex
    return data
  }
}

export interface ISearch {
  value?: string
  regex?: string
}

export class OrderColumn implements IOrderColumn {
  column?: string
  dir?: string

  constructor(data?: IOrderColumn) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.column = data['column']
      this.dir = data['dir']
    }
  }

  static fromJS(data: any): OrderColumn {
    data = typeof data === 'object' ? data : {}
    let result = new OrderColumn()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['column'] = this.column
    data['dir'] = this.dir
    return data
  }
}

export interface IOrderColumn {
  column?: string
  dir?: string
}

export class Column implements IColumn {
  data?: string
  name?: string
  searchable: boolean
  orderable?: string
  search?: Search

  constructor(data?: IColumn) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.data = data['data']
      this.name = data['name']
      this.searchable = data['searchable']
      this.orderable = data['orderable']
      this.search = data['search']
        ? Search.fromJS(data['search'])
        : <any>undefined
    }
  }

  static fromJS(data: any): Column {
    data = typeof data === 'object' ? data : {}
    let result = new Column()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['data'] = this.data
    data['name'] = this.name
    data['searchable'] = this.searchable
    data['orderable'] = this.orderable
    data['search'] = this.search ? this.search.toJSON() : <any>undefined
    return data
  }
}

export interface IColumn {
  data?: string
  name?: string
  searchable: boolean
  orderable?: string
  search?: Search
}

export class DataTableResponseOfBatchTraceServices
  implements IDataTableResponseOfBatchTraceServices {
  draw: number
  recordsFiltered: number
  recordsTotal: number
  totalTime: number
  data?: BatchTraceServices[]

  constructor(data?: IDataTableResponseOfBatchTraceServices) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.draw = data['draw']
      this.recordsFiltered = data['recordsFiltered']
      this.recordsTotal = data['recordsTotal']
      this.totalTime = data['totalTime']
      if (data['data'] && data['data'].constructor === Array) {
        this.data = []
        for (let item of data['data'])
          this.data.push(BatchTraceServices.fromJS(item))
      }
    }
  }

  static fromJS(data: any): DataTableResponseOfBatchTraceServices {
    data = typeof data === 'object' ? data : {}
    let result = new DataTableResponseOfBatchTraceServices()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['draw'] = this.draw
    data['recordsFiltered'] = this.recordsFiltered
    data['recordsTotal'] = this.recordsTotal
    data['totalTime'] = this.totalTime
    if (this.data && this.data.constructor === Array) {
      data['data'] = []
      for (let item of this.data) data['data'].push(item.toJSON())
    }
    return data
  }
}

export interface IDataTableResponseOfBatchTraceServices {
  draw: number
  recordsFiltered: number
  recordsTotal: number
  totalTime: number
  data?: BatchTraceServices[]
}

export class BatchTraceServiceResponse
  extends DataTableResponseOfBatchTraceServices
  implements IBatchTraceServiceResponse {
  constructor(data?: IBatchTraceServiceResponse) {
    super(data)
  }

  init(data?: any) {
    super.init(data)
    if (data) {
    }
  }

  static fromJS(data: any): BatchTraceServiceResponse {
    data = typeof data === 'object' ? data : {}
    let result = new BatchTraceServiceResponse()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    super.toJSON(data)
    return data
  }
}

export interface IBatchTraceServiceResponse
  extends IDataTableResponseOfBatchTraceServices {}

export class InvoiceGenResponse implements IInvoiceGenResponse {
  message?: string
  isSuccess: boolean

  constructor(data?: IInvoiceGenResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.message = data['message']
      this.isSuccess = data['isSuccess']
    }
  }

  static fromJS(data: any): InvoiceGenResponse {
    data = typeof data === 'object' ? data : {}
    let result = new InvoiceGenResponse()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['message'] = this.message
    data['isSuccess'] = this.isSuccess
    return data
  }
}

export interface IInvoiceGenResponse {
  message?: string
  isSuccess: boolean
}

export class FullAuditSearchRequest implements IFullAuditSearchRequest {
  customerId: string
  customerUserId: string
  fromdate?: string
  todate?: string
  dtRequest?: DataTableRequest

  constructor(data?: IFullAuditSearchRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.customerId = data['customerId']
      this.customerUserId = data['customerUserId']
      this.fromdate = data['fromdate']
      this.todate = data['todate']
      this.dtRequest = data['dtRequest']
        ? DataTableRequest.fromJS(data['dtRequest'])
        : <any>undefined
    }
  }

  static fromJS(data: any): FullAuditSearchRequest {
    data = typeof data === 'object' ? data : {}
    let result = new FullAuditSearchRequest()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['customerId'] = this.customerId
    data['customerUserId'] = this.customerUserId
    data['fromdate'] = this.fromdate
    data['todate'] = this.todate
    data['dtRequest'] = this.dtRequest
      ? this.dtRequest.toJSON()
      : <any>undefined
    return data
  }
}

export interface IFullAuditSearchRequest {
  customerId: string
  customerUserId: string
  fromdate?: string
  todate?: string
  dtRequest?: DataTableRequest
}

export class DataTableResponseOfCustomerLogvms
  implements IDataTableResponseOfCustomerLogvms {
  draw: number
  recordsFiltered: number
  recordsTotal: number
  totalTime: number
  data?: CustomerLogvms[]

  constructor(data?: IDataTableResponseOfCustomerLogvms) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.draw = data['draw']
      this.recordsFiltered = data['recordsFiltered']
      this.recordsTotal = data['recordsTotal']
      this.totalTime = data['totalTime']
      if (data['data'] && data['data'].constructor === Array) {
        this.data = []
        for (let item of data['data'])
          this.data.push(CustomerLogvms.fromJS(item))
      }
    }
  }

  static fromJS(data: any): DataTableResponseOfCustomerLogvms {
    data = typeof data === 'object' ? data : {}
    let result = new DataTableResponseOfCustomerLogvms()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['draw'] = this.draw
    data['recordsFiltered'] = this.recordsFiltered
    data['recordsTotal'] = this.recordsTotal
    data['totalTime'] = this.totalTime
    if (this.data && this.data.constructor === Array) {
      data['data'] = []
      for (let item of this.data) data['data'].push(item.toJSON())
    }
    return data
  }
}

export interface IDataTableResponseOfCustomerLogvms {
  draw: number
  recordsFiltered: number
  recordsTotal: number
  totalTime: number
  data?: CustomerLogvms[]
}

export class FullAuditDataResponse extends DataTableResponseOfCustomerLogvms
  implements IFullAuditDataResponse {
  constructor(data?: IFullAuditDataResponse) {
    super(data)
  }

  init(data?: any) {
    super.init(data)
    if (data) {
    }
  }

  static fromJS(data: any): FullAuditDataResponse {
    data = typeof data === 'object' ? data : {}
    let result = new FullAuditDataResponse()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    super.toJSON(data)
    return data
  }
}

export interface IFullAuditDataResponse
  extends IDataTableResponseOfCustomerLogvms {}

export class CustomerLogvms implements ICustomerLogvms {
  id: string
  dateTime?: string
  creditPoints: number
  fromdate: Date
  todate: Date
  logType?: string
  searchCriteria?: string
  searchType?: string
  name?: string
  customerUserId: string
  userEmail?: string

  constructor(data?: ICustomerLogvms) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.id = data['id']
      this.dateTime = data['dateTime']
      this.creditPoints = data['creditPoints']
      this.fromdate = data['fromdate']
        ? new Date(data['fromdate'].toString())
        : <any>undefined
      this.todate = data['todate']
        ? new Date(data['todate'].toString())
        : <any>undefined
      this.logType = data['logType']
      this.searchCriteria = data['searchCriteria']
      this.searchType = data['searchType']
      this.name = data['name']
      this.customerUserId = data['customerUserId']
      this.userEmail = data['userEmail']
    }
  }

  static fromJS(data: any): CustomerLogvms {
    data = typeof data === 'object' ? data : {}
    let result = new CustomerLogvms()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['id'] = this.id
    data['dateTime'] = this.dateTime
    data['creditPoints'] = this.creditPoints
    data['fromdate'] = this.fromdate
      ? this.fromdate.toISOString()
      : <any>undefined
    data['todate'] = this.todate ? this.todate.toISOString() : <any>undefined
    data['logType'] = this.logType
    data['searchCriteria'] = this.searchCriteria
    data['searchType'] = this.searchType
    data['name'] = this.name
    data['customerUserId'] = this.customerUserId
    data['userEmail'] = this.userEmail
    return data
  }
}

export interface ICustomerLogvms {
  id: string
  dateTime?: string
  creditPoints: number
  fromdate: Date
  todate: Date
  logType?: string
  searchCriteria?: string
  searchType?: string
  name?: string
  customerUserId: string
  userEmail?: string
}

export class CustomerLog implements ICustomerLog {
  id: string
  dateTime: Date
  companyId: string
  customerUser?: CustomerUser
  companyUserId: string
  creditPoints: number
  idOrPassportNumber?: string
  searchType?: string
  searchCriteria?: string
  logType?: string
  workorder?: Workorder
  workorderId?: string
  inputType?: string

  constructor(data?: ICustomerLog) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.id = data['id']
      this.dateTime = data['dateTime']
        ? new Date(data['dateTime'].toString())
        : <any>undefined
      this.companyId = data['companyId']
      this.customerUser = data['customerUser']
        ? CustomerUser.fromJS(data['customerUser'])
        : <any>undefined
      this.companyUserId = data['companyUserId']
      this.creditPoints = data['creditPoints']
      this.idOrPassportNumber = data['idOrPassportNumber']
      this.searchType = data['searchType']
      this.searchCriteria = data['searchCriteria']
      this.logType = data['logType']
      this.workorder = data['workorder']
        ? Workorder.fromJS(data['workorder'])
        : <any>undefined
      this.workorderId = data['workorderId']
      this.inputType = data['inputType']
    }
  }

  static fromJS(data: any): CustomerLog {
    data = typeof data === 'object' ? data : {}
    let result = new CustomerLog()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['id'] = this.id
    data['dateTime'] = this.dateTime
      ? this.dateTime.toISOString()
      : <any>undefined
    data['companyId'] = this.companyId
    data['customerUser'] = this.customerUser
      ? this.customerUser.toJSON()
      : <any>undefined
    data['companyUserId'] = this.companyUserId
    data['creditPoints'] = this.creditPoints
    data['idOrPassportNumber'] = this.idOrPassportNumber
    data['searchType'] = this.searchType
    data['searchCriteria'] = this.searchCriteria
    data['logType'] = this.logType
    data['workorder'] = this.workorder
      ? this.workorder.toJSON()
      : <any>undefined
    data['workorderId'] = this.workorderId
    data['inputType'] = this.inputType
    return data
  }
}

export interface ICustomerLog {
  id: string
  dateTime: Date
  companyId: string
  customerUser?: CustomerUser
  companyUserId: string
  creditPoints: number
  idOrPassportNumber?: string
  searchType?: string
  searchCriteria?: string
  logType?: string
  workorder?: Workorder
  workorderId?: string
  inputType?: string
}

export class Workorder implements IWorkorder {
  id: string
  startDate: Date
  endDate: Date
  subscriptionItem?: SubscriptionItem
  subscriptionItemID?: string
  productPackage?: ProductPackageRate
  productPackageId: string
  customer?: Customer
  customerId: string
  status?: string
  serviceType?: string
  credits: number
  isCancelled: boolean
  invoiceLineItemId?: string

  constructor(data?: IWorkorder) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.id = data['id']
      this.startDate = data['startDate']
        ? new Date(data['startDate'].toString())
        : <any>undefined
      this.endDate = data['endDate']
        ? new Date(data['endDate'].toString())
        : <any>undefined
      this.subscriptionItem = data['subscriptionItem']
        ? SubscriptionItem.fromJS(data['subscriptionItem'])
        : <any>undefined
      this.subscriptionItemID = data['subscriptionItemID']
      this.productPackage = data['productPackage']
        ? ProductPackageRate.fromJS(data['productPackage'])
        : <any>undefined
      this.productPackageId = data['productPackageId']
      this.customer = data['customer']
        ? Customer.fromJS(data['customer'])
        : <any>undefined
      this.customerId = data['customerId']
      this.status = data['status']
      this.serviceType = data['serviceType']
      this.credits = data['credits']
      this.isCancelled = data['isCancelled']
      this.invoiceLineItemId = data['invoiceLineItemId']
    }
  }

  static fromJS(data: any): Workorder {
    data = typeof data === 'object' ? data : {}
    let result = new Workorder()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['id'] = this.id
    data['startDate'] = this.startDate
      ? this.startDate.toISOString()
      : <any>undefined
    data['endDate'] = this.endDate ? this.endDate.toISOString() : <any>undefined
    data['subscriptionItem'] = this.subscriptionItem
      ? this.subscriptionItem.toJSON()
      : <any>undefined
    data['subscriptionItemID'] = this.subscriptionItemID
    data['productPackage'] = this.productPackage
      ? this.productPackage.toJSON()
      : <any>undefined
    data['productPackageId'] = this.productPackageId
    data['customer'] = this.customer ? this.customer.toJSON() : <any>undefined
    data['customerId'] = this.customerId
    data['status'] = this.status
    data['serviceType'] = this.serviceType
    data['credits'] = this.credits
    data['isCancelled'] = this.isCancelled
    data['invoiceLineItemId'] = this.invoiceLineItemId
    return data
  }
}

export interface IWorkorder {
  id: string
  startDate: Date
  endDate: Date
  subscriptionItem?: SubscriptionItem
  subscriptionItemID?: string
  productPackage?: ProductPackageRate
  productPackageId: string
  customer?: Customer
  customerId: string
  status?: string
  serviceType?: string
  credits: number
  isCancelled: boolean
  invoiceLineItemId?: string
}

export class InvDataTableRequest implements IInvDataTableRequest {
  customerId: string
  invoiceId: string
  dtRequest?: DataTableRequest

  constructor(data?: IInvDataTableRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.customerId = data['customerId']
      this.invoiceId = data['invoiceId']
      this.dtRequest = data['dtRequest']
        ? DataTableRequest.fromJS(data['dtRequest'])
        : <any>undefined
    }
  }

  static fromJS(data: any): InvDataTableRequest {
    data = typeof data === 'object' ? data : {}
    let result = new InvDataTableRequest()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['customerId'] = this.customerId
    data['invoiceId'] = this.invoiceId
    data['dtRequest'] = this.dtRequest
      ? this.dtRequest.toJSON()
      : <any>undefined
    return data
  }
}

export interface IInvDataTableRequest {
  customerId: string
  invoiceId: string
  dtRequest?: DataTableRequest
}

export class DataTableResponseOfInvoiceVm
  implements IDataTableResponseOfInvoiceVm {
  draw: number
  recordsFiltered: number
  recordsTotal: number
  totalTime: number
  data?: InvoiceVm[]

  constructor(data?: IDataTableResponseOfInvoiceVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.draw = data['draw']
      this.recordsFiltered = data['recordsFiltered']
      this.recordsTotal = data['recordsTotal']
      this.totalTime = data['totalTime']
      if (data['data'] && data['data'].constructor === Array) {
        this.data = []
        for (let item of data['data']) this.data.push(InvoiceVm.fromJS(item))
      }
    }
  }

  static fromJS(data: any): DataTableResponseOfInvoiceVm {
    data = typeof data === 'object' ? data : {}
    let result = new DataTableResponseOfInvoiceVm()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['draw'] = this.draw
    data['recordsFiltered'] = this.recordsFiltered
    data['recordsTotal'] = this.recordsTotal
    data['totalTime'] = this.totalTime
    if (this.data && this.data.constructor === Array) {
      data['data'] = []
      for (let item of this.data) data['data'].push(item.toJSON())
    }
    return data
  }
}

export interface IDataTableResponseOfInvoiceVm {
  draw: number
  recordsFiltered: number
  recordsTotal: number
  totalTime: number
  data?: InvoiceVm[]
}

export class InvoiceDataResponse extends DataTableResponseOfInvoiceVm
  implements IInvoiceDataResponse {
  constructor(data?: IInvoiceDataResponse) {
    super(data)
  }

  init(data?: any) {
    super.init(data)
    if (data) {
    }
  }

  static fromJS(data: any): InvoiceDataResponse {
    data = typeof data === 'object' ? data : {}
    let result = new InvoiceDataResponse()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    super.toJSON(data)
    return data
  }
}

export interface IInvoiceDataResponse extends IDataTableResponseOfInvoiceVm {}

export class InvoiceVm implements IInvoiceVm {
  name?: string
  id: string
  invoiceNumber: number
  proFormaInvoice: boolean
  date: Date
  referenceNumber: number
  subTotal: number
  discount: number
  vatTotal: number
  total: number
  billingType?: string
  emailDate: Date
  paymentReceivedDate: Date
  invoiceDate: Date
  isProformaInvoice: boolean
  isCancelled: boolean
  invoiceLineItems?: InvoiceLineItem[]
  customer?: Customer
  customerId: string
  subscription?: Subscription
  subscriptionID?: string
  isPayed?: string
  displayNumber?: string

  constructor(data?: IInvoiceVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.name = data['name']
      this.id = data['id']
      this.invoiceNumber = data['invoiceNumber']
      this.proFormaInvoice = data['proFormaInvoice']
      this.date = data['date']
        ? new Date(data['date'].toString())
        : <any>undefined
      this.referenceNumber = data['referenceNumber']
      this.subTotal = data['subTotal']
      this.discount = data['discount']
      this.vatTotal = data['vatTotal']
      this.total = data['total']
      this.billingType = data['billingType']
      this.emailDate = data['emailDate']
        ? new Date(data['emailDate'].toString())
        : <any>undefined
      this.paymentReceivedDate = data['paymentReceivedDate']
        ? new Date(data['paymentReceivedDate'].toString())
        : <any>undefined
      this.invoiceDate = data['invoiceDate']
        ? new Date(data['invoiceDate'].toString())
        : <any>undefined
      this.isProformaInvoice = data['isProformaInvoice']
      this.isCancelled = data['isCancelled']
      if (
        data['invoiceLineItems'] &&
        data['invoiceLineItems'].constructor === Array
      ) {
        this.invoiceLineItems = []
        for (let item of data['invoiceLineItems'])
          this.invoiceLineItems.push(InvoiceLineItem.fromJS(item))
      }
      this.customer = data['customer']
        ? Customer.fromJS(data['customer'])
        : <any>undefined
      this.customerId = data['customerId']
      this.subscription = data['subscription']
        ? Subscription.fromJS(data['subscription'])
        : <any>undefined
      this.subscriptionID = data['subscriptionID']
      this.isPayed = data['isPayed']
      this.displayNumber = data['displayNumber']
    }
  }

  static fromJS(data: any): InvoiceVm {
    data = typeof data === 'object' ? data : {}
    let result = new InvoiceVm()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['name'] = this.name
    data['id'] = this.id
    data['invoiceNumber'] = this.invoiceNumber
    data['proFormaInvoice'] = this.proFormaInvoice
    data['date'] = this.date ? this.date.toISOString() : <any>undefined
    data['referenceNumber'] = this.referenceNumber
    data['subTotal'] = this.subTotal
    data['discount'] = this.discount
    data['vatTotal'] = this.vatTotal
    data['total'] = this.total
    data['billingType'] = this.billingType
    data['emailDate'] = this.emailDate
      ? this.emailDate.toISOString()
      : <any>undefined
    data['paymentReceivedDate'] = this.paymentReceivedDate
      ? this.paymentReceivedDate.toISOString()
      : <any>undefined
    data['invoiceDate'] = this.invoiceDate
      ? this.invoiceDate.toISOString()
      : <any>undefined
    data['isProformaInvoice'] = this.isProformaInvoice
    data['isCancelled'] = this.isCancelled
    if (this.invoiceLineItems && this.invoiceLineItems.constructor === Array) {
      data['invoiceLineItems'] = []
      for (let item of this.invoiceLineItems)
        data['invoiceLineItems'].push(item.toJSON())
    }
    data['customer'] = this.customer ? this.customer.toJSON() : <any>undefined
    data['customerId'] = this.customerId
    data['subscription'] = this.subscription
      ? this.subscription.toJSON()
      : <any>undefined
    data['subscriptionID'] = this.subscriptionID
    data['isPayed'] = this.isPayed
    data['displayNumber'] = this.displayNumber
    return data
  }
}

export interface IInvoiceVm {
  name?: string
  id: string
  invoiceNumber: number
  proFormaInvoice: boolean
  date: Date
  referenceNumber: number
  subTotal: number
  discount: number
  vatTotal: number
  total: number
  billingType?: string
  emailDate: Date
  paymentReceivedDate: Date
  invoiceDate: Date
  isProformaInvoice: boolean
  isCancelled: boolean
  invoiceLineItems?: InvoiceLineItem[]
  customer?: Customer
  customerId: string
  subscription?: Subscription
  subscriptionID?: string
  isPayed?: string
  displayNumber?: string
}

export class InvoiceLineItem implements IInvoiceLineItem {
  id: string
  invoiceID: string
  productPackageRate?: ProductPackageRate
  productPackageRateID?: string
  description?: string
  quantity: number
  unitPrice: number
  netAmount: number
  vatAmount: number
  billingType?: string
  usageType?: string
  subscription?: Subscription
  subscriptionID?: string

  constructor(data?: IInvoiceLineItem) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.id = data['id']
      this.invoiceID = data['invoiceID']
      this.productPackageRate = data['productPackageRate']
        ? ProductPackageRate.fromJS(data['productPackageRate'])
        : <any>undefined
      this.productPackageRateID = data['productPackageRateID']
      this.description = data['description']
      this.quantity = data['quantity']
      this.unitPrice = data['unitPrice']
      this.netAmount = data['netAmount']
      this.vatAmount = data['vatAmount']
      this.billingType = data['billingType']
      this.usageType = data['usageType']
      this.subscription = data['subscription']
        ? Subscription.fromJS(data['subscription'])
        : <any>undefined
      this.subscriptionID = data['subscriptionID']
    }
  }

  static fromJS(data: any): InvoiceLineItem {
    data = typeof data === 'object' ? data : {}
    let result = new InvoiceLineItem()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['id'] = this.id
    data['invoiceID'] = this.invoiceID
    data['productPackageRate'] = this.productPackageRate
      ? this.productPackageRate.toJSON()
      : <any>undefined
    data['productPackageRateID'] = this.productPackageRateID
    data['description'] = this.description
    data['quantity'] = this.quantity
    data['unitPrice'] = this.unitPrice
    data['netAmount'] = this.netAmount
    data['vatAmount'] = this.vatAmount
    data['billingType'] = this.billingType
    data['usageType'] = this.usageType
    data['subscription'] = this.subscription
      ? this.subscription.toJSON()
      : <any>undefined
    data['subscriptionID'] = this.subscriptionID
    return data
  }
}

export interface IInvoiceLineItem {
  id: string
  invoiceID: string
  productPackageRate?: ProductPackageRate
  productPackageRateID?: string
  description?: string
  quantity: number
  unitPrice: number
  netAmount: number
  vatAmount: number
  billingType?: string
  usageType?: string
  subscription?: Subscription
  subscriptionID?: string
}

export class Invoice implements IInvoice {
  id: string
  invoiceNumber: number
  proFormaInvoice: boolean
  date: Date
  referenceNumber: number
  subTotal: number
  discount: number
  vatTotal: number
  total: number
  billingType?: string
  remarks?: string
  invoiceLineItems?: InvoiceLineItem[]
  customer?: Customer
  customerId: string
  subscription?: Subscription
  subscriptionID?: string
  ispaid: boolean
  isCreditNoteRaised: boolean
  isSubmited: boolean
  isCancelled: boolean
  isEmailSend: boolean
  emailSendDate: Date
  invoiceDate: Date
  invoiceDisplayNumber?: string
  isTaxinvSent: boolean

  constructor(data?: IInvoice) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.id = data['id']
      this.invoiceNumber = data['invoiceNumber']
      this.proFormaInvoice = data['proFormaInvoice']
      this.date = data['date']
        ? new Date(data['date'].toString())
        : <any>undefined
      this.referenceNumber = data['referenceNumber']
      this.subTotal = data['subTotal']
      this.discount = data['discount']
      this.vatTotal = data['vatTotal']
      this.total = data['total']
      this.billingType = data['billingType']
      this.remarks = data['remarks']
      if (
        data['invoiceLineItems'] &&
        data['invoiceLineItems'].constructor === Array
      ) {
        this.invoiceLineItems = []
        for (let item of data['invoiceLineItems'])
          this.invoiceLineItems.push(InvoiceLineItem.fromJS(item))
      }
      this.customer = data['customer']
        ? Customer.fromJS(data['customer'])
        : <any>undefined
      this.customerId = data['customerId']
      this.subscription = data['subscription']
        ? Subscription.fromJS(data['subscription'])
        : <any>undefined
      this.subscriptionID = data['subscriptionID']
      this.ispaid = data['ispaid']
      this.isCreditNoteRaised = data['isCreditNoteRaised']
      this.isSubmited = data['isSubmited']
      this.isCancelled = data['isCancelled']
      this.isEmailSend = data['isEmailSend']
      this.emailSendDate = data['emailSendDate']
        ? new Date(data['emailSendDate'].toString())
        : <any>undefined
      this.invoiceDate = data['invoiceDate']
        ? new Date(data['invoiceDate'].toString())
        : <any>undefined
      this.invoiceDisplayNumber = data['invoiceDisplayNumber']
      this.isTaxinvSent = data['isTaxinvSent']
    }
  }

  static fromJS(data: any): Invoice {
    data = typeof data === 'object' ? data : {}
    let result = new Invoice()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['id'] = this.id
    data['invoiceNumber'] = this.invoiceNumber
    data['proFormaInvoice'] = this.proFormaInvoice
    data['date'] = this.date ? this.date.toISOString() : <any>undefined
    data['referenceNumber'] = this.referenceNumber
    data['subTotal'] = this.subTotal
    data['discount'] = this.discount
    data['vatTotal'] = this.vatTotal
    data['total'] = this.total
    data['billingType'] = this.billingType
    data['remarks'] = this.remarks
    if (this.invoiceLineItems && this.invoiceLineItems.constructor === Array) {
      data['invoiceLineItems'] = []
      for (let item of this.invoiceLineItems)
        data['invoiceLineItems'].push(item.toJSON())
    }
    data['customer'] = this.customer ? this.customer.toJSON() : <any>undefined
    data['customerId'] = this.customerId
    data['subscription'] = this.subscription
      ? this.subscription.toJSON()
      : <any>undefined
    data['subscriptionID'] = this.subscriptionID
    data['ispaid'] = this.ispaid
    data['isCreditNoteRaised'] = this.isCreditNoteRaised
    data['isSubmited'] = this.isSubmited
    data['isCancelled'] = this.isCancelled
    data['isEmailSend'] = this.isEmailSend
    data['emailSendDate'] = this.emailSendDate
      ? this.emailSendDate.toISOString()
      : <any>undefined
    data['invoiceDate'] = this.invoiceDate
      ? this.invoiceDate.toISOString()
      : <any>undefined
    data['invoiceDisplayNumber'] = this.invoiceDisplayNumber
    data['isTaxinvSent'] = this.isTaxinvSent
    return data
  }
}

export interface IInvoice {
  id: string
  invoiceNumber: number
  proFormaInvoice: boolean
  date: Date
  referenceNumber: number
  subTotal: number
  discount: number
  vatTotal: number
  total: number
  billingType?: string
  remarks?: string
  invoiceLineItems?: InvoiceLineItem[]
  customer?: Customer
  customerId: string
  subscription?: Subscription
  subscriptionID?: string
  ispaid: boolean
  isCreditNoteRaised: boolean
  isSubmited: boolean
  isCancelled: boolean
  isEmailSend: boolean
  emailSendDate: Date
  invoiceDate: Date
  invoiceDisplayNumber?: string
  isTaxinvSent: boolean
}

export class InvoiceCrudResponses implements IInvoiceCrudResponses {
  message?: string
  isSuccess: boolean

  constructor(data?: IInvoiceCrudResponses) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.message = data['message']
      this.isSuccess = data['isSuccess']
    }
  }

  static fromJS(data: any): InvoiceCrudResponses {
    data = typeof data === 'object' ? data : {}
    let result = new InvoiceCrudResponses()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['message'] = this.message
    data['isSuccess'] = this.isSuccess
    return data
  }
}

export interface IInvoiceCrudResponses {
  message?: string
  isSuccess: boolean
}

export class PaymentResponse implements IPaymentResponse {
  message?: string
  isSuccess: boolean

  constructor(data?: IPaymentResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.message = data['message']
      this.isSuccess = data['isSuccess']
    }
  }

  static fromJS(data: any): PaymentResponse {
    data = typeof data === 'object' ? data : {}
    let result = new PaymentResponse()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['message'] = this.message
    data['isSuccess'] = this.isSuccess
    return data
  }
}

export interface IPaymentResponse {
  message?: string
  isSuccess: boolean
}

export class ProductVm implements IProductVm {
  id: string
  name?: string
  packageRates?: ProductPackageRateVm[]
  service?: Service
  serviceId: string
  usageType?: string

  constructor(data?: IProductVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.id = data['id']
      this.name = data['name']
      if (data['packageRates'] && data['packageRates'].constructor === Array) {
        this.packageRates = []
        for (let item of data['packageRates'])
          this.packageRates.push(ProductPackageRateVm.fromJS(item))
      }
      this.service = data['service']
        ? Service.fromJS(data['service'])
        : <any>undefined
      this.serviceId = data['serviceId']
      this.usageType = data['usageType']
    }
  }

  static fromJS(data: any): ProductVm {
    data = typeof data === 'object' ? data : {}
    let result = new ProductVm()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['id'] = this.id
    data['name'] = this.name
    if (this.packageRates && this.packageRates.constructor === Array) {
      data['packageRates'] = []
      for (let item of this.packageRates)
        data['packageRates'].push(item.toJSON())
    }
    data['service'] = this.service ? this.service.toJSON() : <any>undefined
    data['serviceId'] = this.serviceId
    data['usageType'] = this.usageType
    return data
  }
}

export interface IProductVm {
  id: string
  name?: string
  packageRates?: ProductPackageRateVm[]
  service?: Service
  serviceId: string
  usageType?: string
}

export class ProductPackageRateVm implements IProductPackageRateVm {
  id: string
  productId: string
  minLimit: number
  maxLimit: number
  unitPrice: number

  constructor(data?: IProductPackageRateVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.id = data['id']
      this.productId = data['productId']
      this.minLimit = data['minLimit']
      this.maxLimit = data['maxLimit']
      this.unitPrice = data['unitPrice']
    }
  }

  static fromJS(data: any): ProductPackageRateVm {
    data = typeof data === 'object' ? data : {}
    let result = new ProductPackageRateVm()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['id'] = this.id
    data['productId'] = this.productId
    data['minLimit'] = this.minLimit
    data['maxLimit'] = this.maxLimit
    data['unitPrice'] = this.unitPrice
    return data
  }
}

export interface IProductPackageRateVm {
  id: string
  productId: string
  minLimit: number
  maxLimit: number
  unitPrice: number
}

export class SubscriptionLicenceVm implements ISubscriptionLicenceVm {
  subscriptionId?: string
  customerUserId: string
  customerName?: string
  isActive: boolean

  constructor(data?: ISubscriptionLicenceVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.subscriptionId = data['subscriptionId']
      this.customerUserId = data['customerUserId']
      this.customerName = data['customerName']
      this.isActive = data['isActive']
    }
  }

  static fromJS(data: any): SubscriptionLicenceVm {
    data = typeof data === 'object' ? data : {}
    let result = new SubscriptionLicenceVm()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['subscriptionId'] = this.subscriptionId
    data['customerUserId'] = this.customerUserId
    data['customerName'] = this.customerName
    data['isActive'] = this.isActive
    return data
  }
}

export interface ISubscriptionLicenceVm {
  subscriptionId?: string
  customerUserId: string
  customerName?: string
  isActive: boolean
}

export class SubscriptionLicenceRequest implements ISubscriptionLicenceRequest {
  subscriptionLicenceVms?: SubscriptionLicenceVm[]

  constructor(data?: ISubscriptionLicenceRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      if (
        data['subscriptionLicenceVms'] &&
        data['subscriptionLicenceVms'].constructor === Array
      ) {
        this.subscriptionLicenceVms = []
        for (let item of data['subscriptionLicenceVms'])
          this.subscriptionLicenceVms.push(SubscriptionLicenceVm.fromJS(item))
      }
    }
  }

  static fromJS(data: any): SubscriptionLicenceRequest {
    data = typeof data === 'object' ? data : {}
    let result = new SubscriptionLicenceRequest()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    if (
      this.subscriptionLicenceVms &&
      this.subscriptionLicenceVms.constructor === Array
    ) {
      data['subscriptionLicenceVms'] = []
      for (let item of this.subscriptionLicenceVms)
        data['subscriptionLicenceVms'].push(item.toJSON())
    }
    return data
  }
}

export interface ISubscriptionLicenceRequest {
  subscriptionLicenceVms?: SubscriptionLicenceVm[]
}

export class ProductsVm implements IProductsVm {
  id: string
  name?: string
  isSelect: boolean
  rates?: ProductPackageRate[]
  billingType?: string
  duration: number
  quantity: number
  startDate?: string

  constructor(data?: IProductsVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.id = data['id']
      this.name = data['name']
      this.isSelect = data['isSelect']
      if (data['rates'] && data['rates'].constructor === Array) {
        this.rates = []
        for (let item of data['rates'])
          this.rates.push(ProductPackageRate.fromJS(item))
      }
      this.billingType = data['billingType']
      this.duration = data['duration']
      this.quantity = data['quantity']
      this.startDate = data['startDate']
    }
  }

  static fromJS(data: any): ProductsVm {
    data = typeof data === 'object' ? data : {}
    let result = new ProductsVm()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['id'] = this.id
    data['name'] = this.name
    data['isSelect'] = this.isSelect
    if (this.rates && this.rates.constructor === Array) {
      data['rates'] = []
      for (let item of this.rates) data['rates'].push(item.toJSON())
    }
    data['billingType'] = this.billingType
    data['duration'] = this.duration
    data['quantity'] = this.quantity
    data['startDate'] = this.startDate
    return data
  }
}

export interface IProductsVm {
  id: string
  name?: string
  isSelect: boolean
  rates?: ProductPackageRate[]
  billingType?: string
  duration: number
  quantity: number
  startDate?: string
}

export class SubDataTableRequest implements ISubDataTableRequest {
  customerId: string
  subscriptionId: string
  dtRequest?: DataTableRequest

  constructor(data?: ISubDataTableRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.customerId = data['customerId']
      this.subscriptionId = data['subscriptionId']
      this.dtRequest = data['dtRequest']
        ? DataTableRequest.fromJS(data['dtRequest'])
        : <any>undefined
    }
  }

  static fromJS(data: any): SubDataTableRequest {
    data = typeof data === 'object' ? data : {}
    let result = new SubDataTableRequest()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['customerId'] = this.customerId
    data['subscriptionId'] = this.subscriptionId
    data['dtRequest'] = this.dtRequest
      ? this.dtRequest.toJSON()
      : <any>undefined
    return data
  }
}

export interface ISubDataTableRequest {
  customerId: string
  subscriptionId: string
  dtRequest?: DataTableRequest
}

export class DataTableResponseOfSubscriptionDataTable
  implements IDataTableResponseOfSubscriptionDataTable {
  draw: number
  recordsFiltered: number
  recordsTotal: number
  totalTime: number
  data?: SubscriptionDataTable[]

  constructor(data?: IDataTableResponseOfSubscriptionDataTable) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.draw = data['draw']
      this.recordsFiltered = data['recordsFiltered']
      this.recordsTotal = data['recordsTotal']
      this.totalTime = data['totalTime']
      if (data['data'] && data['data'].constructor === Array) {
        this.data = []
        for (let item of data['data'])
          this.data.push(SubscriptionDataTable.fromJS(item))
      }
    }
  }

  static fromJS(data: any): DataTableResponseOfSubscriptionDataTable {
    data = typeof data === 'object' ? data : {}
    let result = new DataTableResponseOfSubscriptionDataTable()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['draw'] = this.draw
    data['recordsFiltered'] = this.recordsFiltered
    data['recordsTotal'] = this.recordsTotal
    data['totalTime'] = this.totalTime
    if (this.data && this.data.constructor === Array) {
      data['data'] = []
      for (let item of this.data) data['data'].push(item.toJSON())
    }
    return data
  }
}

export interface IDataTableResponseOfSubscriptionDataTable {
  draw: number
  recordsFiltered: number
  recordsTotal: number
  totalTime: number
  data?: SubscriptionDataTable[]
}

export class SubscriptionDataTableRespone
  extends DataTableResponseOfSubscriptionDataTable
  implements ISubscriptionDataTableRespone {
  constructor(data?: ISubscriptionDataTableRespone) {
    super(data)
  }

  init(data?: any) {
    super.init(data)
    if (data) {
    }
  }

  static fromJS(data: any): SubscriptionDataTableRespone {
    data = typeof data === 'object' ? data : {}
    let result = new SubscriptionDataTableRespone()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    super.toJSON(data)
    return data
  }
}

export interface ISubscriptionDataTableRespone
  extends IDataTableResponseOfSubscriptionDataTable {}

export class SubscriptionDataTable implements ISubscriptionDataTable {
  id: string
  subscriptionDate: Date
  productName?: string
  isPaid?: string
  usageType?: string
  numberofAssign: number
  number?: string
  customerId: string
  numberOfUsers: number
  isAutoBilled: boolean
  isLicenced: boolean

  constructor(data?: ISubscriptionDataTable) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.id = data['id']
      this.subscriptionDate = data['subscriptionDate']
        ? new Date(data['subscriptionDate'].toString())
        : <any>undefined
      this.productName = data['productName']
      this.isPaid = data['isPaid']
      this.usageType = data['usageType']
      this.numberofAssign = data['numberofAssign']
      this.number = data['number']
      this.customerId = data['customerId']
      this.numberOfUsers = data['numberOfUsers']
      this.isAutoBilled = data['isAutoBilled']
      this.isLicenced = data['isLicenced']
    }
  }

  static fromJS(data: any): SubscriptionDataTable {
    data = typeof data === 'object' ? data : {}
    let result = new SubscriptionDataTable()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['id'] = this.id
    data['subscriptionDate'] = this.subscriptionDate
      ? this.subscriptionDate.toISOString()
      : <any>undefined
    data['productName'] = this.productName
    data['isPaid'] = this.isPaid
    data['usageType'] = this.usageType
    data['numberofAssign'] = this.numberofAssign
    data['number'] = this.number
    data['customerId'] = this.customerId
    data['numberOfUsers'] = this.numberOfUsers
    data['isAutoBilled'] = this.isAutoBilled
    data['isLicenced'] = this.isLicenced
    return data
  }
}

export interface ISubscriptionDataTable {
  id: string
  subscriptionDate: Date
  productName?: string
  isPaid?: string
  usageType?: string
  numberofAssign: number
  number?: string
  customerId: string
  numberOfUsers: number
  isAutoBilled: boolean
  isLicenced: boolean
}

export class SubscriptionVm implements ISubscriptionVm {
  subscriptionId: string
  productId: string
  productName?: string
  startDate: Date
  billingType?: string
  duration: number
  quantity: number

  constructor(data?: ISubscriptionVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.subscriptionId = data['subscriptionId']
      this.productId = data['productId']
      this.productName = data['productName']
      this.startDate = data['startDate']
        ? new Date(data['startDate'].toString())
        : <any>undefined
      this.billingType = data['billingType']
      this.duration = data['duration']
      this.quantity = data['quantity']
    }
  }

  static fromJS(data: any): SubscriptionVm {
    data = typeof data === 'object' ? data : {}
    let result = new SubscriptionVm()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['subscriptionId'] = this.subscriptionId
    data['productId'] = this.productId
    data['productName'] = this.productName
    data['startDate'] = this.startDate
      ? this.startDate.toISOString()
      : <any>undefined
    data['billingType'] = this.billingType
    data['duration'] = this.duration
    data['quantity'] = this.quantity
    return data
  }
}

export interface ISubscriptionVm {
  subscriptionId: string
  productId: string
  productName?: string
  startDate: Date
  billingType?: string
  duration: number
  quantity: number
}

export class SummaryAuditSearchRequest implements ISummaryAuditSearchRequest {
  customerId: string
  customerUserId: string
  companyuserid: string
  fromdate?: string
  todate?: string
  dtRequest?: DataTableRequest

  constructor(data?: ISummaryAuditSearchRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.customerId = data['customerId']
      this.customerUserId = data['customerUserId']
      this.companyuserid = data['companyuserid']
      this.fromdate = data['fromdate']
      this.todate = data['todate']
      this.dtRequest = data['dtRequest']
        ? DataTableRequest.fromJS(data['dtRequest'])
        : <any>undefined
    }
  }

  static fromJS(data: any): SummaryAuditSearchRequest {
    data = typeof data === 'object' ? data : {}
    let result = new SummaryAuditSearchRequest()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['customerId'] = this.customerId
    data['customerUserId'] = this.customerUserId
    data['companyuserid'] = this.companyuserid
    data['fromdate'] = this.fromdate
    data['todate'] = this.todate
    data['dtRequest'] = this.dtRequest
      ? this.dtRequest.toJSON()
      : <any>undefined
    return data
  }
}

export interface ISummaryAuditSearchRequest {
  customerId: string
  customerUserId: string
  companyuserid: string
  fromdate?: string
  todate?: string
  dtRequest?: DataTableRequest
}

export class DataTableResponseOfCustomerLogvm
  implements IDataTableResponseOfCustomerLogvm {
  draw: number
  recordsFiltered: number
  recordsTotal: number
  totalTime: number
  data?: CustomerLogvm[]

  constructor(data?: IDataTableResponseOfCustomerLogvm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.draw = data['draw']
      this.recordsFiltered = data['recordsFiltered']
      this.recordsTotal = data['recordsTotal']
      this.totalTime = data['totalTime']
      if (data['data'] && data['data'].constructor === Array) {
        this.data = []
        for (let item of data['data'])
          this.data.push(CustomerLogvm.fromJS(item))
      }
    }
  }

  static fromJS(data: any): DataTableResponseOfCustomerLogvm {
    data = typeof data === 'object' ? data : {}
    let result = new DataTableResponseOfCustomerLogvm()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['draw'] = this.draw
    data['recordsFiltered'] = this.recordsFiltered
    data['recordsTotal'] = this.recordsTotal
    data['totalTime'] = this.totalTime
    if (this.data && this.data.constructor === Array) {
      data['data'] = []
      for (let item of this.data) data['data'].push(item.toJSON())
    }
    return data
  }
}

export interface IDataTableResponseOfCustomerLogvm {
  draw: number
  recordsFiltered: number
  recordsTotal: number
  totalTime: number
  data?: CustomerLogvm[]
}

export class SummaryAuditDataResponse extends DataTableResponseOfCustomerLogvm
  implements ISummaryAuditDataResponse {
  constructor(data?: ISummaryAuditDataResponse) {
    super(data)
  }

  init(data?: any) {
    super.init(data)
    if (data) {
    }
  }

  static fromJS(data: any): SummaryAuditDataResponse {
    data = typeof data === 'object' ? data : {}
    let result = new SummaryAuditDataResponse()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    super.toJSON(data)
    return data
  }
}

export interface ISummaryAuditDataResponse
  extends IDataTableResponseOfCustomerLogvm {}

export class CustomerLogvm implements ICustomerLogvm {
  fromdate: Date
  todate: Date
  id: string
  userActiveDate: Date
  userLastActiveDate: Date
  creditPoints: number
  loginName?: string
  fullName?: string
  userType: boolean
  firstname?: string

  constructor(data?: ICustomerLogvm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.fromdate = data['fromdate']
        ? new Date(data['fromdate'].toString())
        : <any>undefined
      this.todate = data['todate']
        ? new Date(data['todate'].toString())
        : <any>undefined
      this.id = data['id']
      this.userActiveDate = data['userActiveDate']
        ? new Date(data['userActiveDate'].toString())
        : <any>undefined
      this.userLastActiveDate = data['userLastActiveDate']
        ? new Date(data['userLastActiveDate'].toString())
        : <any>undefined
      this.creditPoints = data['creditPoints']
      this.loginName = data['loginName']
      this.fullName = data['fullName']
      this.userType = data['userType']
      this.firstname = data['firstname']
    }
  }

  static fromJS(data: any): CustomerLogvm {
    data = typeof data === 'object' ? data : {}
    let result = new CustomerLogvm()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['fromdate'] = this.fromdate
      ? this.fromdate.toISOString()
      : <any>undefined
    data['todate'] = this.todate ? this.todate.toISOString() : <any>undefined
    data['id'] = this.id
    data['userActiveDate'] = this.userActiveDate
      ? this.userActiveDate.toISOString()
      : <any>undefined
    data['userLastActiveDate'] = this.userLastActiveDate
      ? this.userLastActiveDate.toISOString()
      : <any>undefined
    data['creditPoints'] = this.creditPoints
    data['loginName'] = this.loginName
    data['fullName'] = this.fullName
    data['userType'] = this.userType
    data['firstname'] = this.firstname
    return data
  }
}

export interface ICustomerLogvm {
  fromdate: Date
  todate: Date
  id: string
  userActiveDate: Date
  userLastActiveDate: Date
  creditPoints: number
  loginName?: string
  fullName?: string
  userType: boolean
  firstname?: string
}

export class UserDataTableRequest implements IUserDataTableRequest {
  customerId: string
  customerUserId: string
  dtRequest?: DataTableRequest

  constructor(data?: IUserDataTableRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.customerId = data['customerId']
      this.customerUserId = data['customerUserId']
      this.dtRequest = data['dtRequest']
        ? DataTableRequest.fromJS(data['dtRequest'])
        : <any>undefined
    }
  }

  static fromJS(data: any): UserDataTableRequest {
    data = typeof data === 'object' ? data : {}
    let result = new UserDataTableRequest()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['customerId'] = this.customerId
    data['customerUserId'] = this.customerUserId
    data['dtRequest'] = this.dtRequest
      ? this.dtRequest.toJSON()
      : <any>undefined
    return data
  }
}

export interface IUserDataTableRequest {
  customerId: string
  customerUserId: string
  dtRequest?: DataTableRequest
}

export class DataTableResponseOfUsers implements IDataTableResponseOfUsers {
  draw: number
  recordsFiltered: number
  recordsTotal: number
  totalTime: number
  data?: Users[]

  constructor(data?: IDataTableResponseOfUsers) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.draw = data['draw']
      this.recordsFiltered = data['recordsFiltered']
      this.recordsTotal = data['recordsTotal']
      this.totalTime = data['totalTime']
      if (data['data'] && data['data'].constructor === Array) {
        this.data = []
        for (let item of data['data']) this.data.push(Users.fromJS(item))
      }
    }
  }

  static fromJS(data: any): DataTableResponseOfUsers {
    data = typeof data === 'object' ? data : {}
    let result = new DataTableResponseOfUsers()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['draw'] = this.draw
    data['recordsFiltered'] = this.recordsFiltered
    data['recordsTotal'] = this.recordsTotal
    data['totalTime'] = this.totalTime
    if (this.data && this.data.constructor === Array) {
      data['data'] = []
      for (let item of this.data) data['data'].push(item.toJSON())
    }
    return data
  }
}

export interface IDataTableResponseOfUsers {
  draw: number
  recordsFiltered: number
  recordsTotal: number
  totalTime: number
  data?: Users[]
}

export class UserResponse extends DataTableResponseOfUsers
  implements IUserResponse {
  constructor(data?: IUserResponse) {
    super(data)
  }

  init(data?: any) {
    super.init(data)
    if (data) {
    }
  }

  static fromJS(data: any): UserResponse {
    data = typeof data === 'object' ? data : {}
    let result = new UserResponse()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    super.toJSON(data)
    return data
  }
}

export interface IUserResponse extends IDataTableResponseOfUsers {}

export class Users implements IUsers {
  id: string
  firstName?: string
  lastName?: string
  title?: string
  idNumber?: string
  email?: string
  password?: string
  isAdmin: boolean
  MAchAddressCHK?: boolean
  MacAddresses: string
  status?: string
  customerId: string

  constructor(data?: IUsers) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.id = data['id']
      this.firstName = data['firstName']
      this.lastName = data['lastName']
      this.title = data['title']
      this.idNumber = data['idNumber']
      this.email = data['email']
      this.password = data['password']
      this.isAdmin = data['isAdmin']
      this.MAchAddressCHK = data['MAchAddressCHK']
      this.MacAddresses = data['MacAddresses']
      this.status = data['status']
      this.customerId = data['customerId']
    }
  }

  static fromJS(data: any): Users {
    data = typeof data === 'object' ? data : {}
    let result = new Users()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['id'] = this.id
    data['firstName'] = this.firstName
    data['lastName'] = this.lastName
    data['title'] = this.title
    data['idNumber'] = this.idNumber
    data['email'] = this.email
    data['password'] = this.password
    data['isAdmin'] = this.isAdmin
    data['MAchAddressCHK'] = this.MAchAddressCHK
    data['MacAddresses'] = this.MacAddresses
    data['status'] = this.status
    data['customerId'] = this.customerId
    return data
  }
}

export interface IUsers {
  id: string
  firstName?: string
  lastName?: string
  title?: string
  idNumber?: string
  email?: string
  password?: string
  isAdmin: boolean
  status?: string
  customerId: string
}

export class CrudUserResponse implements ICrudUserResponse {
  message?: string
  isSuccess: boolean

  constructor(data?: ICrudUserResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.message = data['message']
      this.isSuccess = data['isSuccess']
    }
  }

  static fromJS(data: any): CrudUserResponse {
    data = typeof data === 'object' ? data : {}
    let result = new CrudUserResponse()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['message'] = this.message
    data['isSuccess'] = this.isSuccess
    return data
  }
}

export interface ICrudUserResponse {
  message?: string
  isSuccess: boolean
}

export class DashboardVm implements IDashboardVm {
  insertCount: number
  updateCount: number
  yearToDateUpdate: number
  tableName?: string
  totalCount: number
  insertper: number
  updateper: number
  yeartodateper: number

  constructor(data?: IDashboardVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.insertCount = data['insertCount']
      this.updateCount = data['updateCount']
      this.yearToDateUpdate = data['yearToDateUpdate']
      this.tableName = data['tableName']
      this.totalCount = data['totalCount']
      this.insertper = data['insertper']
      this.updateper = data['updateper']
      this.yeartodateper = data['yeartodateper']
    }
  }

  static fromJS(data: any): DashboardVm {
    data = typeof data === 'object' ? data : {}
    let result = new DashboardVm()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['insertCount'] = this.insertCount
    data['updateCount'] = this.updateCount
    data['yearToDateUpdate'] = this.yearToDateUpdate
    data['tableName'] = this.tableName
    data['totalCount'] = this.totalCount
    data['insertper'] = this.insertper
    data['updateper'] = this.updateper
    data['yeartodateper'] = this.yeartodateper
    return data
  }
}

export interface IDashboardVm {
  insertCount: number
  updateCount: number
  yearToDateUpdate: number
  tableName?: string
  totalCount: number
  insertper: number
  updateper: number
  yeartodateper: number
}

export class DatatableLeadRequest implements IDatatableLeadRequest {
  customerId: string
  customerUserId: string
  fromdate?: string
  todate?: string
  dtRequest?: DataTableRequest

  constructor(data?: IDatatableLeadRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.customerId = data['customerId']
      this.customerUserId = data['customerUserId']
      this.fromdate = data['fromdate']
      this.todate = data['todate']
      this.dtRequest = data['dtRequest']
        ? DataTableRequest.fromJS(data['dtRequest'])
        : <any>undefined
    }
  }

  static fromJS(data: any): DatatableLeadRequest {
    data = typeof data === 'object' ? data : {}
    let result = new DatatableLeadRequest()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['customerId'] = this.customerId
    data['customerUserId'] = this.customerUserId
    data['fromdate'] = this.fromdate
    data['todate'] = this.todate
    data['dtRequest'] = this.dtRequest
      ? this.dtRequest.toJSON()
      : <any>undefined
    return data
  }
}

export interface IDatatableLeadRequest {
  customerId: string
  customerUserId: string
  fromdate?: string
  todate?: string
  dtRequest?: DataTableRequest
}

export class DataTableResponseOfLeadListVM
  implements IDataTableResponseOfLeadListVM {
  draw: number
  recordsFiltered: number
  recordsTotal: number
  totalTime: number
  data?: LeadListVM[]

  constructor(data?: IDataTableResponseOfLeadListVM) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.draw = data['draw']
      this.recordsFiltered = data['recordsFiltered']
      this.recordsTotal = data['recordsTotal']
      this.totalTime = data['totalTime']
      if (data['data'] && data['data'].constructor === Array) {
        this.data = []
        for (let item of data['data']) this.data.push(LeadListVM.fromJS(item))
      }
    }
  }

  static fromJS(data: any): DataTableResponseOfLeadListVM {
    data = typeof data === 'object' ? data : {}
    let result = new DataTableResponseOfLeadListVM()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['draw'] = this.draw
    data['recordsFiltered'] = this.recordsFiltered
    data['recordsTotal'] = this.recordsTotal
    data['totalTime'] = this.totalTime
    if (this.data && this.data.constructor === Array) {
      data['data'] = []
      for (let item of this.data) data['data'].push(item.toJSON())
    }
    return data
  }
}

export interface IDataTableResponseOfLeadListVM {
  draw: number
  recordsFiltered: number
  recordsTotal: number
  totalTime: number
  data?: LeadListVM[]
}

export class LeadsDatatableResponse extends DataTableResponseOfLeadListVM
  implements ILeadsDatatableResponse {
  constructor(data?: ILeadsDatatableResponse) {
    super(data)
  }

  init(data?: any) {
    super.init(data)
    if (data) {
    }
  }

  static fromJS(data: any): LeadsDatatableResponse {
    data = typeof data === 'object' ? data : {}
    let result = new LeadsDatatableResponse()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    super.toJSON(data)
    return data
  }
}

export interface ILeadsDatatableResponse
  extends IDataTableResponseOfLeadListVM {}

export class LeadListVM implements ILeadListVM {
  id: string
  fileName?: string
  leadDate?: string
  requiredRecords: number
  isExecuted: boolean
  leadNumber?: string
  isInvoiceRaised: string
  proFormaInvoiceId?: string
  isAdminCertified: boolean
  profileReport: boolean

  constructor(data?: ILeadListVM) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.id = data['id']
      this.fileName = data['fileName']
      this.leadDate = data['leadDate']
      this.requiredRecords = data['requiredRecords']
      this.isExecuted = data['isExecuted']
      this.leadNumber = data['leadNumber']
      this.isInvoiceRaised = data['isInvoiceRaised']
      this.proFormaInvoiceId = data['proFormaInvoiceId']
      this.isAdminCertified = data['isAdminCertified']
      this.profileReport = data['profileReport']
    }
  }

  static fromJS(data: any): LeadListVM {
    data = typeof data === 'object' ? data : {}
    let result = new LeadListVM()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['id'] = this.id
    data['fileName'] = this.fileName
    data['leadDate'] = this.leadDate
    data['requiredRecords'] = this.requiredRecords
    data['isExecuted'] = this.isExecuted
    data['leadNumber'] = this.leadNumber
    data['isInvoiceRaised'] = this.isInvoiceRaised
    data['proFormaInvoiceId'] = this.proFormaInvoiceId
    data['isAdminCertified'] = this.isAdminCertified
    data['profileReport'] = this.profileReport
    return data
  }
}

export interface ILeadListVM {
  id: string
  fileName?: string
  leadDate?: string
  requiredRecords: number
  isExecuted: boolean
  leadNumber?: string
  isInvoiceRaised: string
  proFormaInvoiceId?: string
  isAdminCertified: boolean
  profileReport: boolean
}

export class LeadsRequest implements ILeadsRequest {
  customerId: string
  customerUserId: string
  requiredLeads: number
  dateRange1: number
  dateRange2: number
  isEmployed: boolean
  isDirector: boolean
  isHomeOwner: boolean
  isAdversed: boolean
  isCellNumber: boolean
  isEmail: boolean
  employmentLevel?: string
  isDeceased: boolean
  displayDate1: Date
  displayDate2: Date
  type?: string
  leadId: string
  genderlst?: Gender[]
  provincelst?: Province[]
  statuslst?: MaritalStatus[]
  alloylst?: Alloy[]
  lsmlst?: LSM[]
  risklst?: RiskCategory[]
  inclst?: IncomeCategory[]

  constructor(data?: ILeadsRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.customerId = data['customerId']
      this.customerUserId = data['customerUserId']
      this.requiredLeads = data['requiredLeads']
      this.dateRange1 = data['dateRange1']
      this.dateRange2 = data['dateRange2']
      this.isEmployed = data['isEmployed']
      this.isDirector = data['isDirector']
      this.isHomeOwner = data['isHomeOwner']
      this.isAdversed = data['isAdversed']
      this.isCellNumber = data['isCellNumber']
      this.isEmail = data['isEmail']
      this.employmentLevel = data['employmentLevel']
      this.isDeceased = data['isDeceased']
      this.displayDate1 = data['displayDate1']
        ? new Date(data['displayDate1'].toString())
        : <any>undefined
      this.displayDate2 = data['displayDate2']
        ? new Date(data['displayDate2'].toString())
        : <any>undefined
      this.type = data['type']
      this.leadId = data['leadId']
      if (data['genderlst'] && data['genderlst'].constructor === Array) {
        this.genderlst = []
        for (let item of data['genderlst'])
          this.genderlst.push(Gender.fromJS(item))
      }
      if (data['provincelst'] && data['provincelst'].constructor === Array) {
        this.provincelst = []
        for (let item of data['provincelst'])
          this.provincelst.push(Province.fromJS(item))
      }
      if (data['statuslst'] && data['statuslst'].constructor === Array) {
        this.statuslst = []
        for (let item of data['statuslst'])
          this.statuslst.push(MaritalStatus.fromJS(item))
      }
      if (data['alloylst'] && data['alloylst'].constructor === Array) {
        this.alloylst = []
        for (let item of data['alloylst'])
          this.alloylst.push(Alloy.fromJS(item))
      }
      if (data['lsmlst'] && data['lsmlst'].constructor === Array) {
        this.lsmlst = []
        for (let item of data['lsmlst']) this.lsmlst.push(LSM.fromJS(item))
      }
      if (data['risklst'] && data['risklst'].constructor === Array) {
        this.risklst = []
        for (let item of data['risklst'])
          this.risklst.push(RiskCategory.fromJS(item))
      }
      if (data['inclst'] && data['inclst'].constructor === Array) {
        this.inclst = []
        for (let item of data['inclst'])
          this.inclst.push(IncomeCategory.fromJS(item))
      }
    }
  }

  static fromJS(data: any): LeadsRequest {
    data = typeof data === 'object' ? data : {}
    let result = new LeadsRequest()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['customerId'] = this.customerId
    data['customerUserId'] = this.customerUserId
    data['requiredLeads'] = this.requiredLeads
    data['dateRange1'] = this.dateRange1
    data['dateRange2'] = this.dateRange2
    data['isEmployed'] = this.isEmployed
    data['isDirector'] = this.isDirector
    data['isHomeOwner'] = this.isHomeOwner
    data['isAdversed'] = this.isAdversed
    data['isCellNumber'] = this.isCellNumber
    data['isEmail'] = this.isEmail
    data['employmentLevel'] = this.employmentLevel
    data['isDeceased'] = this.isDeceased
    data['displayDate1'] = this.displayDate1
      ? this.displayDate1.toISOString()
      : <any>undefined
    data['displayDate2'] = this.displayDate2
      ? this.displayDate2.toISOString()
      : <any>undefined
    data['type'] = this.type
    data['leadId'] = this.leadId
    if (this.genderlst && this.genderlst.constructor === Array) {
      data['genderlst'] = []
      for (let item of this.genderlst) data['genderlst'].push(item.toJSON())
    }
    if (this.provincelst && this.provincelst.constructor === Array) {
      data['provincelst'] = []
      for (let item of this.provincelst) data['provincelst'].push(item.toJSON())
    }
    if (this.statuslst && this.statuslst.constructor === Array) {
      data['statuslst'] = []
      for (let item of this.statuslst) data['statuslst'].push(item.toJSON())
    }
    if (this.alloylst && this.alloylst.constructor === Array) {
      data['alloylst'] = []
      for (let item of this.alloylst) data['alloylst'].push(item.toJSON())
    }
    if (this.lsmlst && this.lsmlst.constructor === Array) {
      data['lsmlst'] = []
      for (let item of this.lsmlst) data['lsmlst'].push(item.toJSON())
    }
    if (this.risklst && this.risklst.constructor === Array) {
      data['risklst'] = []
      for (let item of this.risklst) data['risklst'].push(item.toJSON())
    }
    if (this.inclst && this.inclst.constructor === Array) {
      data['inclst'] = []
      for (let item of this.inclst) data['inclst'].push(item.toJSON())
    }
    return data
  }
}

export interface ILeadsRequest {
  customerId: string
  customerUserId: string
  requiredLeads: number
  dateRange1: number
  dateRange2: number
  isEmployed: boolean
  isDirector: boolean
  isHomeOwner: boolean
  isAdversed: boolean
  isCellNumber: boolean
  isEmail: boolean
  employmentLevel?: string
  isDeceased: boolean
  displayDate1: Date
  displayDate2: Date
  type?: string
  leadId: string
  genderlst?: Gender[]
  provincelst?: Province[]
  statuslst?: MaritalStatus[]
  alloylst?: Alloy[]
  lsmlst?: LSM[]
  risklst?: RiskCategory[]
  inclst?: IncomeCategory[]
}

export class Gender implements IGender {
  genderName?: string
  percentage: number

  constructor(data?: IGender) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.genderName = data['genderName']
      this.percentage = data['percentage']
    }
  }

  static fromJS(data: any): Gender {
    data = typeof data === 'object' ? data : {}
    let result = new Gender()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['genderName'] = this.genderName
    data['percentage'] = this.percentage
    return data
  }
}

export interface IGender {
  genderName?: string
  percentage: number
}

export class Province implements IProvince {
  provinceName?: string
  percentage: number

  constructor(data?: IProvince) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.provinceName = data['provinceName']
      this.percentage = data['percentage']
    }
  }

  static fromJS(data: any): Province {
    data = typeof data === 'object' ? data : {}
    let result = new Province()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['provinceName'] = this.provinceName
    data['percentage'] = this.percentage
    return data
  }
}

export interface IProvince {
  provinceName?: string
  percentage: number
}

export class MaritalStatus implements IMaritalStatus {
  statusName?: string
  percentage: number

  constructor(data?: IMaritalStatus) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.statusName = data['statusName']
      this.percentage = data['percentage']
    }
  }

  static fromJS(data: any): MaritalStatus {
    data = typeof data === 'object' ? data : {}
    let result = new MaritalStatus()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['statusName'] = this.statusName
    data['percentage'] = this.percentage
    return data
  }
}

export interface IMaritalStatus {
  statusName?: string
  percentage: number
}

export class Alloy implements IAlloy {
  alloyName?: string
  ischecked: boolean

  constructor(data?: IAlloy) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.alloyName = data['alloyName']
      this.ischecked = data['ischecked']
    }
  }

  static fromJS(data: any): Alloy {
    data = typeof data === 'object' ? data : {}
    let result = new Alloy()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['alloyName'] = this.alloyName
    data['ischecked'] = this.ischecked
    return data
  }
}

export interface IAlloy {
  alloyName?: string
  ischecked: boolean
}

export class LSM implements ILSM {
  lsmName?: string
  ischecked: boolean

  constructor(data?: ILSM) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.lsmName = data['lsmName']
      this.ischecked = data['ischecked']
    }
  }

  static fromJS(data: any): LSM {
    data = typeof data === 'object' ? data : {}
    let result = new LSM()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['lsmName'] = this.lsmName
    data['ischecked'] = this.ischecked
    return data
  }
}

export interface ILSM {
  lsmName?: string
  ischecked: boolean
}

export class RiskCategory implements IRiskCategory {
  riskName?: string
  ischecked: boolean

  constructor(data?: IRiskCategory) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.riskName = data['riskName']
      this.ischecked = data['ischecked']
    }
  }

  static fromJS(data: any): RiskCategory {
    data = typeof data === 'object' ? data : {}
    let result = new RiskCategory()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['riskName'] = this.riskName
    data['ischecked'] = this.ischecked
    return data
  }
}

export interface IRiskCategory {
  riskName?: string
  ischecked: boolean
}

export class IncomeCategory implements IIncomeCategory {
  incomeCategoryName?: string
  ischecked: boolean

  constructor(data?: IIncomeCategory) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.incomeCategoryName = data['incomeCategoryName']
      this.ischecked = data['ischecked']
    }
  }

  static fromJS(data: any): IncomeCategory {
    data = typeof data === 'object' ? data : {}
    let result = new IncomeCategory()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['incomeCategoryName'] = this.incomeCategoryName
    data['ischecked'] = this.ischecked
    return data
  }
}

export interface IIncomeCategory {
  incomeCategoryName?: string
  ischecked: boolean
}

export class LeadGenerationResponse implements ILeadGenerationResponse {
  leadId: string
  profileGender?: string
  profileMarital?: string
  profileRiskCategory?: string
  profileAlloyBreakdown?: string
  profileLocationDistributorAge?: string
  profileAgeGroup?: string
  profileIncomeBrackets?: string
  profileTotalRecords?: string
  isinvoiceraised: boolean
  isProfileRaised: boolean
  tableresponse?: LeadsResponse[]
  morrisGenders?: MorrisGender[]
  morrisMaritalStaus?: MorrisMaritalStaus[]
  morrisRiskCategories?: MorrisRiskCategories[]
  morrisAlloyBreakDowns?: MorrisAlloyBreakDown[]
  locationDistributorAgeGroups?: LocationDistributorAgeGroup[]
  ageGrouGenders?: AgeGrouGenders
  incomeBrackets?: IncomeBrackets
  totalRecordsAvailables?: TotalRecordsAvailable[]
  leadtableresponse?: string
  leadInput?: string

  constructor(data?: ILeadGenerationResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.leadId = data['leadId']
      this.profileGender = data['profileGender']
      this.profileMarital = data['profileMarital']
      this.profileRiskCategory = data['profileRiskCategory']
      this.profileAlloyBreakdown = data['profileAlloyBreakdown']
      this.profileLocationDistributorAge = data['profileLocationDistributorAge']
      this.profileAgeGroup = data['profileAgeGroup']
      this.profileIncomeBrackets = data['profileIncomeBrackets']
      this.profileTotalRecords = data['profileTotalRecords']
      this.isinvoiceraised = data['isinvoiceraised']
      this.isProfileRaised = data['isProfileRaised']
      if (
        data['tableresponse'] &&
        data['tableresponse'].constructor === Array
      ) {
        this.tableresponse = []
        for (let item of data['tableresponse'])
          this.tableresponse.push(LeadsResponse.fromJS(item))
      }
      if (
        data['morrisGenders'] &&
        data['morrisGenders'].constructor === Array
      ) {
        this.morrisGenders = []
        for (let item of data['morrisGenders'])
          this.morrisGenders.push(MorrisGender.fromJS(item))
      }
      if (
        data['morrisMaritalStaus'] &&
        data['morrisMaritalStaus'].constructor === Array
      ) {
        this.morrisMaritalStaus = []
        for (let item of data['morrisMaritalStaus'])
          this.morrisMaritalStaus.push(MorrisMaritalStaus.fromJS(item))
      }
      if (
        data['morrisRiskCategories'] &&
        data['morrisRiskCategories'].constructor === Array
      ) {
        this.morrisRiskCategories = []
        for (let item of data['morrisRiskCategories'])
          this.morrisRiskCategories.push(MorrisRiskCategories.fromJS(item))
      }
      if (
        data['morrisAlloyBreakDowns'] &&
        data['morrisAlloyBreakDowns'].constructor === Array
      ) {
        this.morrisAlloyBreakDowns = []
        for (let item of data['morrisAlloyBreakDowns'])
          this.morrisAlloyBreakDowns.push(MorrisAlloyBreakDown.fromJS(item))
      }
      if (
        data['locationDistributorAgeGroups'] &&
        data['locationDistributorAgeGroups'].constructor === Array
      ) {
        this.locationDistributorAgeGroups = []
        for (let item of data['locationDistributorAgeGroups'])
          this.locationDistributorAgeGroups.push(
            LocationDistributorAgeGroup.fromJS(item),
          )
      }
      this.ageGrouGenders = data['ageGrouGenders']
        ? AgeGrouGenders.fromJS(data['ageGrouGenders'])
        : <any>undefined
      this.incomeBrackets = data['incomeBrackets']
        ? IncomeBrackets.fromJS(data['incomeBrackets'])
        : <any>undefined
      if (
        data['totalRecordsAvailables'] &&
        data['totalRecordsAvailables'].constructor === Array
      ) {
        this.totalRecordsAvailables = []
        for (let item of data['totalRecordsAvailables'])
          this.totalRecordsAvailables.push(TotalRecordsAvailable.fromJS(item))
      }
      this.leadtableresponse = data['leadtableresponse']
      this.leadInput = data['leadInput']
    }
  }

  static fromJS(data: any): LeadGenerationResponse {
    data = typeof data === 'object' ? data : {}
    let result = new LeadGenerationResponse()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['leadId'] = this.leadId
    data['profileGender'] = this.profileGender
    data['profileMarital'] = this.profileMarital
    data['profileRiskCategory'] = this.profileRiskCategory
    data['profileAlloyBreakdown'] = this.profileAlloyBreakdown
    data['profileLocationDistributorAge'] = this.profileLocationDistributorAge
    data['profileAgeGroup'] = this.profileAgeGroup
    data['profileIncomeBrackets'] = this.profileIncomeBrackets
    data['profileTotalRecords'] = this.profileTotalRecords
    data['isinvoiceraised'] = this.isinvoiceraised
    data['isProfileRaised'] = this.isProfileRaised
    if (this.tableresponse && this.tableresponse.constructor === Array) {
      data['tableresponse'] = []
      for (let item of this.tableresponse)
        data['tableresponse'].push(item.toJSON())
    }
    if (this.morrisGenders && this.morrisGenders.constructor === Array) {
      data['morrisGenders'] = []
      for (let item of this.morrisGenders)
        data['morrisGenders'].push(item.toJSON())
    }
    if (
      this.morrisMaritalStaus &&
      this.morrisMaritalStaus.constructor === Array
    ) {
      data['morrisMaritalStaus'] = []
      for (let item of this.morrisMaritalStaus)
        data['morrisMaritalStaus'].push(item.toJSON())
    }
    if (
      this.morrisRiskCategories &&
      this.morrisRiskCategories.constructor === Array
    ) {
      data['morrisRiskCategories'] = []
      for (let item of this.morrisRiskCategories)
        data['morrisRiskCategories'].push(item.toJSON())
    }
    if (
      this.morrisAlloyBreakDowns &&
      this.morrisAlloyBreakDowns.constructor === Array
    ) {
      data['morrisAlloyBreakDowns'] = []
      for (let item of this.morrisAlloyBreakDowns)
        data['morrisAlloyBreakDowns'].push(item.toJSON())
    }
    if (
      this.locationDistributorAgeGroups &&
      this.locationDistributorAgeGroups.constructor === Array
    ) {
      data['locationDistributorAgeGroups'] = []
      for (let item of this.locationDistributorAgeGroups)
        data['locationDistributorAgeGroups'].push(item.toJSON())
    }
    data['ageGrouGenders'] = this.ageGrouGenders
      ? this.ageGrouGenders.toJSON()
      : <any>undefined
    data['incomeBrackets'] = this.incomeBrackets
      ? this.incomeBrackets.toJSON()
      : <any>undefined
    if (
      this.totalRecordsAvailables &&
      this.totalRecordsAvailables.constructor === Array
    ) {
      data['totalRecordsAvailables'] = []
      for (let item of this.totalRecordsAvailables)
        data['totalRecordsAvailables'].push(item.toJSON())
    }
    data['leadtableresponse'] = this.leadtableresponse
    data['leadInput'] = this.leadInput
    return data
  }
}

export interface ILeadGenerationResponse {
  leadId: string
  profileGender?: string
  profileMarital?: string
  profileRiskCategory?: string
  profileAlloyBreakdown?: string
  profileLocationDistributorAge?: string
  profileAgeGroup?: string
  profileIncomeBrackets?: string
  profileTotalRecords?: string
  isinvoiceraised: boolean
  isProfileRaised: boolean
  tableresponse?: LeadsResponse[]
  morrisGenders?: MorrisGender[]
  morrisMaritalStaus?: MorrisMaritalStaus[]
  morrisRiskCategories?: MorrisRiskCategories[]
  morrisAlloyBreakDowns?: MorrisAlloyBreakDown[]
  locationDistributorAgeGroups?: LocationDistributorAgeGroup[]
  ageGrouGenders?: AgeGrouGenders
  incomeBrackets?: IncomeBrackets
  totalRecordsAvailables?: TotalRecordsAvailable[]
  leadtableresponse?: string
  leadInput?: string
}

export class LeadsResponse implements ILeadsResponse {
  provinceName?: string
  gender?: string
  marital?: string
  requiredCount: number
  availableCount: number
  totalSum: number

  constructor(data?: ILeadsResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.provinceName = data['provinceName']
      this.gender = data['gender']
      this.marital = data['marital']
      this.requiredCount = data['requiredCount']
      this.availableCount = data['availableCount']
      this.totalSum = data['totalSum']
    }
  }

  static fromJS(data: any): LeadsResponse {
    data = typeof data === 'object' ? data : {}
    let result = new LeadsResponse()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['provinceName'] = this.provinceName
    data['gender'] = this.gender
    data['marital'] = this.marital
    data['requiredCount'] = this.requiredCount
    data['availableCount'] = this.availableCount
    data['totalSum'] = this.totalSum
    return data
  }
}

export interface ILeadsResponse {
  provinceName?: string
  gender?: string
  marital?: string
  requiredCount: number
  availableCount: number
  totalSum: number
}

export class LeadsMessage implements ILeadsMessage {
  isSuccess: boolean
  message?: string

  constructor(data?: ILeadsMessage) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.isSuccess = data['isSuccess']
      this.message = data['message']
    }
  }

  static fromJS(data: any): LeadsMessage {
    data = typeof data === 'object' ? data : {}
    let result = new LeadsMessage()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['isSuccess'] = this.isSuccess
    data['message'] = this.message
    return data
  }
}

export interface ILeadsMessage {
  isSuccess: boolean
  message?: string
}

export class ProfileRequest implements IProfileRequest {
  id: number
  userId: string
  customerId: string
  searchType?: string
  inputType?: string
  spouseID?: string
  searchCriteria?: string
  istrailuser: boolean

  constructor(data?: IProfileRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.id = data['id']
      this.userId = data['userId']
      this.customerId = data['customerId']
      this.searchType = data['searchType']
      this.inputType = data['inputType']
      this.spouseID = data['spouseID']
      this.searchCriteria = data['searchCriteria']
      this.istrailuser = data['istrailuser']
    }
  }

  static fromJS(data: any): ProfileRequest {
    data = typeof data === 'object' ? data : {}
    let result = new ProfileRequest()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['id'] = this.id
    data['userId'] = this.userId
    data['customerId'] = this.customerId
    data['searchType'] = this.searchType
    data['inputType'] = this.inputType
    data['spouseID'] = this.spouseID
    data['searchCriteria'] = this.searchCriteria
    data['istrailuser'] = this.istrailuser
    return data
  }
}

export interface IProfileRequest {
  id: number
  userId: string
  customerId: string
  searchType?: string
  inputType?: string
  spouseID?: string
  searchCriteria?: string
  istrailuser: boolean
}

export class PersonProfile implements IPersonProfile {
  id?: string
  iD10?: string
  idNumber?: string
  passportNo?: string
  firstName?: string
  secondName?: string
  thirdName?: string
  surname?: string
  birthDate?: Date
  maidenName?: string
  genderInd?: string
  titleCode?: string
  createdOnDate?: Date
  firstInitial?: string
  lastUpdatedDate?: Date
  deceasedDate?: Date
  deceasedStatus?: string
  iDIssuedDate?: Date
  marriageDate?: Date
  placeOfMarriage?: string
  spouseIdnoOrDOB?: string
  spouseSurName?: string
  spouseForeNames?: string
  spouseIdNumber?: string
  nameCombo?: string
  spouseConsumerId: number
  divorceDate?: Date
  divorceIssuedCourt?: string
  placeOfDeath?: string
  causeOfDeath?: string
  maritalStatus?: string
  lastupdatesHomeAffire?: Date
  recordstatusind?: string
  contactScore?: string
  riskScore?: string
  lsm?: string
  errorMessage?: string
  tabs?: string
  contacts?: ContactDetail[]
  addresses?: AddressDetail[]
  employees?: Employeement[]
  emails?: ConsumerEmailConfirmed[]
  directorShips?: DirectorShip[]
  propertyOwners?: PropertyDeedDetail[]
  consumerDebtReview?: Consumerdebtreview[]
  consumerjudgements?: Consumerjudgement[]
  relationships?: ReletionshipLinkVm[]
  timelines?: TimeLine[]

  // krishna start pending
  akadet?: AKADetail[]

  //userName?: any
  companyName?: any
  refNum?: any
  customerRefNum?: any
  searchDate?: Date
  searchCriteria?: any
  // krishna end
  constructor(data?: IPersonProfile) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.id = data['id']
      this.iD10 = data['iD10']
      this.idNumber = data['idNumber']
      this.passportNo = data['passportNo']
      this.firstName = data['firstName']
      this.secondName = data['secondName']
      this.thirdName = data['thirdName']
      this.surname = data['surname']
      this.birthDate = data['birthDate']
        ? new Date(data['birthDate'].toString())
        : <any>undefined
      this.maidenName = data['maidenName']
      this.genderInd = data['genderInd']
      this.titleCode = data['titleCode']
      this.createdOnDate = data['createdOnDate']
        ? new Date(data['createdOnDate'].toString())
        : <any>undefined
      this.firstInitial = data['firstInitial']
      this.lastUpdatedDate = data['lastUpdatedDate']
        ? new Date(data['lastUpdatedDate'].toString())
        : <any>undefined
      this.deceasedDate = data['deceasedDate']
        ? new Date(data['deceasedDate'].toString())
        : <any>undefined
      this.deceasedStatus = data['deceasedStatus']
      this.iDIssuedDate = data['iDIssuedDate']
        ? new Date(data['iDIssuedDate'].toString())
        : <any>undefined
      this.marriageDate = data['marriageDate']
        ? new Date(data['marriageDate'].toString())
        : <any>undefined
      this.placeOfMarriage = data['placeOfMarriage']
      this.spouseIdnoOrDOB = data['spouseIdnoOrDOB']
      this.spouseSurName = data['spouseSurName']
      this.spouseForeNames = data['spouseForeNames']
      this.spouseIdNumber = data['spouseIdNumber']
      this.nameCombo = data['nameCombo']
      this.spouseConsumerId = data['spouseConsumerId']
      this.divorceDate = data['divorceDate']
        ? new Date(data['divorceDate'].toString())
        : <any>undefined
      this.divorceIssuedCourt = data['divorceIssuedCourt']
      this.placeOfDeath = data['placeOfDeath']
      this.causeOfDeath = data['causeOfDeath']
      this.maritalStatus = data['maritalStatus']
      this.lastupdatesHomeAffire = data['lastupdatesHomeAffire']
        ? new Date(data['lastupdatesHomeAffire'].toString())
        : <any>undefined
      this.recordstatusind = data['recordstatusind']
      this.contactScore = data['contactScore']
      this.riskScore = data['riskScore']
      // krishna start
      this.companyName = data['companyName']
      this.refNum = data['refNum']
      this.customerRefNum = data['customerRefNum']
      this.searchCriteria = data['searchCriteria']

      // krishna end

      this.lsm = data['lsm']
      this.errorMessage = data['errorMessage']
      this.tabs = data['tabs']
      if (data['contacts'] && data['contacts'].constructor === Array) {
        this.contacts = []
        for (let item of data['contacts'])
          this.contacts.push(ContactDetail.fromJS(item))
      }
      if (data['addresses'] && data['addresses'].constructor === Array) {
        this.addresses = []
        for (let item of data['addresses'])
          this.addresses.push(AddressDetail.fromJS(item))
      }
      if (data['employees'] && data['employees'].constructor === Array) {
        this.employees = []
        for (let item of data['employees'])
          this.employees.push(Employeement.fromJS(item))
      }
      if (data['emails'] && data['emails'].constructor === Array) {
        this.emails = []
        for (let item of data['emails'])
          this.emails.push(ConsumerEmailConfirmed.fromJS(item))
      }
      if (
        data['directorShips'] &&
        data['directorShips'].constructor === Array
      ) {
        this.directorShips = []
        for (let item of data['directorShips'])
          this.directorShips.push(DirectorShip.fromJS(item))
      }
      if (
        data['propertyOwners'] &&
        data['propertyOwners'].constructor === Array
      ) {
        this.propertyOwners = []
        for (let item of data['propertyOwners'])
          this.propertyOwners.push(PropertyDeedDetail.fromJS(item))
      }
      if (
        data['consumerDebtReview'] &&
        data['consumerDebtReview'].constructor === Array
      ) {
        this.consumerDebtReview = []
        for (let item of data['consumerDebtReview'])
          this.consumerDebtReview.push(Consumerdebtreview.fromJS(item))
      }
      if (
        data['consumerjudgements'] &&
        data['consumerjudgements'].constructor === Array
      ) {
        this.consumerjudgements = []
        for (let item of data['consumerjudgements'])
          this.consumerjudgements.push(Consumerjudgement.fromJS(item))
      }
      if (
        data['relationships'] &&
        data['relationships'].constructor === Array
      ) {
        this.relationships = []
        for (let item of data['relationships'])
          this.relationships.push(ReletionshipLinkVm.fromJS(item))
      }
      if (data['timelines'] && data['timelines'].constructor === Array) {
        this.timelines = []
        for (let item of data['timelines'])
          this.timelines.push(TimeLine.fromJS(item))
      }
      // krishna akas pending 
      if (data['akadet'] && data['akadet'].constructor === Array) {
        this.akadet = []
        for (let item of data['akadet'])
          this.akadet.push(AKADetail.fromJS(item))
      }


    }
  }

  static fromJS(data: any): PersonProfile {
    data = typeof data === 'object' ? data : {}
    let result = new PersonProfile()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['id'] = this.id
    data['iD10'] = this.iD10
    data['idNumber'] = this.idNumber
    data['passportNo'] = this.passportNo
    data['firstName'] = this.firstName
    data['secondName'] = this.secondName
    data['thirdName'] = this.thirdName
    data['surname'] = this.surname
    data['birthDate'] = this.birthDate
      ? this.birthDate.toISOString()
      : <any>undefined
    data['maidenName'] = this.maidenName
    data['genderInd'] = this.genderInd
    data['titleCode'] = this.titleCode
    data['createdOnDate'] = this.createdOnDate
      ? this.createdOnDate.toISOString()
      : <any>undefined
    data['firstInitial'] = this.firstInitial
    data['lastUpdatedDate'] = this.lastUpdatedDate
      ? this.lastUpdatedDate.toISOString()
      : <any>undefined
    data['deceasedDate'] = this.deceasedDate
      ? this.deceasedDate.toISOString()
      : <any>undefined
    data['deceasedStatus'] = this.deceasedStatus
    data['iDIssuedDate'] = this.iDIssuedDate
      ? this.iDIssuedDate.toISOString()
      : <any>undefined
    data['marriageDate'] = this.marriageDate
      ? this.marriageDate.toISOString()
      : <any>undefined
    data['placeOfMarriage'] = this.placeOfMarriage
    data['spouseIdnoOrDOB'] = this.spouseIdnoOrDOB
    data['spouseSurName'] = this.spouseSurName
    data['spouseForeNames'] = this.spouseForeNames
    data['spouseIdNumber'] = this.spouseIdNumber
    data['nameCombo'] = this.nameCombo
    data['spouseConsumerId'] = this.spouseConsumerId
    data['divorceDate'] = this.divorceDate
      ? this.divorceDate.toISOString()
      : <any>undefined
    data['divorceIssuedCourt'] = this.divorceIssuedCourt
    data['placeOfDeath'] = this.placeOfDeath
    data['causeOfDeath'] = this.causeOfDeath
    data['maritalStatus'] = this.maritalStatus
    data['lastupdatesHomeAffire'] = this.lastupdatesHomeAffire
      ? this.lastupdatesHomeAffire.toISOString()
      : <any>undefined
    data['recordstatusind'] = this.recordstatusind
    data['contactScore'] = this.contactScore
    data['riskScore'] = this.riskScore
    // krishna start
    this.companyName = data['companyName']
    this.refNum = data['refNum']
    this.customerRefNum = data['customerRefNum']
    this.searchCriteria = data['searchCriteria']
      // krishna end
    data['lsm'] = this.lsm
    data['errorMessage'] = this.errorMessage
    data['tabs'] = this.tabs
    if (this.contacts && this.contacts.constructor === Array) {
      data['contacts'] = []
      for (let item of this.contacts) data['contacts'].push(item.toJSON())
    }
    if (this.addresses && this.addresses.constructor === Array) {
      data['addresses'] = []
      for (let item of this.addresses) data['addresses'].push(item.toJSON())
    }
    if (this.employees && this.employees.constructor === Array) {
      data['employees'] = []
      for (let item of this.employees) data['employees'].push(item.toJSON())
    }
    if (this.emails && this.emails.constructor === Array) {
      data['emails'] = []
      for (let item of this.emails) data['emails'].push(item.toJSON())
    }
    if (this.directorShips && this.directorShips.constructor === Array) {
      data['directorShips'] = []
      for (let item of this.directorShips)
        data['directorShips'].push(item.toJSON())
    }
    if (this.propertyOwners && this.propertyOwners.constructor === Array) {
      data['propertyOwners'] = []
      for (let item of this.propertyOwners)
        data['propertyOwners'].push(item.toJSON())
    }
    if (
      this.consumerDebtReview &&
      this.consumerDebtReview.constructor === Array
    ) {
      data['consumerDebtReview'] = []
      for (let item of this.consumerDebtReview)
        data['consumerDebtReview'].push(item.toJSON())
    }
    if (
      this.consumerjudgements &&
      this.consumerjudgements.constructor === Array
    ) {
      data['consumerjudgements'] = []
      for (let item of this.consumerjudgements)
        data['consumerjudgements'].push(item.toJSON())
    }
    if (this.relationships && this.relationships.constructor === Array) {
      data['relationships'] = []
      for (let item of this.relationships)
        data['relationships'].push(item.toJSON())
    }
    if (this.timelines && this.timelines.constructor === Array) {
      data['timelines'] = []
      for (let item of this.timelines) data['timelines'].push(item.toJSON())
    }
    return data
  }
}

export interface IPersonProfile {
  id?: string
  iD10?: string
  idNumber?: string
  passportNo?: string
  firstName?: string
  secondName?: string
  thirdName?: string
  surname?: string
  birthDate?: Date
  maidenName?: string
  genderInd?: string
  titleCode?: string
  createdOnDate?: Date
  firstInitial?: string
  lastUpdatedDate?: Date
  deceasedDate?: Date
  deceasedStatus?: string
  iDIssuedDate?: Date
  marriageDate?: Date
  placeOfMarriage?: string
  spouseIdnoOrDOB?: string
  spouseSurName?: string
  spouseForeNames?: string
  spouseIdNumber?: string
  nameCombo?: string
  spouseConsumerId: number
  divorceDate?: Date
  divorceIssuedCourt?: string
  placeOfDeath?: string
  causeOfDeath?: string
  maritalStatus?: string
  lastupdatesHomeAffire?: Date
  recordstatusind?: string
  contactScore?: string
  riskScore?: string
  lsm?: string
  errorMessage?: string
  tabs?: string
  contacts?: ContactDetail[]
  addresses?: AddressDetail[]
  employees?: Employeement[]
  emails?: ConsumerEmailConfirmed[]
  directorShips?: DirectorShip[]
  propertyOwners?: PropertyDeedDetail[]
  consumerDebtReview?: Consumerdebtreview[]
  consumerjudgements?: Consumerjudgement[]
  relationships?: ReletionshipLinkVm[]
  timelines?: TimeLine[]
  // krishna start pending
  akadet?: AKADetail[]

  //userName?: any
  companyName?: any
  refNum?: any
  customerRefNum?: any
  searchDate?: Date
  searchCriteria?: any
  // krishna end

}

export class Employeement implements IEmployeement {
  id?: string
  occupation?: string
  employer?: string
  date?: Date
  recordstatusind: number
  createdDate?: Date

  constructor(data?: IEmployeement) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.id = data['id']
      this.occupation = data['occupation']
      this.employer = data['employer']
      this.date = data['date']
        ? new Date(data['date'].toString())
        : <any>undefined
      this.recordstatusind = data['recordstatusind']
      this.createdDate = data['createdDate']
        ? new Date(data['createdDate'].toString())
        : <any>undefined
    }
  }

  static fromJS(data: any): Employeement {
    data = typeof data === 'object' ? data : {}
    let result = new Employeement()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['id'] = this.id
    data['occupation'] = this.occupation
    data['employer'] = this.employer
    data['date'] = this.date ? this.date.toISOString() : <any>undefined
    data['recordstatusind'] = this.recordstatusind
    data['createdDate'] = this.createdDate
      ? this.createdDate.toISOString()
      : <any>undefined
    return data
  }
}

export interface IEmployeement {
  id?: string
  occupation?: string
  employer?: string
  date?: Date
  recordstatusind: number
  createdDate?: Date
}

export class Consumerdebtreview implements IConsumerdebtreview {
  consumerID: number
  consumerDebtReviewID: number
  debtCounsellorRegistrationNo?: string
  debtCounsellorFirstName?: string
  debtCounsellorSurname?: string
  debtCounsellorTelephoneCode?: string
  debtCounsellorTelephoneNo?: string
  applicationCreationDate?: Date
  debtReviewStatusDate?: Date
  recordStatusInd: number
  deletedReason?: string
  lastUpdatedDate: Date
  debtReviewStatusCode?: string
  subscriberID?: number
  loaderID?: number
  telephoneCodeandNumber?: string

  constructor(data?: IConsumerdebtreview) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.consumerID = data['consumerID']
      this.consumerDebtReviewID = data['consumerDebtReviewID']
      this.debtCounsellorRegistrationNo = data['debtCounsellorRegistrationNo']
      this.debtCounsellorFirstName = data['debtCounsellorFirstName']
      this.debtCounsellorSurname = data['debtCounsellorSurname']
      this.debtCounsellorTelephoneCode = data['debtCounsellorTelephoneCode']
      this.debtCounsellorTelephoneNo = data['debtCounsellorTelephoneNo']
      this.applicationCreationDate = data['applicationCreationDate']
        ? new Date(data['applicationCreationDate'].toString())
        : <any>undefined
      this.debtReviewStatusDate = data['debtReviewStatusDate']
        ? new Date(data['debtReviewStatusDate'].toString())
        : <any>undefined
      this.recordStatusInd = data['recordStatusInd']
      this.deletedReason = data['deletedReason']
      this.lastUpdatedDate = data['lastUpdatedDate']
        ? new Date(data['lastUpdatedDate'].toString())
        : <any>undefined
      this.debtReviewStatusCode = data['debtReviewStatusCode']
      this.subscriberID = data['subscriberID']
      this.loaderID = data['loaderID']
      this.telephoneCodeandNumber = data['telephoneCodeandNumber']
    }
  }

  static fromJS(data: any): Consumerdebtreview {
    data = typeof data === 'object' ? data : {}
    let result = new Consumerdebtreview()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['consumerID'] = this.consumerID
    data['consumerDebtReviewID'] = this.consumerDebtReviewID
    data['debtCounsellorRegistrationNo'] = this.debtCounsellorRegistrationNo
    data['debtCounsellorFirstName'] = this.debtCounsellorFirstName
    data['debtCounsellorSurname'] = this.debtCounsellorSurname
    data['debtCounsellorTelephoneCode'] = this.debtCounsellorTelephoneCode
    data['debtCounsellorTelephoneNo'] = this.debtCounsellorTelephoneNo
    data['applicationCreationDate'] = this.applicationCreationDate
      ? this.applicationCreationDate.toISOString()
      : <any>undefined
    data['debtReviewStatusDate'] = this.debtReviewStatusDate
      ? this.debtReviewStatusDate.toISOString()
      : <any>undefined
    data['recordStatusInd'] = this.recordStatusInd
    data['deletedReason'] = this.deletedReason
    data['lastUpdatedDate'] = this.lastUpdatedDate
      ? this.lastUpdatedDate.toISOString()
      : <any>undefined
    data['debtReviewStatusCode'] = this.debtReviewStatusCode
    data['subscriberID'] = this.subscriberID
    data['loaderID'] = this.loaderID
    data['telephoneCodeandNumber'] = this.telephoneCodeandNumber
    return data
  }
}

export interface IConsumerdebtreview {
  consumerID: number
  consumerDebtReviewID: number
  debtCounsellorRegistrationNo?: string
  debtCounsellorFirstName?: string
  debtCounsellorSurname?: string
  debtCounsellorTelephoneCode?: string
  debtCounsellorTelephoneNo?: string
  applicationCreationDate?: Date
  debtReviewStatusDate?: Date
  recordStatusInd: number
  deletedReason?: string
  lastUpdatedDate: Date
  debtReviewStatusCode?: string
  subscriberID?: number
  loaderID?: number
  telephoneCodeandNumber?: string
}

export class Consumerjudgement implements IConsumerjudgement {
  id?: string
  idno?: string
  casenumber?: string
  casefilingdate?: Date
  casereason?: string
  propertytype?: string
  propertyname?: string
  casetype?: string
  disputeamt?: number
  courtname?: string
  courtcity?: string
  courttype?: string
  plaintiffname?: string
  plaintiffaddress1?: string
  plaintiffaddress2?: string
  plaintiffaddress3?: string
  plaintiffaddress4?: string
  plaintifpostalcode?: string
  attorneyname?: string
  attorneytelephonecode?: string
  attorneytelephoneno?: string
  attorneyfaxcode?: string
  attorneyfaxno?: string
  attorneyaddress1?: string
  attorneyaddress2?: string
  attorneyaddress3?: string
  attorneyaddress4?: string
  attorneypostalcode?: string
  lastupdateddate: Date
  createdodate?: Date
  judgementtypecode?: string
  disputedate?: Date
  disputeresolveddate?: Date
  rescinded?: boolean
  rescissiondate?: Date
  rescissionreason?: string
  rescindedamount?: string

  constructor(data?: IConsumerjudgement) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.id = data['id']
      this.idno = data['idno']
      this.casenumber = data['casenumber']
      this.casefilingdate = data['casefilingdate']
        ? new Date(data['casefilingdate'].toString())
        : <any>undefined
      this.casereason = data['casereason']
      this.propertytype = data['propertytype']
      this.propertyname = data['propertyname']
      this.casetype = data['casetype']
      this.disputeamt = data['disputeamt']
      this.courtname = data['courtname']
      this.courtcity = data['courtcity']
      this.courttype = data['courttype']
      this.plaintiffname = data['plaintiffname']
      this.plaintiffaddress1 = data['plaintiffaddress1']
      this.plaintiffaddress2 = data['plaintiffaddress2']
      this.plaintiffaddress3 = data['plaintiffaddress3']
      this.plaintiffaddress4 = data['plaintiffaddress4']
      this.plaintifpostalcode = data['plaintifpostalcode']
      this.attorneyname = data['attorneyname']
      this.attorneytelephonecode = data['attorneytelephonecode']
      this.attorneytelephoneno = data['attorneytelephoneno']
      this.attorneyfaxcode = data['attorneyfaxcode']
      this.attorneyfaxno = data['attorneyfaxno']
      this.attorneyaddress1 = data['attorneyaddress1']
      this.attorneyaddress2 = data['attorneyaddress2']
      this.attorneyaddress3 = data['attorneyaddress3']
      this.attorneyaddress4 = data['attorneyaddress4']
      this.attorneypostalcode = data['attorneypostalcode']
      this.lastupdateddate = data['lastupdateddate']
        ? new Date(data['lastupdateddate'].toString())
        : <any>undefined
      this.createdodate = data['createdodate']
        ? new Date(data['createdodate'].toString())
        : <any>undefined
      this.judgementtypecode = data['judgementtypecode']
      this.disputedate = data['disputedate']
        ? new Date(data['disputedate'].toString())
        : <any>undefined
      this.disputeresolveddate = data['disputeresolveddate']
        ? new Date(data['disputeresolveddate'].toString())
        : <any>undefined
      this.rescinded = data['rescinded']
      this.rescissiondate = data['rescissiondate']
        ? new Date(data['rescissiondate'].toString())
        : <any>undefined
      this.rescissionreason = data['rescissionreason']
      this.rescindedamount = data['rescindedamount']
    }
  }

  static fromJS(data: any): Consumerjudgement {
    data = typeof data === 'object' ? data : {}
    let result = new Consumerjudgement()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['id'] = this.id
    data['idno'] = this.idno
    data['casenumber'] = this.casenumber
    data['casefilingdate'] = this.casefilingdate
      ? this.casefilingdate.toISOString()
      : <any>undefined
    data['casereason'] = this.casereason
    data['propertytype'] = this.propertytype
    data['propertyname'] = this.propertyname
    data['casetype'] = this.casetype
    data['disputeamt'] = this.disputeamt
    data['courtname'] = this.courtname
    data['courtcity'] = this.courtcity
    data['courttype'] = this.courttype
    data['plaintiffname'] = this.plaintiffname
    data['plaintiffaddress1'] = this.plaintiffaddress1
    data['plaintiffaddress2'] = this.plaintiffaddress2
    data['plaintiffaddress3'] = this.plaintiffaddress3
    data['plaintiffaddress4'] = this.plaintiffaddress4
    data['plaintifpostalcode'] = this.plaintifpostalcode
    data['attorneyname'] = this.attorneyname
    data['attorneytelephonecode'] = this.attorneytelephonecode
    data['attorneytelephoneno'] = this.attorneytelephoneno
    data['attorneyfaxcode'] = this.attorneyfaxcode
    data['attorneyfaxno'] = this.attorneyfaxno
    data['attorneyaddress1'] = this.attorneyaddress1
    data['attorneyaddress2'] = this.attorneyaddress2
    data['attorneyaddress3'] = this.attorneyaddress3
    data['attorneyaddress4'] = this.attorneyaddress4
    data['attorneypostalcode'] = this.attorneypostalcode
    data['lastupdateddate'] = this.lastupdateddate
      ? this.lastupdateddate.toISOString()
      : <any>undefined
    data['createdodate'] = this.createdodate
      ? this.createdodate.toISOString()
      : <any>undefined
    data['judgementtypecode'] = this.judgementtypecode
    data['disputedate'] = this.disputedate
      ? this.disputedate.toISOString()
      : <any>undefined
    data['disputeresolveddate'] = this.disputeresolveddate
      ? this.disputeresolveddate.toISOString()
      : <any>undefined
    data['rescinded'] = this.rescinded
    data['rescissiondate'] = this.rescissiondate
      ? this.rescissiondate.toISOString()
      : <any>undefined
    data['rescissionreason'] = this.rescissionreason
    data['rescindedamount'] = this.rescindedamount
    return data
  }
}

export interface IConsumerjudgement {
  id?: string
  idno?: string
  casenumber?: string
  casefilingdate?: Date
  casereason?: string
  propertytype?: string
  propertyname?: string
  casetype?: string
  disputeamt?: number
  courtname?: string
  courtcity?: string
  courttype?: string
  plaintiffname?: string
  plaintiffaddress1?: string
  plaintiffaddress2?: string
  plaintiffaddress3?: string
  plaintiffaddress4?: string
  plaintifpostalcode?: string
  attorneyname?: string
  attorneytelephonecode?: string
  attorneytelephoneno?: string
  attorneyfaxcode?: string
  attorneyfaxno?: string
  attorneyaddress1?: string
  attorneyaddress2?: string
  attorneyaddress3?: string
  attorneyaddress4?: string
  attorneypostalcode?: string
  lastupdateddate: Date
  createdodate?: Date
  judgementtypecode?: string
  disputedate?: Date
  disputeresolveddate?: Date
  rescinded?: boolean
  rescissiondate?: Date
  rescissionreason?: string
  rescindedamount?: string
}

export class ReletionshipLinkVm implements IReletionshipLinkVm {
  type?: string
  idNumber?: string
  fullName?: string
  consumerId: number
  keyMatch?: string
  matchCriteria?: string
  displayNo?: string

  constructor(data?: IReletionshipLinkVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.type = data['type']
      this.idNumber = data['idNumber']
      this.fullName = data['fullName']
      this.consumerId = data['consumerId']
      this.keyMatch = data['keyMatch']
      this.matchCriteria = data['matchCriteria']
      this.displayNo = data['displayNo']
    }
  }

  static fromJS(data: any): ReletionshipLinkVm {
    data = typeof data === 'object' ? data : {}
    let result = new ReletionshipLinkVm()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['type'] = this.type
    data['idNumber'] = this.idNumber
    data['fullName'] = this.fullName
    data['consumerId'] = this.consumerId
    data['keyMatch'] = this.keyMatch
    data['matchCriteria'] = this.matchCriteria
    data['displayNo'] = this.displayNo
    return data
  }
}

export interface IReletionshipLinkVm {
  type?: string
  idNumber?: string
  fullName?: string
  consumerId: number
  keyMatch?: string
  matchCriteria?: string
  displayNo?: string
}

export class Endorsement implements IEndorsement {
  endorsementID: number
  propertyDeedID?: number
  propertydeed?: PropertyDeed
  endorsementNumber?: string
  endorsementHolder?: string
  endorsementAmount?: number
  recordStatusInd?: string
  createByUser?: string
  createdOnDate: Date
  changedByUser?: string
  changedOnDate?: Date
  deedsLoaderID?: number

  constructor(data?: IEndorsement) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.endorsementID = data['endorsementID']
      this.propertyDeedID = data['propertyDeedID']
      this.propertydeed = data['propertydeed']
        ? PropertyDeed.fromJS(data['propertydeed'])
        : <any>undefined
      this.endorsementNumber = data['endorsementNumber']
      this.endorsementHolder = data['endorsementHolder']
      this.endorsementAmount = data['endorsementAmount']
      this.recordStatusInd = data['recordStatusInd']
      this.createByUser = data['createByUser']
      this.createdOnDate = data['createdOnDate']
        ? new Date(data['createdOnDate'].toString())
        : <any>undefined
      this.changedByUser = data['changedByUser']
      this.changedOnDate = data['changedOnDate']
        ? new Date(data['changedOnDate'].toString())
        : <any>undefined
      this.deedsLoaderID = data['deedsLoaderID']
    }
  }

  static fromJS(data: any): Endorsement {
    data = typeof data === 'object' ? data : {}
    let result = new Endorsement()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['endorsementID'] = this.endorsementID
    data['propertyDeedID'] = this.propertyDeedID
    data['propertydeed'] = this.propertydeed
      ? this.propertydeed.toJSON()
      : <any>undefined
    data['endorsementNumber'] = this.endorsementNumber
    data['endorsementHolder'] = this.endorsementHolder
    data['endorsementAmount'] = this.endorsementAmount
    data['recordStatusInd'] = this.recordStatusInd
    data['createByUser'] = this.createByUser
    data['createdOnDate'] = this.createdOnDate
      ? this.createdOnDate.toISOString()
      : <any>undefined
    data['changedByUser'] = this.changedByUser
    data['changedOnDate'] = this.changedOnDate
      ? this.changedOnDate.toISOString()
      : <any>undefined
    data['deedsLoaderID'] = this.deedsLoaderID
    return data
  }
}

export interface IEndorsement {
  endorsementID: number
  propertyDeedID?: number
  propertydeed?: PropertyDeed
  endorsementNumber?: string
  endorsementHolder?: string
  endorsementAmount?: number
  recordStatusInd?: string
  createByUser?: string
  createdOnDate: Date
  changedByUser?: string
  changedOnDate?: Date
  deedsLoaderID?: number
}

export class PropertyDeed implements IPropertyDeed {
  propertyDeedID: number
  deedsOfficeId: number
  titleDeedNo?: string
  titleDeedNoOLD?: string
  titleDeedFee?: number
  datePurchase?: Date
  dateRegister?: Date
  purchaseAmount?: number
  streetAddress?: string
  streetNumber?: string
  streetName?: string
  streetType?: string
  y?: number
  x?: number
  suburbCode?: string
  suburbDeeds?: string
  town?: string
  authority?: string
  municipalityName?: string
  provinceId?: number
  isCurrentOwner?: boolean
  extent?: string
  attorneyFirmNumber?: string
  attorneyFileNumber?: string
  transferSeqNo?: number
  dateCaptured?: Date
  bondNumber?: string
  bondHolder?: string
  bondAmount?: number
  propertyType?: string
  propertyName?: string
  schemeId?: string
  suburbId?: number
  erf?: string
  portion?: number
  unit?: number
  createdOndate?: Date
  erfSize?: string
  standNo?: string
  portionNo?: string
  townShipNo?: number
  prevExtent?: string
  isCurrOwnerUpdated?: number
  changedByLoaderID?: number
  recordStatusInd: string

  constructor(data?: IPropertyDeed) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.propertyDeedID = data['propertyDeedID']
      this.deedsOfficeId = data['deedsOfficeId']
      this.titleDeedNo = data['titleDeedNo']
      this.titleDeedNoOLD = data['titleDeedNoOLD']
      this.titleDeedFee = data['titleDeedFee']
      this.datePurchase = data['datePurchase']
        ? new Date(data['datePurchase'].toString())
        : <any>undefined
      this.dateRegister = data['dateRegister']
        ? new Date(data['dateRegister'].toString())
        : <any>undefined
      this.purchaseAmount = data['purchaseAmount']
      this.streetAddress = data['streetAddress']
      this.streetNumber = data['streetNumber']
      this.streetName = data['streetName']
      this.streetType = data['streetType']
      this.y = data['y']
      this.x = data['x']
      this.suburbCode = data['suburbCode']
      this.suburbDeeds = data['suburbDeeds']
      this.town = data['town']
      this.authority = data['authority']
      this.municipalityName = data['municipalityName']
      this.provinceId = data['provinceId']
      this.isCurrentOwner = data['isCurrentOwner']
      this.extent = data['extent']
      this.attorneyFirmNumber = data['attorneyFirmNumber']
      this.attorneyFileNumber = data['attorneyFileNumber']
      this.transferSeqNo = data['transferSeqNo']
      this.dateCaptured = data['dateCaptured']
        ? new Date(data['dateCaptured'].toString())
        : <any>undefined
      this.bondNumber = data['bondNumber']
      this.bondHolder = data['bondHolder']
      this.bondAmount = data['bondAmount']
      this.propertyType = data['propertyType']
      this.propertyName = data['propertyName']
      this.schemeId = data['schemeId']
      this.suburbId = data['suburbId']
      this.erf = data['erf']
      this.portion = data['portion']
      this.unit = data['unit']
      this.createdOndate = data['createdOndate']
        ? new Date(data['createdOndate'].toString())
        : <any>undefined
      this.erfSize = data['erfSize']
      this.standNo = data['standNo']
      this.portionNo = data['portionNo']
      this.townShipNo = data['townShipNo']
      this.prevExtent = data['prevExtent']
      this.isCurrOwnerUpdated = data['isCurrOwnerUpdated']
      this.changedByLoaderID = data['changedByLoaderID']
      this.recordStatusInd = data['recordStatusInd']
    }
  }

  static fromJS(data: any): PropertyDeed {
    data = typeof data === 'object' ? data : {}
    let result = new PropertyDeed()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['propertyDeedID'] = this.propertyDeedID
    data['deedsOfficeId'] = this.deedsOfficeId
    data['titleDeedNo'] = this.titleDeedNo
    data['titleDeedNoOLD'] = this.titleDeedNoOLD
    data['titleDeedFee'] = this.titleDeedFee
    data['datePurchase'] = this.datePurchase
      ? this.datePurchase.toISOString()
      : <any>undefined
    data['dateRegister'] = this.dateRegister
      ? this.dateRegister.toISOString()
      : <any>undefined
    data['purchaseAmount'] = this.purchaseAmount
    data['streetAddress'] = this.streetAddress
    data['streetNumber'] = this.streetNumber
    data['streetName'] = this.streetName
    data['streetType'] = this.streetType
    data['y'] = this.y
    data['x'] = this.x
    data['suburbCode'] = this.suburbCode
    data['suburbDeeds'] = this.suburbDeeds
    data['town'] = this.town
    data['authority'] = this.authority
    data['municipalityName'] = this.municipalityName
    data['provinceId'] = this.provinceId
    data['isCurrentOwner'] = this.isCurrentOwner
    data['extent'] = this.extent
    data['attorneyFirmNumber'] = this.attorneyFirmNumber
    data['attorneyFileNumber'] = this.attorneyFileNumber
    data['transferSeqNo'] = this.transferSeqNo
    data['dateCaptured'] = this.dateCaptured
      ? this.dateCaptured.toISOString()
      : <any>undefined
    data['bondNumber'] = this.bondNumber
    data['bondHolder'] = this.bondHolder
    data['bondAmount'] = this.bondAmount
    data['propertyType'] = this.propertyType
    data['propertyName'] = this.propertyName
    data['schemeId'] = this.schemeId
    data['suburbId'] = this.suburbId
    data['erf'] = this.erf
    data['portion'] = this.portion
    data['unit'] = this.unit
    data['createdOndate'] = this.createdOndate
      ? this.createdOndate.toISOString()
      : <any>undefined
    data['erfSize'] = this.erfSize
    data['standNo'] = this.standNo
    data['portionNo'] = this.portionNo
    data['townShipNo'] = this.townShipNo
    data['prevExtent'] = this.prevExtent
    data['isCurrOwnerUpdated'] = this.isCurrOwnerUpdated
    data['changedByLoaderID'] = this.changedByLoaderID
    data['recordStatusInd'] = this.recordStatusInd
    return data
  }
}

export interface IPropertyDeed {
  propertyDeedID: number
  deedsOfficeId: number
  titleDeedNo?: string
  titleDeedNoOLD?: string
  titleDeedFee?: number
  datePurchase?: Date
  dateRegister?: Date
  purchaseAmount?: number
  streetAddress?: string
  streetNumber?: string
  streetName?: string
  streetType?: string
  y?: number
  x?: number
  suburbCode?: string
  suburbDeeds?: string
  town?: string
  authority?: string
  municipalityName?: string
  provinceId?: number
  isCurrentOwner?: boolean
  extent?: string
  attorneyFirmNumber?: string
  attorneyFileNumber?: string
  transferSeqNo?: number
  dateCaptured?: Date
  bondNumber?: string
  bondHolder?: string
  bondAmount?: number
  propertyType?: string
  propertyName?: string
  schemeId?: string
  suburbId?: number
  erf?: string
  portion?: number
  unit?: number
  createdOndate?: Date
  erfSize?: string
  standNo?: string
  portionNo?: string
  townShipNo?: number
  prevExtent?: string
  isCurrOwnerUpdated?: number
  changedByLoaderID?: number
  recordStatusInd: string
}
export class XdsLoginRequest implements IXdsLoginRequest {
  token?: string
  

  constructor(data?: IXdsLoginRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.token = data['token']
    }
  }

  static fromJS(data: any): XdsLoginRequest {
    data = typeof data === 'object' ? data : {}
    let result = new XdsLoginRequest()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['token'] = this.token
    return data
  }
}

export interface IXdsLoginRequest {
  token?: string
}

export class LoginRequest implements ILoginRequest {
  userName?: string
  password?: string

  constructor(data?: ILoginRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.userName = data['userName']
      this.password = data['password']
    }
  }

  static fromJS(data: any): LoginRequest {
    data = typeof data === 'object' ? data : {}
    let result = new LoginRequest()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['userName'] = this.userName
    data['password'] = this.password
    return data
  }
}

export interface ILoginRequest {
  userName?: string
  password?: string
}




export class LoginReponse implements ILoginReponse {
  isSucsess: boolean
  errorMessage?: string
  userName?: string
  token?: string
  showDSA: boolean
  userID: string
  customerID: string
  credits: number
  isIdasUser: boolean
  userIpaddress?: string
  isTrialuser: boolean
  company: string
  passwordLength: number
  hasNumber: boolean
  hasUpperCase: boolean
  hasLowerCase: boolean
  hasSpecialChars: boolean
  client_logo: string
  //krishna start
  isXDS: boolean
  //krishna end
  constructor(data?: ILoginReponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.isSucsess = data['isSucsess']
      this.errorMessage = data['errorMessage']
      this.userName = data['userName']
      this.token = data['token']
      this.showDSA = data['showDSA']
      this.userID = data['userID']
      this.customerID = data['customerID']
      this.credits = data['credits']
      this.isIdasUser = data['isIdasUser']
      this.userIpaddress = data['userIpaddress']
      this.isTrialuser = data['isTrialuser']
      this.company = data['company']
      this.passwordLength = data['passwordLength']
      this.hasNumber = data['hasNumber']
      this.hasUpperCase = data['hasUpperCase']
      this.hasLowerCase = data['hasLowerCase']
      this.hasSpecialChars = data['hasSpecialChars']
      this.client_logo = data['client_logo']
      // krishna start
      this.isXDS = data['isXDS']
      // krishna end
    }
  }

  static fromJS(data: any): LoginReponse {
    data = typeof data === 'object' ? data : {}
    let result = new LoginReponse()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['isSucsess'] = this.isSucsess
    data['errorMessage'] = this.errorMessage
    data['userName'] = this.userName
    data['token'] = this.token
    data['showDSA'] = this.showDSA
    data['userID'] = this.userID
    data['customerID'] = this.customerID
    data['credits'] = this.credits
    data['isIdasUser'] = this.isIdasUser
    data['userIpaddress'] = this.userIpaddress
    data['isTrialuser'] = this.isTrialuser
    data['company'] = this.company
    data['passwordLength'] = this.passwordLength
    data['hasNumber'] = this.hasNumber
    data['hasUpperCase'] = this.hasUpperCase
    data['hasLowerCase'] = this.hasLowerCase
    data['hasSpecialChars'] = this.hasSpecialChars
    data['client_logo'] = this.client_logo
    // krishna start
    data['isXDS'] = this.isXDS
    // krishna end
    return data
  }
}

export interface ILoginReponse {
  isSucsess: boolean
  errorMessage?: string
  userName?: string
  token?: string
  showDSA: boolean
  userID: string
  customerID: string
  credits: number
  isIdasUser: boolean
  userIpaddress?: string
  isTrialuser: boolean
  company: string
  passwordLength: number
  hasNumber: boolean
  hasUpperCase: boolean
  hasLowerCase: boolean
  hasSpecialChars: boolean  
  client_logo: string
  // krishna start
  isXDS: boolean
  // krishna end
}

export class SignUpRequest implements ISignUpRequest {
  firstName?: string
  lastName?: string
  title?: string
  iDNumber?: string
  emailid?: string
  billEmailadress?: string
  contactNumber?: string
  dsaVersion?: string
  htmlString?: string
  base64Array?: string[]
  floats?: number[]
  customer?: Customer
  toMail?: string
  displayBusinessName?: string

  constructor(data?: ISignUpRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.firstName = data['firstName']
      this.lastName = data['lastName']
      this.title = data['title']
      this.iDNumber = data['iDNumber']
      this.emailid = data['emailid']
      this.billEmailadress = data['billEmailadress']
      this.contactNumber = data['contactNumber']
      this.dsaVersion = data['dsaVersion']
      this.htmlString = data['htmlString']
      if (data['base64Array'] && data['base64Array'].constructor === Array) {
        this.base64Array = []
        for (let item of data['base64Array']) this.base64Array.push(item)
      }
      if (data['floats'] && data['floats'].constructor === Array) {
        this.floats = []
        for (let item of data['floats']) this.floats.push(item)
      }
      this.customer = data['customer']
        ? Customer.fromJS(data['customer'])
        : <any>undefined
      this.toMail = data['toMail']
      this.displayBusinessName = data['displayBusinessName']
    }
  }

  static fromJS(data: any): SignUpRequest {
    data = typeof data === 'object' ? data : {}
    let result = new SignUpRequest()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['firstName'] = this.firstName
    data['lastName'] = this.lastName
    data['title'] = this.title
    data['iDNumber'] = this.iDNumber
    data['emailid'] = this.emailid
    data['billEmailadress'] = this.billEmailadress
    data['contactNumber'] = this.contactNumber
    data['dsaVersion'] = this.dsaVersion
    data['htmlString'] = this.htmlString
    if (this.base64Array && this.base64Array.constructor === Array) {
      data['base64Array'] = []
      for (let item of this.base64Array) data['base64Array'].push(item)
    }
    if (this.floats && this.floats.constructor === Array) {
      data['floats'] = []
      for (let item of this.floats) data['floats'].push(item)
    }
    data['customer'] = this.customer ? this.customer.toJSON() : <any>undefined
    data['toMail'] = this.toMail
    data['displayBusinessName'] = this.displayBusinessName
    return data
  }
}

export interface ISignUpRequest {
  firstName?: string
  lastName?: string
  title?: string
  iDNumber?: string
  emailid?: string
  billEmailadress?: string
  contactNumber?: string
  dsaVersion?: string
  htmlString?: string
  base64Array?: string[]
  floats?: number[]
  customer?: Customer
  toMail?: string
  displayBusinessName?: string
}

export class SignUpResponse implements ISignUpResponse {
  isSucsess: boolean
  message?: string
  token?: string

  constructor(data?: ISignUpResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.isSucsess = data['isSucsess']
      this.message = data['message']
      this.token = data['token']
    }
  }

  static fromJS(data: any): SignUpResponse {
    data = typeof data === 'object' ? data : {}
    let result = new SignUpResponse()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['isSucsess'] = this.isSucsess
    data['message'] = this.message
    data['token'] = this.token
    return data
  }
}

export interface ISignUpResponse {
  isSucsess: boolean
  message?: string
  token?: string
}

export class DonotCallRegistryRequest implements IDonotCallRegistryRequest {
  iDNumber?: string
  name?: string
  surname?: string
  phonenumber?: string
  emailaddress?: string
  currentdate: Date

  constructor(data?: IDonotCallRegistryRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.iDNumber = data['iDNumber']
      this.name = data['name']
      this.surname = data['surname']
      this.phonenumber = data['phonenumber']
      this.emailaddress = data['emailaddress']
      this.currentdate = data['currentdate']
        ? new Date(data['currentdate'].toString())
        : <any>undefined
    }
  }

  static fromJS(data: any): DonotCallRegistryRequest {
    data = typeof data === 'object' ? data : {}
    let result = new DonotCallRegistryRequest()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['iDNumber'] = this.iDNumber
    data['name'] = this.name
    data['surname'] = this.surname
    data['phonenumber'] = this.phonenumber
    data['emailaddress'] = this.emailaddress
    data['currentdate'] = this.currentdate
      ? this.currentdate.toISOString()
      : <any>undefined
    return data
  }
}

export interface IDonotCallRegistryRequest {
  iDNumber?: string
  name?: string
  surname?: string
  phonenumber?: string
  emailaddress?: string
  currentdate: Date
}

export class DonoCallRegistryResponse implements IDonoCallRegistryResponse {
  isSucsess: boolean
  errorMessage?: string
  token?: string

  constructor(data?: IDonoCallRegistryResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.isSucsess = data['isSucsess']
      this.errorMessage = data['errorMessage']
      this.token = data['token']
    }
  }

  static fromJS(data: any): DonoCallRegistryResponse {
    data = typeof data === 'object' ? data : {}
    let result = new DonoCallRegistryResponse()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['isSucsess'] = this.isSucsess
    data['errorMessage'] = this.errorMessage
    data['token'] = this.token
    return data
  }
}

export interface IDonoCallRegistryResponse {
  isSucsess: boolean
  errorMessage?: string
  token?: string
}

export class DataServiceResponse implements IDataServiceResponse {
  version: number
  isSuccess: boolean
  message?: string
  fileName?: string
  description?: string

  constructor(data?: IDataServiceResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.version = data['version']
      this.isSuccess = data['isSuccess']
      this.message = data['message']
      this.fileName = data['fileName']
      this.description = data['description']
    }
  }

  static fromJS(data: any): DataServiceResponse {
    data = typeof data === 'object' ? data : {}
    let result = new DataServiceResponse()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['version'] = this.version
    data['isSuccess'] = this.isSuccess
    data['message'] = this.message
    data['fileName'] = this.fileName
    data['description'] = this.description
    return data
  }
}

export interface IDataServiceResponse {
  version: number
  isSuccess: boolean
  message?: string
  fileName?: string
  description?: string
}

export class TrailUserLog implements ITrailUserLog {
  id: string
  trailUserId: string
  trailUsers?: TrailUser
  date: Date
  productPackageId: string
  creditPoints: number
  idorpassportnumber?: string
  searchtype?: string
  searchCriteria?: string
  logtype?: string
  inputType?: string

  constructor(data?: ITrailUserLog) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.id = data['id']
      this.trailUserId = data['trailUserId']
      this.trailUsers = data['trailUsers']
        ? TrailUser.fromJS(data['trailUsers'])
        : <any>undefined
      this.date = data['date']
        ? new Date(data['date'].toString())
        : <any>undefined
      this.productPackageId = data['productPackageId']
      this.creditPoints = data['creditPoints']
      this.idorpassportnumber = data['idorpassportnumber']
      this.searchtype = data['searchtype']
      this.searchCriteria = data['searchCriteria']
      this.logtype = data['logtype']
      this.inputType = data['inputType']
    }
  }

  static fromJS(data: any): TrailUserLog {
    data = typeof data === 'object' ? data : {}
    let result = new TrailUserLog()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['id'] = this.id
    data['trailUserId'] = this.trailUserId
    data['trailUsers'] = this.trailUsers
      ? this.trailUsers.toJSON()
      : <any>undefined
    data['date'] = this.date ? this.date.toISOString() : <any>undefined
    data['productPackageId'] = this.productPackageId
    data['creditPoints'] = this.creditPoints
    data['idorpassportnumber'] = this.idorpassportnumber
    data['searchtype'] = this.searchtype
    data['searchCriteria'] = this.searchCriteria
    data['logtype'] = this.logtype
    data['inputType'] = this.inputType
    return data
  }
}

export interface ITrailUserLog {
  id: string
  trailUserId: string
  trailUsers?: TrailUser
  date: Date
  productPackageId: string
  creditPoints: number
  idorpassportnumber?: string
  searchtype?: string
  searchCriteria?: string
  logtype?: string
  inputType?: string
}

export class TrailUser implements ITrailUser {
  id: string
  firstName?: string
  surname?: string
  emailAddress?: string
  mobileNumber?: string
  businessRegisterNumber?: string
  password?: string
  date: Date
  isExpired: boolean
  credits: number

  constructor(data?: ITrailUser) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.id = data['id']
      this.firstName = data['firstName']
      this.surname = data['surname']
      this.emailAddress = data['emailAddress']
      this.mobileNumber = data['mobileNumber']
      this.businessRegisterNumber = data['businessRegisterNumber']
      this.password = data['password']
      this.date = data['date']
        ? new Date(data['date'].toString())
        : <any>undefined
      this.isExpired = data['isExpired']
      this.credits = data['credits']
    }
  }

  static fromJS(data: any): TrailUser {
    data = typeof data === 'object' ? data : {}
    let result = new TrailUser()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['id'] = this.id
    data['firstName'] = this.firstName
    data['surname'] = this.surname
    data['emailAddress'] = this.emailAddress
    data['mobileNumber'] = this.mobileNumber
    data['businessRegisterNumber'] = this.businessRegisterNumber
    data['password'] = this.password
    data['date'] = this.date ? this.date.toISOString() : <any>undefined
    data['isExpired'] = this.isExpired
    data['credits'] = this.credits
    return data
  }
}

export interface ITrailUser {
  id: string
  firstName?: string
  surname?: string
  emailAddress?: string
  mobileNumber?: string
  businessRegisterNumber?: string
  password?: string
  date: Date
  isExpired: boolean
  credits: number
}

export class Menu implements IMenu {
  caption?: string
  image?: string
  url?: string
  isSelected: boolean
  subMenus?: Menu[]

  constructor(data?: IMenu) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.caption = data['caption']
      this.image = data['image']
      this.url = data['url']
      this.isSelected = data['isSelected']
      if (data['subMenus'] && data['subMenus'].constructor === Array) {
        this.subMenus = []
        for (let item of data['subMenus']) this.subMenus.push(Menu.fromJS(item))
      }
    }
  }

  static fromJS(data: any): Menu {
    data = typeof data === 'object' ? data : {}
    let result = new Menu()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['caption'] = this.caption
    data['image'] = this.image
    data['url'] = this.url
    data['isSelected'] = this.isSelected
    if (this.subMenus && this.subMenus.constructor === Array) {
      data['subMenus'] = []
      for (let item of this.subMenus) data['subMenus'].push(item.toJSON())
    }
    return data
  }
}

export interface IMenu {
  caption?: string
  image?: string
  url?: string
  isSelected: boolean
  subMenus?: Menu[]
}

export class LookupData implements ILookupData {
  id: string
  type?: string
  value?: string
  text?: string
  isActive: boolean

  constructor(data?: ILookupData) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.id = data['id']
      this.type = data['type']
      this.value = data['value']
      this.text = data['text']
      this.isActive = data['isActive']
    }
  }

  static fromJS(data: any): LookupData {
    data = typeof data === 'object' ? data : {}
    let result = new LookupData()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['id'] = this.id
    data['type'] = this.type
    data['value'] = this.value
    data['text'] = this.text
    data['isActive'] = this.isActive
    return data
  }
}

export interface ILookupData {
  id: string
  type?: string
  value?: string
  text?: string
  isActive: boolean
}

export class ApplicationMessages implements IApplicationMessages {
  id: string
  message?: string
  showmessage: boolean

  constructor(data?: IApplicationMessages) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.id = data['id']
      this.message = data['message']
      this.showmessage = data['showmessage']
    }
  }

  static fromJS(data: any): ApplicationMessages {
    data = typeof data === 'object' ? data : {}
    let result = new ApplicationMessages()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['id'] = this.id
    data['message'] = this.message
    data['showmessage'] = this.showmessage
    return data
  }
}

export interface IApplicationMessages {
  id: string
  message?: string
  showmessage: boolean
}

export class ConsumerSearchRequest implements IConsumerSearchRequest {
  iDNumber?: string
  passport?: string
  enquiryReason?:number
  surname?: string
  firstname?: string
  //reference?: string
  customerRefNum?: string
  voucherCode?: string
  address?: string
  dateOfBirth?: string
  fromDate?: string
  toDate?: string
  phoneNumber?: string
  type?: string
  globalSearch?: string
  emailaddress?: string
  searchTimereq?: string
  userId: string
  consumerId?: string
  isTrailuser: boolean
  custId: string
  isXDS: boolean
  userName: string

  constructor(data?: IConsumerSearchRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.iDNumber = data['iDNumber']
      this.passport = data['passport']
      this.enquiryReason = data['enquiryReason']
      this.surname = data['surname']
      this.firstname = data['firstname']
      this.voucherCode = data['voucherCode']
      this.customerRefNum = data['customerRefNum']
      this.address = data['address']
      this.dateOfBirth = data['dateOfBirth']
      this.fromDate = data['fromDate']
      this.toDate = data['toDate']
      this.phoneNumber = data['phoneNumber']
      this.type = data['type']
      this.globalSearch = data['globalSearch']
      this.emailaddress = data['emailaddress']
      this.searchTimereq = data['searchTimereq']
      this.userId = data['userId']
      this.consumerId = data['consumerId']
      this.isTrailuser = data['isTrailuser']
      //this.isXDS = data['isXDS']
      this.custId = data['custId']
    }
  }

  static fromJS(data: any): ConsumerSearchRequest {
    data = typeof data === 'object' ? data : {}
    let result = new ConsumerSearchRequest()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['iDNumber'] = this.iDNumber
    data['passport'] = this.passport
    data['enquiryReason'] = this.enquiryReason
    data['surname'] = this.surname
    data['firstname'] = this.firstname
    data['customerRefNum'] = this.customerRefNum
    data['voucherCode'] = this.voucherCode
    data['address'] = this.address
    data['dateOfBirth'] = this.dateOfBirth
    data['fromDate'] = this.fromDate
    data['toDate'] = this.toDate
    data['phoneNumber'] = this.phoneNumber
    data['type'] = this.type
    data['globalSearch'] = this.globalSearch
    data['emailaddress'] = this.emailaddress
    data['searchTimereq'] = this.searchTimereq
    data['userId'] = this.userId
    data['consumerId'] = this.consumerId
    data['isTrailuser'] = this.isTrailuser
    //this.isXDS = data['isXDS']
    data['custId'] = this.custId
    return data
  }
}

export interface IConsumerSearchRequest {
  iDNumber?: string
  passport?: string
  enquiryReason?: number
  surname?: string
  firstname?: string
  voucherCode?: string
  customerRefNum?: string
  address?: string
  dateOfBirth?: string
  fromDate?: string
  toDate?: string
  phoneNumber?: string
  type?: string
  globalSearch?: string
  emailaddress?: string
  searchTimereq?: string
  userId: string
  consumerId?: string
  isTrailuser: boolean
  isXDS: boolean
  custId: string
  userName: string
}

export class DataTableResponseOfPersonProfileData
  implements IDataTableResponseOfPersonProfileData {
  draw: number
  recordsFiltered: number
  recordsTotal: number
  totalTime: number
  data?: PersonProfileData[]

  constructor(data?: IDataTableResponseOfPersonProfileData) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.draw = data['draw']
      this.recordsFiltered = data['recordsFiltered']
      this.recordsTotal = data['recordsTotal']
      this.totalTime = data['totalTime']
      if (data['data'] && data['data'].constructor === Array) {
        this.data = []
        for (let item of data['data'])
          this.data.push(PersonProfileData.fromJS(item))
      }
    }
  }

  static fromJS(data: any): DataTableResponseOfPersonProfileData {
    data = typeof data === 'object' ? data : {}
    let result = new DataTableResponseOfPersonProfileData()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['draw'] = this.draw
    data['recordsFiltered'] = this.recordsFiltered
    data['recordsTotal'] = this.recordsTotal
    data['totalTime'] = this.totalTime
    if (this.data && this.data.constructor === Array) {
      data['data'] = []
      for (let item of this.data) data['data'].push(item.toJSON())
    }
    return data
  }
}

export interface IDataTableResponseOfPersonProfileData {
  draw: number
  recordsFiltered: number
  recordsTotal: number
  totalTime: number
  data?: PersonProfileData[]
}

export class ConsumerSearchResponse extends DataTableResponseOfPersonProfileData
  implements IConsumerSearchResponse {
  constructor(data?: IConsumerSearchResponse) {
    super(data)
  }

  init(data?: any) {
    super.init(data)
    if (data) {
    }
  }

  static fromJS(data: any): ConsumerSearchResponse {
    data = typeof data === 'object' ? data : {}
    let result = new ConsumerSearchResponse()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    super.toJSON(data)
    return data
  }
}

export interface IConsumerSearchResponse
  extends IDataTableResponseOfPersonProfileData {}

export class PersonProfileData implements IPersonProfileData {
  totalCount: number
  consumerId?: string
  gender?: string
  iDNumber?: string
  fullName?: string
  age: number
  dateOfBirth: Date
  isdeceased: boolean
  totalTime: number

  constructor(data?: IPersonProfileData) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.totalCount = data['totalCount']
      this.consumerId = data['consumerId']
      this.gender = data['gender']
      this.iDNumber = data['iDNumber']
      this.fullName = data['fullName']
      this.age = data['age']
      this.dateOfBirth = data['dateOfBirth']
        ? new Date(data['dateOfBirth'].toString())
        : <any>undefined
      this.isdeceased = data['isdeceased']
      this.totalTime = data['totalTime']
    }
  }

  static fromJS(data: any): PersonProfileData {
    data = typeof data === 'object' ? data : {}
    let result = new PersonProfileData()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['totalCount'] = this.totalCount
    data['consumerId'] = this.consumerId
    data['gender'] = this.gender
    data['iDNumber'] = this.iDNumber
    data['fullName'] = this.fullName
    data['age'] = this.age
    data['dateOfBirth'] = this.dateOfBirth
      ? this.dateOfBirth.toISOString()
      : <any>undefined
    data['isdeceased'] = this.isdeceased
    data['totalTime'] = this.totalTime
    return data
  }
}

export interface IPersonProfileData {
  totalCount: number
  consumerId?: string
  gender?: string
  iDNumber?: string
  fullName?: string
  age: number
  dateOfBirth: Date
  isdeceased: boolean
  totalTime: number
}

export class CompanySearchRequest implements ICompanySearchRequest {
  companyName?: string
  Client_Logo?: string
  companyRegNumber?: string
  type?: string
  commercialAddress?: string
  commercialTelephone?: string
  globalSearch?: string
  userId: string
  commercialId?: string
  isTrailuser: boolean
  custId: string
  searchTimereq?: string

  constructor(data?: ICompanySearchRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.companyName = data['companyName']
      this.Client_Logo = data['Client_Logo']
      this.companyRegNumber = data['companyRegNumber']
      this.type = data['type']
      this.commercialAddress = data['commercialAddress']
      this.commercialTelephone = data['commercialTelephone']
      this.globalSearch = data['globalSearch']
      this.userId = data['userId']
      this.commercialId = data['commercialId']
      this.isTrailuser = data['isTrailuser']
      this.custId = data['custId']
      this.searchTimereq = data['searchTimereq']
    }
  }

  static fromJS(data: any): CompanySearchRequest {
    data = typeof data === 'object' ? data : {}
    let result = new CompanySearchRequest()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['companyName'] = this.companyName
    data['Client_Logo'] = this.Client_Logo
    data['companyRegNumber'] = this.companyRegNumber
    data['type'] = this.type
    data['commercialAddress'] = this.commercialAddress
    data['commercialTelephone'] = this.commercialTelephone
    data['globalSearch'] = this.globalSearch
    data['userId'] = this.userId
    data['commercialId'] = this.commercialId
    data['isTrailuser'] = this.isTrailuser
    data['custId'] = this.custId
    data['searchTimereq'] = this.searchTimereq
    return data
  }
}

export interface ICompanySearchRequest {
  companyName?: string
  Client_Logo?: string
  companyRegNumber?: string
  type?: string
  commercialAddress?: string
  commercialTelephone?: string
  globalSearch?: string
  userId: string
  commercialId?: string
  isTrailuser: boolean
  custId: string
  searchTimereq?: string
}

export class DataTableResponseOfCompanyData
  implements IDataTableResponseOfCompanyData {
  draw: number
  recordsFiltered: number
  recordsTotal: number
  totalTime: number
  data?: CompanyData[]

  constructor(data?: IDataTableResponseOfCompanyData) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.draw = data['draw']
      this.recordsFiltered = data['recordsFiltered']
      this.recordsTotal = data['recordsTotal']
      this.totalTime = data['totalTime']
      if (data['data'] && data['data'].constructor === Array) {
        this.data = []
        for (let item of data['data']) this.data.push(CompanyData.fromJS(item))
      }
    }
  }

  static fromJS(data: any): DataTableResponseOfCompanyData {
    data = typeof data === 'object' ? data : {}
    let result = new DataTableResponseOfCompanyData()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['draw'] = this.draw
    data['recordsFiltered'] = this.recordsFiltered
    data['recordsTotal'] = this.recordsTotal
    data['totalTime'] = this.totalTime
    if (this.data && this.data.constructor === Array) {
      data['data'] = []
      for (let item of this.data) data['data'].push(item.toJSON())
    }
    return data
  }
}

export interface IDataTableResponseOfCompanyData {
  draw: number
  recordsFiltered: number
  recordsTotal: number
  totalTime: number
  data?: CompanyData[]
}

export class CompanySearchResponse extends DataTableResponseOfCompanyData
  implements ICompanySearchResponse {
  constructor(data?: ICompanySearchResponse) {
    super(data)
  }

  init(data?: any) {
    super.init(data)
    if (data) {
    }
  }

  static fromJS(data: any): CompanySearchResponse {
    data = typeof data === 'object' ? data : {}
    let result = new CompanySearchResponse()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    super.toJSON(data)
    return data
  }
}

export interface ICompanySearchResponse
  extends IDataTableResponseOfCompanyData {}

export class CompanyData implements ICompanyData {
  companyRegNumber?: string
  companyName?: string
  Client_Logo?: string
  companyid: number
  commercialStatusCode?: string
  businessStartDate: Date

  constructor(data?: ICompanyData) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.companyRegNumber = data['companyRegNumber']
      this.companyName = data['companyName']
      this.Client_Logo = data['Client_Logo']
      this.companyid = data['companyid']
      this.commercialStatusCode = data['commercialStatusCode']
      this.businessStartDate = data['businessStartDate']
        ? new Date(data['businessStartDate'].toString())
        : <any>undefined
    }
  }

  static fromJS(data: any): CompanyData {
    data = typeof data === 'object' ? data : {}
    let result = new CompanyData()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['companyRegNumber'] = this.companyRegNumber
    data['companyName'] = this.companyName
    data['Client_Logo'] = this.Client_Logo
    data['companyid'] = this.companyid
    data['commercialStatusCode'] = this.commercialStatusCode
    data['businessStartDate'] = this.businessStartDate
      ? this.businessStartDate.toISOString()
      : <any>undefined
    return data
  }
}

export interface ICompanyData {
  companyRegNumber?: string
  companyName?: string
  Client_Logo?: string
  companyid: number
  commercialStatusCode?: string
  businessStartDate: Date
}

export class AddressSearchRequest implements IAddressSearchRequest {
  address1?: string
  address2?: string
  address3?: string
  address4?: string
  postalCode?: string
  isTrailuser?: boolean

  constructor(data?: IAddressSearchRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.address1 = data['address1']
      this.address2 = data['address2']
      this.address3 = data['address3']
      this.address4 = data['address4']
      this.postalCode = data['postalCode']
      this.isTrailuser = data['isTrailuser']
    }
  }

  static fromJS(data: any): AddressSearchRequest {
    data = typeof data === 'object' ? data : {}
    let result = new AddressSearchRequest()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['address1'] = this.address1
    data['address2'] = this.address2
    data['address3'] = this.address3
    data['address4'] = this.address4
    data['postalCode'] = this.postalCode
    data['isTrailuser'] = this.isTrailuser
    return data
  }
}

export interface IAddressSearchRequest {
  address1?: string
  address2?: string
  address3?: string
  address4?: string
  postalCode?: string
  isTrailuser?: boolean
}

export class DataTableResponseOfAddressData
  implements IDataTableResponseOfAddressData {
  draw: number
  recordsFiltered: number
  recordsTotal: number
  totalTime: number
  data?: AddressData[]

  constructor(data?: IDataTableResponseOfAddressData) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.draw = data['draw']
      this.recordsFiltered = data['recordsFiltered']
      this.recordsTotal = data['recordsTotal']
      this.totalTime = data['totalTime']
      if (data['data'] && data['data'].constructor === Array) {
        this.data = []
        for (let item of data['data']) this.data.push(AddressData.fromJS(item))
      }
    }
  }

  static fromJS(data: any): DataTableResponseOfAddressData {
    data = typeof data === 'object' ? data : {}
    let result = new DataTableResponseOfAddressData()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['draw'] = this.draw
    data['recordsFiltered'] = this.recordsFiltered
    data['recordsTotal'] = this.recordsTotal
    data['totalTime'] = this.totalTime
    if (this.data && this.data.constructor === Array) {
      data['data'] = []
      for (let item of this.data) data['data'].push(item.toJSON())
    }
    return data
  }
}

export interface IDataTableResponseOfAddressData {
  draw: number
  recordsFiltered: number
  recordsTotal: number
  totalTime: number
  data?: AddressData[]
}

export class AddressSearchResponse extends DataTableResponseOfAddressData
  implements IAddressSearchResponse {
  constructor(data?: IAddressSearchResponse) {
    super(data)
  }

  init(data?: any) {
    super.init(data)
    if (data) {
    }
  }

  static fromJS(data: any): AddressSearchResponse {
    data = typeof data === 'object' ? data : {}
    let result = new AddressSearchResponse()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    super.toJSON(data)
    return data
  }
}

export interface IAddressSearchResponse
  extends IDataTableResponseOfAddressData {}

export class AddressData implements IAddressData {
  addressId?: string
  address?: string

  constructor(data?: IAddressData) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.addressId = data['addressId']
      this.address = data['address']
    }
  }

  static fromJS(data: any): AddressData {
    data = typeof data === 'object' ? data : {}
    let result = new AddressData()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['addressId'] = this.addressId
    data['address'] = this.address
    return data
  }
}

export interface IAddressData {
  addressId?: string
  address?: string
}

export interface FileResponse {
  data: Blob
  status: number
  fileName?: string
  headers?: { [name: string]: any }
}

export class SwaggerException extends Error {
  message: string
  status: number
  response: string
  headers: { [key: string]: any }
  result: any

  constructor(
    message: string,
    status: number,
    response: string,
    headers: { [key: string]: any },
    result: any,
  ) {
    super()

    this.message = message
    this.status = status
    this.response = response
    this.headers = headers
    this.result = result
  }

  protected isSwaggerException = true

  static isSwaggerException(obj: any): obj is SwaggerException {
    return obj.isSwaggerException === true
  }
}

function throwException(
  message: string,
  status: number,
  response: string,
  headers: { [key: string]: any },
  result?: any,
): Observable<any> {
  if (result !== null && result !== undefined) return Observable.throw(result)
  else
    return Observable.throw(
      new SwaggerException(message, status, response, headers, null),
    )
}

function blobToText(blob: any): Observable<string> {
  return new Observable<string>((observer: any) => {
    if (!blob) {
      observer.next('')
      observer.complete()
    } else {
      let reader = new FileReader()
      reader.onload = function () {
        observer.next(this.result)
        observer.complete()
      }
      reader.readAsText(blob)
    }
  })
}
