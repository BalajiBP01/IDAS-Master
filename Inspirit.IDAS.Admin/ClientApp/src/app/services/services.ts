/* tslint:disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v11.18.5.0 (NJsonSchema v9.10.67.0 (Newtonsoft.Json v9.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import 'rxjs/add/observable/fromPromise'
import 'rxjs/add/observable/of'
import 'rxjs/add/observable/throw'
import 'rxjs/add/operator/map'
import 'rxjs/add/operator/toPromise'
import 'rxjs/add/operator/mergeMap'
import 'rxjs/add/operator/catch'

import { Observable } from 'rxjs/Observable'
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core'
import {
  HttpClient,
  HttpHeaders,
  HttpResponse,
  HttpResponseBase,
} from '@angular/common/http'

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL')

@Injectable()
export class AppSettingService {
  private http: HttpClient
  private baseUrl: string
  protected jsonParseReviver: (key: string, value: any) => any = undefined

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string,
  ) {
    this.http = http
    this.baseUrl = baseUrl ? baseUrl : ''
  }

  settingDataList(request: DataTableRequest): Observable<SettingDataResponse> {
    let url_ = this.baseUrl + '/api/AppSetting/SettingDataList'
    url_ = url_.replace(/[?&]$/, '')

    const content_ = JSON.stringify(request)

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('post', url_, options_)
      .flatMap((response_: any) => {
        return this.processSettingDataList(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processSettingDataList(<any>response_)
          } catch (e) {
            return <Observable<SettingDataResponse>>(<any>Observable.throw(e))
          }
        } else
          return <Observable<SettingDataResponse>>(
            (<any>Observable.throw(response_))
          )
      })
  }

  protected processSettingDataList(
    response: HttpResponseBase,
  ): Observable<SettingDataResponse> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = resultData200
          ? SettingDataResponse.fromJS(resultData200)
          : <any>null
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<SettingDataResponse>(<any>null)
  }

  insert(request: ApplicationSetting): Observable<SettingCrudResponse> {
    let url_ = this.baseUrl + '/api/AppSetting/Insert'
    url_ = url_.replace(/[?&]$/, '')

    const content_ = JSON.stringify(request)

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('post', url_, options_)
      .flatMap((response_: any) => {
        return this.processInsert(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processInsert(<any>response_)
          } catch (e) {
            return <Observable<SettingCrudResponse>>(<any>Observable.throw(e))
          }
        } else
          return <Observable<SettingCrudResponse>>(
            (<any>Observable.throw(response_))
          )
      })
  }

  protected processInsert(
    response: HttpResponseBase,
  ): Observable<SettingCrudResponse> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = resultData200
          ? SettingCrudResponse.fromJS(resultData200)
          : <any>null
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<SettingCrudResponse>(<any>null)
  }

  update(request: ApplicationSetting): Observable<SettingCrudResponse> {
    let url_ = this.baseUrl + '/api/AppSetting/Update'
    url_ = url_.replace(/[?&]$/, '')

    const content_ = JSON.stringify(request)

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('post', url_, options_)
      .flatMap((response_: any) => {
        return this.processUpdate(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processUpdate(<any>response_)
          } catch (e) {
            return <Observable<SettingCrudResponse>>(<any>Observable.throw(e))
          }
        } else
          return <Observable<SettingCrudResponse>>(
            (<any>Observable.throw(response_))
          )
      })
  }

  protected processUpdate(
    response: HttpResponseBase,
  ): Observable<SettingCrudResponse> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = resultData200
          ? SettingCrudResponse.fromJS(resultData200)
          : <any>null
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<SettingCrudResponse>(<any>null)
  }

  view(id: string): Observable<ApplicationSetting> {
    let url_ = this.baseUrl + '/api/AppSetting/View?'
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined and cannot be null.")
    else url_ += 'id=' + encodeURIComponent('' + id) + '&'
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('post', url_, options_)
      .flatMap((response_: any) => {
        return this.processView(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processView(<any>response_)
          } catch (e) {
            return <Observable<ApplicationSetting>>(<any>Observable.throw(e))
          }
        } else
          return <Observable<ApplicationSetting>>(
            (<any>Observable.throw(response_))
          )
      })
  }

  protected processView(
    response: HttpResponseBase,
  ): Observable<ApplicationSetting> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = resultData200
          ? ApplicationSetting.fromJS(resultData200)
          : <any>null
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<ApplicationSetting>(<any>null)
  }
}

@Injectable()
export class BatchTracingService {
  private http: HttpClient
  private baseUrl: string
  protected jsonParseReviver: (key: string, value: any) => any = undefined

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string,
  ) {
    this.http = http
    this.baseUrl = baseUrl ? baseUrl : ''
  }

  getBatchTrace(
    request: BatchDataTableRequest,
  ): Observable<BatchTracingDataTableResponse> {
    let url_ = this.baseUrl + '/api/BatchTracing/GetBatchTrace'
    url_ = url_.replace(/[?&]$/, '')

    const content_ = JSON.stringify(request)

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('post', url_, options_)
      .flatMap((response_: any) => {
        return this.processGetBatchTrace(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processGetBatchTrace(<any>response_)
          } catch (e) {
            return <Observable<BatchTracingDataTableResponse>>(
              (<any>Observable.throw(e))
            )
          }
        } else
          return <Observable<BatchTracingDataTableResponse>>(
            (<any>Observable.throw(response_))
          )
      })
  }

  protected processGetBatchTrace(
    response: HttpResponseBase,
  ): Observable<BatchTracingDataTableResponse> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = resultData200
          ? BatchTracingDataTableResponse.fromJS(resultData200)
          : <any>null
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<BatchTracingDataTableResponse>(<any>null)
  }

  updateBatchTrace(batchId: string, c: string): Observable<BatchtraceResponse> {
    let url_ = this.baseUrl + '/api/BatchTracing/UpdateBatchTrace?'
    if (batchId === undefined || batchId === null)
      throw new Error(
        "The parameter 'batchId' must be defined and cannot be null.",
      )
    else url_ += 'BatchId=' + encodeURIComponent('' + batchId) + '&'
    if (c === undefined || c === null)
      throw new Error("The parameter 'c' must be defined and cannot be null.")
    else url_ += 'c=' + encodeURIComponent('' + c) + '&'
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('get', url_, options_)
      .flatMap((response_: any) => {
        return this.processUpdateBatchTrace(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processUpdateBatchTrace(<any>response_)
          } catch (e) {
            return <Observable<BatchtraceResponse>>(<any>Observable.throw(e))
          }
        } else
          return <Observable<BatchtraceResponse>>(
            (<any>Observable.throw(response_))
          )
      })
  }

  protected processUpdateBatchTrace(
    response: HttpResponseBase,
  ): Observable<BatchtraceResponse> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = resultData200
          ? BatchtraceResponse.fromJS(resultData200)
          : <any>null
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<BatchtraceResponse>(<any>null)
  }

  removeBatchTrace(iD: string): Observable<string> {
    let url_ = this.baseUrl + '/api/BatchTracing/RemoveBatchTrace?'
    if (iD === undefined || iD === null)
      throw new Error("The parameter 'iD' must be defined and cannot be null.")
    else url_ += 'ID=' + encodeURIComponent('' + iD) + '&'
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('get', url_, options_)
      .flatMap((response_: any) => {
        return this.processRemoveBatchTrace(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processRemoveBatchTrace(<any>response_)
          } catch (e) {
            return <Observable<string>>(<any>Observable.throw(e))
          }
        } else return <Observable<string>>(<any>Observable.throw(response_))
      })
  }

  protected processRemoveBatchTrace(
    response: HttpResponseBase,
  ): Observable<string> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = resultData200 !== undefined ? resultData200 : <any>null
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<string>(<any>null)
  }

  downloadExcel(id: string): Observable<FileResponse> {
    let url_ = this.baseUrl + '/api/BatchTracing/DownloadExcel?'
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined and cannot be null.")
    else url_ += 'id=' + encodeURIComponent('' + id) + '&'
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('get', url_, options_)
      .flatMap((response_: any) => {
        return this.processDownloadExcel(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processDownloadExcel(<any>response_)
          } catch (e) {
            return <Observable<FileResponse>>(<any>Observable.throw(e))
          }
        } else
          return <Observable<FileResponse>>(<any>Observable.throw(response_))
      })
  }

  protected processDownloadExcel(
    response: HttpResponseBase,
  ): Observable<FileResponse> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers
        ? response.headers.get('content-disposition')
        : undefined
      const fileNameMatch = contentDisposition
        ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
        : undefined
      const fileName =
        fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined
      return Observable.of({
        fileName: fileName,
        data: <any>responseBlob,
        status: status,
        headers: _headers,
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<FileResponse>(<any>null)
  }
}

@Injectable()
export class ContactusService {
  private http: HttpClient
  private baseUrl: string
  protected jsonParseReviver: (key: string, value: any) => any = undefined

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string,
  ) {
    this.http = http
    this.baseUrl = baseUrl ? baseUrl : ''
  }

  contactusList(
    request: ContactUsSearchRequest,
  ): Observable<ContactusResponse> {
    let url_ = this.baseUrl + '/api/Contactus/ContactusList'
    url_ = url_.replace(/[?&]$/, '')

    const content_ = JSON.stringify(request)

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('post', url_, options_)
      .flatMap((response_: any) => {
        return this.processContactusList(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processContactusList(<any>response_)
          } catch (e) {
            return <Observable<ContactusResponse>>(<any>Observable.throw(e))
          }
        } else
          return <Observable<ContactusResponse>>(
            (<any>Observable.throw(response_))
          )
      })
  }

  protected processContactusList(
    response: HttpResponseBase,
  ): Observable<ContactusResponse> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = resultData200
          ? ContactusResponse.fromJS(resultData200)
          : <any>null
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<ContactusResponse>(<any>null)
  }

  view(id: string): Observable<ContactUs> {
    let url_ = this.baseUrl + '/api/Contactus/View?'
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined and cannot be null.")
    else url_ += 'id=' + encodeURIComponent('' + id) + '&'
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('post', url_, options_)
      .flatMap((response_: any) => {
        return this.processView(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processView(<any>response_)
          } catch (e) {
            return <Observable<ContactUs>>(<any>Observable.throw(e))
          }
        } else return <Observable<ContactUs>>(<any>Observable.throw(response_))
      })
  }

  protected processView(response: HttpResponseBase): Observable<ContactUs> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = resultData200 ? ContactUs.fromJS(resultData200) : <any>null
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<ContactUs>(<any>null)
  }

  updateReadStatus(req: ContactUs): Observable<ContactusResponse> {
    let url_ = this.baseUrl + '/api/Contactus/UpdateReadStatus'
    url_ = url_.replace(/[?&]$/, '')

    const content_ = JSON.stringify(req)

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('post', url_, options_)
      .flatMap((response_: any) => {
        return this.processUpdateReadStatus(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processUpdateReadStatus(<any>response_)
          } catch (e) {
            return <Observable<ContactusResponse>>(<any>Observable.throw(e))
          }
        } else
          return <Observable<ContactusResponse>>(
            (<any>Observable.throw(response_))
          )
      })
  }

  protected processUpdateReadStatus(
    response: HttpResponseBase,
  ): Observable<ContactusResponse> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = resultData200
          ? ContactusResponse.fromJS(resultData200)
          : <any>null
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<ContactusResponse>(<any>null)
  }
}

@Injectable()
export class ApplicationMessageService {
  private http: HttpClient
  private baseUrl: string
  protected jsonParseReviver: (key: string, value: any) => any = undefined

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string,
  ) {
    this.http = http
    this.baseUrl = baseUrl ? baseUrl : ''
  }

  applicationMessageList(
    request: DataTableRequest,
  ): Observable<ApplicationmessageResponse> {
    let url_ = this.baseUrl + '/api/ApplicationMessage/ApplicationMessageList'
    url_ = url_.replace(/[?&]$/, '')

    const content_ = JSON.stringify(request)

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('post', url_, options_)
      .flatMap((response_: any) => {
        return this.processApplicationMessageList(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processApplicationMessageList(<any>response_)
          } catch (e) {
            return <Observable<ApplicationmessageResponse>>(
              (<any>Observable.throw(e))
            )
          }
        } else
          return <Observable<ApplicationmessageResponse>>(
            (<any>Observable.throw(response_))
          )
      })
  }

  protected processApplicationMessageList(
    response: HttpResponseBase,
  ): Observable<ApplicationmessageResponse> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = resultData200
          ? ApplicationmessageResponse.fromJS(resultData200)
          : <any>null
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<ApplicationmessageResponse>(<any>null)
  }

  insert(request: ApplicationMessage): Observable<CrudResponseMessage> {
    let url_ = this.baseUrl + '/api/ApplicationMessage/Insert'
    url_ = url_.replace(/[?&]$/, '')

    const content_ = JSON.stringify(request)

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('post', url_, options_)
      .flatMap((response_: any) => {
        return this.processInsert(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processInsert(<any>response_)
          } catch (e) {
            return <Observable<CrudResponseMessage>>(<any>Observable.throw(e))
          }
        } else
          return <Observable<CrudResponseMessage>>(
            (<any>Observable.throw(response_))
          )
      })
  }

  protected processInsert(
    response: HttpResponseBase,
  ): Observable<CrudResponseMessage> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = resultData200
          ? CrudResponseMessage.fromJS(resultData200)
          : <any>null
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<CrudResponseMessage>(<any>null)
  }

  update(request: ApplicationMessage): Observable<CrudResponseMessage> {
    let url_ = this.baseUrl + '/api/ApplicationMessage/Update'
    url_ = url_.replace(/[?&]$/, '')

    const content_ = JSON.stringify(request)

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('post', url_, options_)
      .flatMap((response_: any) => {
        return this.processUpdate(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processUpdate(<any>response_)
          } catch (e) {
            return <Observable<CrudResponseMessage>>(<any>Observable.throw(e))
          }
        } else
          return <Observable<CrudResponseMessage>>(
            (<any>Observable.throw(response_))
          )
      })
  }

  protected processUpdate(
    response: HttpResponseBase,
  ): Observable<CrudResponseMessage> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = resultData200
          ? CrudResponseMessage.fromJS(resultData200)
          : <any>null
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<CrudResponseMessage>(<any>null)
  }

  delete(id: string): Observable<CrudResponseMessage> {
    let url_ = this.baseUrl + '/api/ApplicationMessage/Delete?'
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined and cannot be null.")
    else url_ += 'id=' + encodeURIComponent('' + id) + '&'
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('post', url_, options_)
      .flatMap((response_: any) => {
        return this.processDelete(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processDelete(<any>response_)
          } catch (e) {
            return <Observable<CrudResponseMessage>>(<any>Observable.throw(e))
          }
        } else
          return <Observable<CrudResponseMessage>>(
            (<any>Observable.throw(response_))
          )
      })
  }

  protected processDelete(
    response: HttpResponseBase,
  ): Observable<CrudResponseMessage> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = resultData200
          ? CrudResponseMessage.fromJS(resultData200)
          : <any>null
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<CrudResponseMessage>(<any>null)
  }

  view(id: string): Observable<ApplicationMessage> {
    let url_ = this.baseUrl + '/api/ApplicationMessage/View?'
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined and cannot be null.")
    else url_ += 'id=' + encodeURIComponent('' + id) + '&'
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('post', url_, options_)
      .flatMap((response_: any) => {
        return this.processView(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processView(<any>response_)
          } catch (e) {
            return <Observable<ApplicationMessage>>(<any>Observable.throw(e))
          }
        } else
          return <Observable<ApplicationMessage>>(
            (<any>Observable.throw(response_))
          )
      })
  }

  protected processView(
    response: HttpResponseBase,
  ): Observable<ApplicationMessage> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = resultData200
          ? ApplicationMessage.fromJS(resultData200)
          : <any>null
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<ApplicationMessage>(<any>null)
  }
}

@Injectable()
export class CustomerUserService {
  private http: HttpClient
  private baseUrl: string
  protected jsonParseReviver: (key: string, value: any) => any = undefined

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string,
  ) {
    this.http = http
    this.baseUrl = baseUrl ? baseUrl : ''
  }

  customerUserList(
    request: CustomerUserRequest,
  ): Observable<CustomerUserResponse> {
    let url_ = this.baseUrl + '/api/CustomerUser/CustomerUserList'
    url_ = url_.replace(/[?&]$/, '')

    const content_ = JSON.stringify(request)

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('post', url_, options_)
      .flatMap((response_: any) => {
        return this.processCustomerUserList(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processCustomerUserList(<any>response_)
          } catch (e) {
            return <Observable<CustomerUserResponse>>(<any>Observable.throw(e))
          }
        } else
          return <Observable<CustomerUserResponse>>(
            (<any>Observable.throw(response_))
          )
      })
  }

  protected processCustomerUserList(
    response: HttpResponseBase,
  ): Observable<CustomerUserResponse> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = resultData200
          ? CustomerUserResponse.fromJS(resultData200)
          : <any>null
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<CustomerUserResponse>(<any>null)
  }

  insert(request: CustomerUserVM): Observable<CrudUserResponse> {
    let url_ = this.baseUrl + '/api/CustomerUser/Insert'
    url_ = url_.replace(/[?&]$/, '')

    const content_ = JSON.stringify(request)

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('post', url_, options_)
      .flatMap((response_: any) => {
        return this.processInsert(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processInsert(<any>response_)
          } catch (e) {
            return <Observable<CrudUserResponse>>(<any>Observable.throw(e))
          }
        } else
          return <Observable<CrudUserResponse>>(
            (<any>Observable.throw(response_))
          )
      })
  }

  protected processInsert(
    response: HttpResponseBase,
  ): Observable<CrudUserResponse> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = resultData200
          ? CrudUserResponse.fromJS(resultData200)
          : <any>null
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<CrudUserResponse>(<any>null)
  }

  update(request: CustomerUserVM): Observable<CrudUserResponse> {
    let url_ = this.baseUrl + '/api/CustomerUser/Update'
    url_ = url_.replace(/[?&]$/, '')

    const content_ = JSON.stringify(request)

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('post', url_, options_)
      .flatMap((response_: any) => {
        return this.processUpdate(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processUpdate(<any>response_)
          } catch (e) {
            return <Observable<CrudUserResponse>>(<any>Observable.throw(e))
          }
        } else
          return <Observable<CrudUserResponse>>(
            (<any>Observable.throw(response_))
          )
      })
  }

  protected processUpdate(
    response: HttpResponseBase,
  ): Observable<CrudUserResponse> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = resultData200
          ? CrudUserResponse.fromJS(resultData200)
          : <any>null
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<CrudUserResponse>(<any>null)
  }

  delete(id: string): Observable<CrudUserResponse> {
    let url_ = this.baseUrl + '/api/CustomerUser/Delete?'
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined and cannot be null.")
    else url_ += 'id=' + encodeURIComponent('' + id) + '&'
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('post', url_, options_)
      .flatMap((response_: any) => {
        return this.processDelete(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processDelete(<any>response_)
          } catch (e) {
            return <Observable<CrudUserResponse>>(<any>Observable.throw(e))
          }
        } else
          return <Observable<CrudUserResponse>>(
            (<any>Observable.throw(response_))
          )
      })
  }

  protected processDelete(
    response: HttpResponseBase,
  ): Observable<CrudUserResponse> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = resultData200
          ? CrudUserResponse.fromJS(resultData200)
          : <any>null
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<CrudUserResponse>(<any>null)
  }

  view(id: string): Observable<CustomerUserVM> {
    let url_ = this.baseUrl + '/api/CustomerUser/View?'
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined and cannot be null.")
    else url_ += 'id=' + encodeURIComponent('' + id) + '&'
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('post', url_, options_)
      .flatMap((response_: any) => {
        return this.processView(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processView(<any>response_)
          } catch (e) {
            return <Observable<CustomerUserVM>>(<any>Observable.throw(e))
          }
        } else
          return <Observable<CustomerUserVM>>(<any>Observable.throw(response_))
      })
  }

  protected processView(
    response: HttpResponseBase,
  ): Observable<CustomerUserVM> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = resultData200
          ? CustomerUserVM.fromJS(resultData200)
          : <any>null
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<CustomerUserVM>(<any>null)
  }

  updateStatus(cust: CustomerUserVM): Observable<CustomerCrudResponse> {
    let url_ = this.baseUrl + '/api/CustomerUser/UpdateStatus'
    url_ = url_.replace(/[?&]$/, '')

    const content_ = JSON.stringify(cust)

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('post', url_, options_)
      .flatMap((response_: any) => {
        return this.processUpdateStatus(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processUpdateStatus(<any>response_)
          } catch (e) {
            return <Observable<CustomerCrudResponse>>(<any>Observable.throw(e))
          }
        } else
          return <Observable<CustomerCrudResponse>>(
            (<any>Observable.throw(response_))
          )
      })
  }

  protected processUpdateStatus(
    response: HttpResponseBase,
  ): Observable<CustomerCrudResponse> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = resultData200
          ? CustomerCrudResponse.fromJS(resultData200)
          : <any>null
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<CustomerCrudResponse>(<any>null)
  }
}

@Injectable()
export class DashboardService {
  private http: HttpClient
  private baseUrl: string
  protected jsonParseReviver: (key: string, value: any) => any = undefined

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string,
  ) {
    this.http = http
    this.baseUrl = baseUrl ? baseUrl : ''
  }

  getCustCount(): Observable<CustomerCount> {
    let url_ = this.baseUrl + '/api/Dashboard/GetCustCount'
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('get', url_, options_)
      .flatMap((response_: any) => {
        return this.processGetCustCount(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processGetCustCount(<any>response_)
          } catch (e) {
            return <Observable<CustomerCount>>(<any>Observable.throw(e))
          }
        } else
          return <Observable<CustomerCount>>(<any>Observable.throw(response_))
      })
  }

  protected processGetCustCount(
    response: HttpResponseBase,
  ): Observable<CustomerCount> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = resultData200
          ? CustomerCount.fromJS(resultData200)
          : <any>null
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<CustomerCount>(<any>null)
  }

  getCustuserCount(): Observable<CustomerUserCount> {
    let url_ = this.baseUrl + '/api/Dashboard/GetCustuserCount'
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('get', url_, options_)
      .flatMap((response_: any) => {
        return this.processGetCustuserCount(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processGetCustuserCount(<any>response_)
          } catch (e) {
            return <Observable<CustomerUserCount>>(<any>Observable.throw(e))
          }
        } else
          return <Observable<CustomerUserCount>>(
            (<any>Observable.throw(response_))
          )
      })
  }

  protected processGetCustuserCount(
    response: HttpResponseBase,
  ): Observable<CustomerUserCount> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = resultData200
          ? CustomerUserCount.fromJS(resultData200)
          : <any>null
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<CustomerUserCount>(<any>null)
  }

  getDonotCallCount(): Observable<DonotCallRegCount> {
    let url_ = this.baseUrl + '/api/Dashboard/GetDonotCallCount'
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('get', url_, options_)
      .flatMap((response_: any) => {
        return this.processGetDonotCallCount(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processGetDonotCallCount(<any>response_)
          } catch (e) {
            return <Observable<DonotCallRegCount>>(<any>Observable.throw(e))
          }
        } else
          return <Observable<DonotCallRegCount>>(
            (<any>Observable.throw(response_))
          )
      })
  }

  protected processGetDonotCallCount(
    response: HttpResponseBase,
  ): Observable<DonotCallRegCount> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = resultData200
          ? DonotCallRegCount.fromJS(resultData200)
          : <any>null
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<DonotCallRegCount>(<any>null)
  }

  customerLog(): Observable<CustomerLog[]> {
    let url_ = this.baseUrl + '/api/Dashboard/CustomerLog'
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('get', url_, options_)
      .flatMap((response_: any) => {
        return this.processCustomerLog(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processCustomerLog(<any>response_)
          } catch (e) {
            return <Observable<CustomerLog[]>>(<any>Observable.throw(e))
          }
        } else
          return <Observable<CustomerLog[]>>(<any>Observable.throw(response_))
      })
  }

  protected processCustomerLog(
    response: HttpResponseBase,
  ): Observable<CustomerLog[]> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        if (resultData200 && resultData200.constructor === Array) {
          result200 = []
          for (let item of resultData200)
            result200.push(CustomerLog.fromJS(item))
        }
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<CustomerLog[]>(<any>null)
  }

  getContactus(): Observable<ContactUsCount> {
    let url_ = this.baseUrl + '/api/Dashboard/GetContactus'
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('get', url_, options_)
      .flatMap((response_: any) => {
        return this.processGetContactus(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processGetContactus(<any>response_)
          } catch (e) {
            return <Observable<ContactUsCount>>(<any>Observable.throw(e))
          }
        } else
          return <Observable<ContactUsCount>>(<any>Observable.throw(response_))
      })
  }

  protected processGetContactus(
    response: HttpResponseBase,
  ): Observable<ContactUsCount> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = resultData200
          ? ContactUsCount.fromJS(resultData200)
          : <any>null
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<ContactUsCount>(<any>null)
  }

  getPaymentdetail(): Observable<PaymentCount> {
    let url_ = this.baseUrl + '/api/Dashboard/GetPaymentdetail'
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('get', url_, options_)
      .flatMap((response_: any) => {
        return this.processGetPaymentdetail(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processGetPaymentdetail(<any>response_)
          } catch (e) {
            return <Observable<PaymentCount>>(<any>Observable.throw(e))
          }
        } else
          return <Observable<PaymentCount>>(<any>Observable.throw(response_))
      })
  }

  protected processGetPaymentdetail(
    response: HttpResponseBase,
  ): Observable<PaymentCount> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = resultData200
          ? PaymentCount.fromJS(resultData200)
          : <any>null
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<PaymentCount>(<any>null)
  }

  getInvoice(): Observable<InvoiceCount> {
    let url_ = this.baseUrl + '/api/Dashboard/GetInvoice'
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('get', url_, options_)
      .flatMap((response_: any) => {
        return this.processGetInvoice(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processGetInvoice(<any>response_)
          } catch (e) {
            return <Observable<InvoiceCount>>(<any>Observable.throw(e))
          }
        } else
          return <Observable<InvoiceCount>>(<any>Observable.throw(response_))
      })
  }

  protected processGetInvoice(
    response: HttpResponseBase,
  ): Observable<InvoiceCount> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = resultData200
          ? InvoiceCount.fromJS(resultData200)
          : <any>null
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<InvoiceCount>(<any>null)
  }

  getSubscriptiondet(): Observable<SubscriptionCount> {
    let url_ = this.baseUrl + '/api/Dashboard/GetSubscriptiondet'
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('get', url_, options_)
      .flatMap((response_: any) => {
        return this.processGetSubscriptiondet(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processGetSubscriptiondet(<any>response_)
          } catch (e) {
            return <Observable<SubscriptionCount>>(<any>Observable.throw(e))
          }
        } else
          return <Observable<SubscriptionCount>>(
            (<any>Observable.throw(response_))
          )
      })
  }

  protected processGetSubscriptiondet(
    response: HttpResponseBase,
  ): Observable<SubscriptionCount> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = resultData200
          ? SubscriptionCount.fromJS(resultData200)
          : <any>null
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<SubscriptionCount>(<any>null)
  }
}

@Injectable()
export class DsaService {
  private http: HttpClient
  private baseUrl: string
  protected jsonParseReviver: (key: string, value: any) => any = undefined

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string,
  ) {
    this.http = http
    this.baseUrl = baseUrl ? baseUrl : ''
  }

  insert(request: DataServicesAgreement): Observable<CrudDsaResponse> {
    let url_ = this.baseUrl + '/api/Dsa/Insert'
    url_ = url_.replace(/[?&]$/, '')

    const content_ = JSON.stringify(request)

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('post', url_, options_)
      .flatMap((response_: any) => {
        return this.processInsert(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processInsert(<any>response_)
          } catch (e) {
            return <Observable<CrudDsaResponse>>(<any>Observable.throw(e))
          }
        } else
          return <Observable<CrudDsaResponse>>(<any>Observable.throw(response_))
      })
  }

  protected processInsert(
    response: HttpResponseBase,
  ): Observable<CrudDsaResponse> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = resultData200
          ? CrudDsaResponse.fromJS(resultData200)
          : <any>null
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<CrudDsaResponse>(<any>null)
  }

  update(request: DataServicesAgreement): Observable<CrudDsaResponse> {
    let url_ = this.baseUrl + '/api/Dsa/Update'
    url_ = url_.replace(/[?&]$/, '')

    const content_ = JSON.stringify(request)

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('post', url_, options_)
      .flatMap((response_: any) => {
        return this.processUpdate(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processUpdate(<any>response_)
          } catch (e) {
            return <Observable<CrudDsaResponse>>(<any>Observable.throw(e))
          }
        } else
          return <Observable<CrudDsaResponse>>(<any>Observable.throw(response_))
      })
  }

  protected processUpdate(
    response: HttpResponseBase,
  ): Observable<CrudDsaResponse> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = resultData200
          ? CrudDsaResponse.fromJS(resultData200)
          : <any>null
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<CrudDsaResponse>(<any>null)
  }

  delete(id: string): Observable<CrudDsaResponse> {
    let url_ = this.baseUrl + '/api/Dsa/Delete?'
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined and cannot be null.")
    else url_ += 'id=' + encodeURIComponent('' + id) + '&'
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('post', url_, options_)
      .flatMap((response_: any) => {
        return this.processDelete(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processDelete(<any>response_)
          } catch (e) {
            return <Observable<CrudDsaResponse>>(<any>Observable.throw(e))
          }
        } else
          return <Observable<CrudDsaResponse>>(<any>Observable.throw(response_))
      })
  }

  protected processDelete(
    response: HttpResponseBase,
  ): Observable<CrudDsaResponse> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = resultData200
          ? CrudDsaResponse.fromJS(resultData200)
          : <any>null
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<CrudDsaResponse>(<any>null)
  }

  view(id: string): Observable<DataServicesAgreement> {
    let url_ = this.baseUrl + '/api/Dsa/View?'
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined and cannot be null.")
    else url_ += 'id=' + encodeURIComponent('' + id) + '&'
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('post', url_, options_)
      .flatMap((response_: any) => {
        return this.processView(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processView(<any>response_)
          } catch (e) {
            return <Observable<DataServicesAgreement>>(<any>Observable.throw(e))
          }
        } else
          return <Observable<DataServicesAgreement>>(
            (<any>Observable.throw(response_))
          )
      })
  }

  protected processView(
    response: HttpResponseBase,
  ): Observable<DataServicesAgreement> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = resultData200
          ? DataServicesAgreement.fromJS(resultData200)
          : <any>null
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<DataServicesAgreement>(<any>null)
  }

  uploadFile(): Observable<FileResponse> {
    let url_ = this.baseUrl + '/api/Dsa'
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('post', url_, options_)
      .flatMap((response_: any) => {
        return this.processUploadFile(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processUploadFile(<any>response_)
          } catch (e) {
            return <Observable<FileResponse>>(<any>Observable.throw(e))
          }
        } else
          return <Observable<FileResponse>>(<any>Observable.throw(response_))
      })
  }

  protected processUploadFile(
    response: HttpResponseBase,
  ): Observable<FileResponse> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers
        ? response.headers.get('content-disposition')
        : undefined
      const fileNameMatch = contentDisposition
        ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
        : undefined
      const fileName =
        fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined
      return Observable.of({
        fileName: fileName,
        data: <any>responseBlob,
        status: status,
        headers: _headers,
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<FileResponse>(<any>null)
  }

  getDsaTableList(request: DataTableRequest): Observable<DsaResponse> {
    let url_ = this.baseUrl + '/api/Dsa/GetDsaTableList'
    url_ = url_.replace(/[?&]$/, '')

    const content_ = JSON.stringify(request)

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('post', url_, options_)
      .flatMap((response_: any) => {
        return this.processGetDsaTableList(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processGetDsaTableList(<any>response_)
          } catch (e) {
            return <Observable<DsaResponse>>(<any>Observable.throw(e))
          }
        } else
          return <Observable<DsaResponse>>(<any>Observable.throw(response_))
      })
  }

  protected processGetDsaTableList(
    response: HttpResponseBase,
  ): Observable<DsaResponse> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = resultData200
          ? DsaResponse.fromJS(resultData200)
          : <any>null
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<DsaResponse>(<any>null)
  }

  downloadPdf(fileName: string): Observable<FileResponse> {
    let url_ = this.baseUrl + '/api/Dsa/DownloadPdf?'
    if (fileName === undefined)
      throw new Error("The parameter 'fileName' must be defined.")
    else url_ += 'fileName=' + encodeURIComponent('' + fileName) + '&'
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('get', url_, options_)
      .flatMap((response_: any) => {
        return this.processDownloadPdf(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processDownloadPdf(<any>response_)
          } catch (e) {
            return <Observable<FileResponse>>(<any>Observable.throw(e))
          }
        } else
          return <Observable<FileResponse>>(<any>Observable.throw(response_))
      })
  }

  protected processDownloadPdf(
    response: HttpResponseBase,
  ): Observable<FileResponse> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers
        ? response.headers.get('content-disposition')
        : undefined
      const fileNameMatch = contentDisposition
        ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
        : undefined
      const fileName =
        fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined
      return Observable.of({
        fileName: fileName,
        data: <any>responseBlob,
        status: status,
        headers: _headers,
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<FileResponse>(<any>null)
  }
}

@Injectable()
export class LeadGenerationService {
  private http: HttpClient
  private baseUrl: string
  protected jsonParseReviver: (key: string, value: any) => any = undefined

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string,
  ) {
    this.http = http
    this.baseUrl = baseUrl ? baseUrl : ''
  }

  getLeadList(
    request: LeadDataTableRequest,
  ): Observable<LeadDataTableResponse> {
    let url_ = this.baseUrl + '/api/LeadGeneration/GetLeadList'
    url_ = url_.replace(/[?&]$/, '')

    const content_ = JSON.stringify(request)

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('post', url_, options_)
      .flatMap((response_: any) => {
        return this.processGetLeadList(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processGetLeadList(<any>response_)
          } catch (e) {
            return <Observable<LeadDataTableResponse>>(<any>Observable.throw(e))
          }
        } else
          return <Observable<LeadDataTableResponse>>(
            (<any>Observable.throw(response_))
          )
      })
  }

  protected processGetLeadList(
    response: HttpResponseBase,
  ): Observable<LeadDataTableResponse> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = resultData200
          ? LeadDataTableResponse.fromJS(resultData200)
          : <any>null
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<LeadDataTableResponse>(<any>null)
  }

  updateLead(leadId: string, adminId: string): Observable<LeadResponse> {
    let url_ = this.baseUrl + '/api/LeadGeneration/UpdateLead?'
    if (leadId === undefined || leadId === null)
      throw new Error(
        "The parameter 'leadId' must be defined and cannot be null.",
      )
    else url_ += 'LeadId=' + encodeURIComponent('' + leadId) + '&'
    if (adminId === undefined || adminId === null)
      throw new Error(
        "The parameter 'adminId' must be defined and cannot be null.",
      )
    else url_ += 'AdminId=' + encodeURIComponent('' + adminId) + '&'
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('get', url_, options_)
      .flatMap((response_: any) => {
        return this.processUpdateLead(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processUpdateLead(<any>response_)
          } catch (e) {
            return <Observable<LeadResponse>>(<any>Observable.throw(e))
          }
        } else
          return <Observable<LeadResponse>>(<any>Observable.throw(response_))
      })
  }

  protected processUpdateLead(
    response: HttpResponseBase,
  ): Observable<LeadResponse> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = resultData200
          ? LeadResponse.fromJS(resultData200)
          : <any>null
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<LeadResponse>(<any>null)
  }

  removeLeads(iD: string): Observable<string> {
    let url_ = this.baseUrl + '/api/LeadGeneration/RemoveLeads?'
    if (iD === undefined || iD === null)
      throw new Error("The parameter 'iD' must be defined and cannot be null.")
    else url_ += 'ID=' + encodeURIComponent('' + iD) + '&'
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('get', url_, options_)
      .flatMap((response_: any) => {
        return this.processRemoveLeads(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processRemoveLeads(<any>response_)
          } catch (e) {
            return <Observable<string>>(<any>Observable.throw(e))
          }
        } else return <Observable<string>>(<any>Observable.throw(response_))
      })
  }

  protected processRemoveLeads(response: HttpResponseBase): Observable<string> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = resultData200 !== undefined ? resultData200 : <any>null
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<string>(<any>null)
  }

  downloadExcel(id: string): Observable<FileResponse> {
    let url_ = this.baseUrl + '/api/LeadGeneration/DownloadExcel?'
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined and cannot be null.")
    else url_ += 'id=' + encodeURIComponent('' + id) + '&'
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('get', url_, options_)
      .flatMap((response_: any) => {
        return this.processDownloadExcel(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processDownloadExcel(<any>response_)
          } catch (e) {
            return <Observable<FileResponse>>(<any>Observable.throw(e))
          }
        } else
          return <Observable<FileResponse>>(<any>Observable.throw(response_))
      })
  }

  protected processDownloadExcel(
    response: HttpResponseBase,
  ): Observable<FileResponse> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers
        ? response.headers.get('content-disposition')
        : undefined
      const fileNameMatch = contentDisposition
        ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
        : undefined
      const fileName =
        fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined
      return Observable.of({
        fileName: fileName,
        data: <any>responseBlob,
        status: status,
        headers: _headers,
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<FileResponse>(<any>null)
  }
}

@Injectable()
export class NewsService {
  private http: HttpClient
  private baseUrl: string
  protected jsonParseReviver: (key: string, value: any) => any = undefined

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string,
  ) {
    this.http = http
    this.baseUrl = baseUrl ? baseUrl : ''
  }

  getNewsList(request: DataTableRequest): Observable<NewsDataTableResponse> {
    let url_ = this.baseUrl + '/api/News/GetNewsList'
    url_ = url_.replace(/[?&]$/, '')

    const content_ = JSON.stringify(request)

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('post', url_, options_)
      .flatMap((response_: any) => {
        return this.processGetNewsList(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processGetNewsList(<any>response_)
          } catch (e) {
            return <Observable<NewsDataTableResponse>>(<any>Observable.throw(e))
          }
        } else
          return <Observable<NewsDataTableResponse>>(
            (<any>Observable.throw(response_))
          )
      })
  }

  protected processGetNewsList(
    response: HttpResponseBase,
  ): Observable<NewsDataTableResponse> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = resultData200
          ? NewsDataTableResponse.fromJS(resultData200)
          : <any>null
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<NewsDataTableResponse>(<any>null)
  }

  view(id: string): Observable<News> {
    let url_ = this.baseUrl + '/api/News/View?'
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined and cannot be null.")
    else url_ += 'Id=' + encodeURIComponent('' + id) + '&'
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('get', url_, options_)
      .flatMap((response_: any) => {
        return this.processView(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processView(<any>response_)
          } catch (e) {
            return <Observable<News>>(<any>Observable.throw(e))
          }
        } else return <Observable<News>>(<any>Observable.throw(response_))
      })
  }

  protected processView(response: HttpResponseBase): Observable<News> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = resultData200 ? News.fromJS(resultData200) : <any>null
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<News>(<any>null)
  }

  insert(req: News): Observable<NewsCrudResponse> {
    let url_ = this.baseUrl + '/api/News/Insert'
    url_ = url_.replace(/[?&]$/, '')

    const content_ = JSON.stringify(req)

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('post', url_, options_)
      .flatMap((response_: any) => {
        return this.processInsert(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processInsert(<any>response_)
          } catch (e) {
            return <Observable<NewsCrudResponse>>(<any>Observable.throw(e))
          }
        } else
          return <Observable<NewsCrudResponse>>(
            (<any>Observable.throw(response_))
          )
      })
  }

  protected processInsert(
    response: HttpResponseBase,
  ): Observable<NewsCrudResponse> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = resultData200
          ? NewsCrudResponse.fromJS(resultData200)
          : <any>null
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<NewsCrudResponse>(<any>null)
  }

  update(req: News): Observable<NewsCrudResponse> {
    let url_ = this.baseUrl + '/api/News/Update'
    url_ = url_.replace(/[?&]$/, '')

    const content_ = JSON.stringify(req)

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('post', url_, options_)
      .flatMap((response_: any) => {
        return this.processUpdate(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processUpdate(<any>response_)
          } catch (e) {
            return <Observable<NewsCrudResponse>>(<any>Observable.throw(e))
          }
        } else
          return <Observable<NewsCrudResponse>>(
            (<any>Observable.throw(response_))
          )
      })
  }

  protected processUpdate(
    response: HttpResponseBase,
  ): Observable<NewsCrudResponse> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = resultData200
          ? NewsCrudResponse.fromJS(resultData200)
          : <any>null
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<NewsCrudResponse>(<any>null)
  }

  detele(id: string): Observable<NewsCrudResponse> {
    let url_ = this.baseUrl + '/api/News/Detele?'
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined and cannot be null.")
    else url_ += 'Id=' + encodeURIComponent('' + id) + '&'
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('get', url_, options_)
      .flatMap((response_: any) => {
        return this.processDetele(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processDetele(<any>response_)
          } catch (e) {
            return <Observable<NewsCrudResponse>>(<any>Observable.throw(e))
          }
        } else
          return <Observable<NewsCrudResponse>>(
            (<any>Observable.throw(response_))
          )
      })
  }

  protected processDetele(
    response: HttpResponseBase,
  ): Observable<NewsCrudResponse> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = resultData200
          ? NewsCrudResponse.fromJS(resultData200)
          : <any>null
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<NewsCrudResponse>(<any>null)
  }
}

@Injectable()
export class ProdservService {
  private http: HttpClient
  private baseUrl: string
  protected jsonParseReviver: (key: string, value: any) => any = undefined

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string,
  ) {
    this.http = http
    this.baseUrl = baseUrl ? baseUrl : ''
  }

  serviceDataList(request: DataTableRequest): Observable<ServiceDataResponse> {
    let url_ = this.baseUrl + '/api/Prodserv/ServiceDataList'
    url_ = url_.replace(/[?&]$/, '')

    const content_ = JSON.stringify(request)

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('post', url_, options_)
      .flatMap((response_: any) => {
        return this.processServiceDataList(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processServiceDataList(<any>response_)
          } catch (e) {
            return <Observable<ServiceDataResponse>>(<any>Observable.throw(e))
          }
        } else
          return <Observable<ServiceDataResponse>>(
            (<any>Observable.throw(response_))
          )
      })
  }

  protected processServiceDataList(
    response: HttpResponseBase,
  ): Observable<ServiceDataResponse> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = resultData200
          ? ServiceDataResponse.fromJS(resultData200)
          : <any>null
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<ServiceDataResponse>(<any>null)
  }

  insert(request: Service): Observable<ServiceCrudResponse> {
    let url_ = this.baseUrl + '/api/Prodserv/Insert'
    url_ = url_.replace(/[?&]$/, '')

    const content_ = JSON.stringify(request)

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('post', url_, options_)
      .flatMap((response_: any) => {
        return this.processInsert(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processInsert(<any>response_)
          } catch (e) {
            return <Observable<ServiceCrudResponse>>(<any>Observable.throw(e))
          }
        } else
          return <Observable<ServiceCrudResponse>>(
            (<any>Observable.throw(response_))
          )
      })
  }

  protected processInsert(
    response: HttpResponseBase,
  ): Observable<ServiceCrudResponse> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = resultData200
          ? ServiceCrudResponse.fromJS(resultData200)
          : <any>null
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<ServiceCrudResponse>(<any>null)
  }

  update(request: Service): Observable<ServiceCrudResponse> {
    let url_ = this.baseUrl + '/api/Prodserv/Update'
    url_ = url_.replace(/[?&]$/, '')

    const content_ = JSON.stringify(request)

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('post', url_, options_)
      .flatMap((response_: any) => {
        return this.processUpdate(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processUpdate(<any>response_)
          } catch (e) {
            return <Observable<ServiceCrudResponse>>(<any>Observable.throw(e))
          }
        } else
          return <Observable<ServiceCrudResponse>>(
            (<any>Observable.throw(response_))
          )
      })
  }

  protected processUpdate(
    response: HttpResponseBase,
  ): Observable<ServiceCrudResponse> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = resultData200
          ? ServiceCrudResponse.fromJS(resultData200)
          : <any>null
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<ServiceCrudResponse>(<any>null)
  }

  delete(id: string): Observable<ServiceCrudResponse> {
    let url_ = this.baseUrl + '/api/Prodserv/Delete?'
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined and cannot be null.")
    else url_ += 'id=' + encodeURIComponent('' + id) + '&'
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('post', url_, options_)
      .flatMap((response_: any) => {
        return this.processDelete(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processDelete(<any>response_)
          } catch (e) {
            return <Observable<ServiceCrudResponse>>(<any>Observable.throw(e))
          }
        } else
          return <Observable<ServiceCrudResponse>>(
            (<any>Observable.throw(response_))
          )
      })
  }

  protected processDelete(
    response: HttpResponseBase,
  ): Observable<ServiceCrudResponse> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = resultData200
          ? ServiceCrudResponse.fromJS(resultData200)
          : <any>null
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<ServiceCrudResponse>(<any>null)
  }

  view(id: string): Observable<Service> {
    let url_ = this.baseUrl + '/api/Prodserv/View?'
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined and cannot be null.")
    else url_ += 'id=' + encodeURIComponent('' + id) + '&'
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('post', url_, options_)
      .flatMap((response_: any) => {
        return this.processView(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processView(<any>response_)
          } catch (e) {
            return <Observable<Service>>(<any>Observable.throw(e))
          }
        } else return <Observable<Service>>(<any>Observable.throw(response_))
      })
  }

  protected processView(response: HttpResponseBase): Observable<Service> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = resultData200 ? Service.fromJS(resultData200) : <any>null
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<Service>(<any>null)
  }
}

@Injectable()
export class ProductService {
  private http: HttpClient
  private baseUrl: string
  protected jsonParseReviver: (key: string, value: any) => any = undefined

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string,
  ) {
    this.http = http
    this.baseUrl = baseUrl ? baseUrl : ''
  }

  productDetailList(request: DataTableRequest): Observable<ProductResponse> {
    let url_ = this.baseUrl + '/api/Product/ProductDetailList'
    url_ = url_.replace(/[?&]$/, '')

    const content_ = JSON.stringify(request)

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('post', url_, options_)
      .flatMap((response_: any) => {
        return this.processProductDetailList(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processProductDetailList(<any>response_)
          } catch (e) {
            return <Observable<ProductResponse>>(<any>Observable.throw(e))
          }
        } else
          return <Observable<ProductResponse>>(<any>Observable.throw(response_))
      })
  }

  protected processProductDetailList(
    response: HttpResponseBase,
  ): Observable<ProductResponse> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = resultData200
          ? ProductResponse.fromJS(resultData200)
          : <any>null
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<ProductResponse>(<any>null)
  }

  productsInsert(prod: Product): Observable<ProductCrudResponse> {
    let url_ = this.baseUrl + '/api/Product/ProductsInsert'
    url_ = url_.replace(/[?&]$/, '')

    const content_ = JSON.stringify(prod)

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('post', url_, options_)
      .flatMap((response_: any) => {
        return this.processProductsInsert(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processProductsInsert(<any>response_)
          } catch (e) {
            return <Observable<ProductCrudResponse>>(<any>Observable.throw(e))
          }
        } else
          return <Observable<ProductCrudResponse>>(
            (<any>Observable.throw(response_))
          )
      })
  }

  protected processProductsInsert(
    response: HttpResponseBase,
  ): Observable<ProductCrudResponse> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = resultData200
          ? ProductCrudResponse.fromJS(resultData200)
          : <any>null
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<ProductCrudResponse>(<any>null)
  }

  productsUpdate(prod: Product): Observable<ProductCrudResponse> {
    let url_ = this.baseUrl + '/api/Product/ProductsUpdate'
    url_ = url_.replace(/[?&]$/, '')

    const content_ = JSON.stringify(prod)

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('post', url_, options_)
      .flatMap((response_: any) => {
        return this.processProductsUpdate(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processProductsUpdate(<any>response_)
          } catch (e) {
            return <Observable<ProductCrudResponse>>(<any>Observable.throw(e))
          }
        } else
          return <Observable<ProductCrudResponse>>(
            (<any>Observable.throw(response_))
          )
      })
  }

  protected processProductsUpdate(
    response: HttpResponseBase,
  ): Observable<ProductCrudResponse> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = resultData200
          ? ProductCrudResponse.fromJS(resultData200)
          : <any>null
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<ProductCrudResponse>(<any>null)
  }

  productsDelete(id: string): Observable<ProductCrudResponse> {
    let url_ = this.baseUrl + '/api/Product/ProductsDelete?'
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined and cannot be null.")
    else url_ += 'id=' + encodeURIComponent('' + id) + '&'
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('get', url_, options_)
      .flatMap((response_: any) => {
        return this.processProductsDelete(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processProductsDelete(<any>response_)
          } catch (e) {
            return <Observable<ProductCrudResponse>>(<any>Observable.throw(e))
          }
        } else
          return <Observable<ProductCrudResponse>>(
            (<any>Observable.throw(response_))
          )
      })
  }

  protected processProductsDelete(
    response: HttpResponseBase,
  ): Observable<ProductCrudResponse> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = resultData200
          ? ProductCrudResponse.fromJS(resultData200)
          : <any>null
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<ProductCrudResponse>(<any>null)
  }

  productsView(id: string): Observable<ProductDetails> {
    let url_ = this.baseUrl + '/api/Product/ProductsView?'
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined and cannot be null.")
    else url_ += 'id=' + encodeURIComponent('' + id) + '&'
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('get', url_, options_)
      .flatMap((response_: any) => {
        return this.processProductsView(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processProductsView(<any>response_)
          } catch (e) {
            return <Observable<ProductDetails>>(<any>Observable.throw(e))
          }
        } else
          return <Observable<ProductDetails>>(<any>Observable.throw(response_))
      })
  }

  protected processProductsView(
    response: HttpResponseBase,
  ): Observable<ProductDetails> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = resultData200
          ? ProductDetails.fromJS(resultData200)
          : <any>null
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<ProductDetails>(<any>null)
  }

  productPackageRatesRemove(id: string): Observable<ProductPackageRate[]> {
    let url_ = this.baseUrl + '/api/Product/ProductPackageRatesRemove?'
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined and cannot be null.")
    else url_ += 'id=' + encodeURIComponent('' + id) + '&'
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('get', url_, options_)
      .flatMap((response_: any) => {
        return this.processProductPackageRatesRemove(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processProductPackageRatesRemove(<any>response_)
          } catch (e) {
            return <Observable<ProductPackageRate[]>>(<any>Observable.throw(e))
          }
        } else
          return <Observable<ProductPackageRate[]>>(
            (<any>Observable.throw(response_))
          )
      })
  }

  protected processProductPackageRatesRemove(
    response: HttpResponseBase,
  ): Observable<ProductPackageRate[]> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        if (resultData200 && resultData200.constructor === Array) {
          result200 = []
          for (let item of resultData200)
            result200.push(ProductPackageRate.fromJS(item))
        }
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<ProductPackageRate[]>(<any>null)
  }

  productsAdd(): Observable<Product> {
    let url_ = this.baseUrl + '/api/Product/ProductsAdd'
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('get', url_, options_)
      .flatMap((response_: any) => {
        return this.processProductsAdd(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processProductsAdd(<any>response_)
          } catch (e) {
            return <Observable<Product>>(<any>Observable.throw(e))
          }
        } else return <Observable<Product>>(<any>Observable.throw(response_))
      })
  }

  protected processProductsAdd(
    response: HttpResponseBase,
  ): Observable<Product> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = resultData200 ? Product.fromJS(resultData200) : <any>null
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<Product>(<any>null)
  }

  getServices(): Observable<ProductDetails> {
    let url_ = this.baseUrl + '/api/Product/GetServices'
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('get', url_, options_)
      .flatMap((response_: any) => {
        return this.processGetServices(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processGetServices(<any>response_)
          } catch (e) {
            return <Observable<ProductDetails>>(<any>Observable.throw(e))
          }
        } else
          return <Observable<ProductDetails>>(<any>Observable.throw(response_))
      })
  }

  protected processGetServices(
    response: HttpResponseBase,
  ): Observable<ProductDetails> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = resultData200
          ? ProductDetails.fromJS(resultData200)
          : <any>null
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<ProductDetails>(<any>null)
  }
}

@Injectable()
export class SubscriptionService {
  private http: HttpClient
  private baseUrl: string
  protected jsonParseReviver: (key: string, value: any) => any = undefined

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string,
  ) {
    this.http = http
    this.baseUrl = baseUrl ? baseUrl : ''
  }

  createInvoice(subscriptionId: string): Observable<SubscriptionResponse> {
    let url_ = this.baseUrl + '/api/Subscription/CreateInvoice?'
    if (subscriptionId === undefined || subscriptionId === null)
      throw new Error(
        "The parameter 'subscriptionId' must be defined and cannot be null.",
      )
    else
      url_ += 'subscriptionId=' + encodeURIComponent('' + subscriptionId) + '&'
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('get', url_, options_)
      .flatMap((response_: any) => {
        return this.processCreateInvoice(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processCreateInvoice(<any>response_)
          } catch (e) {
            return <Observable<SubscriptionResponse>>(<any>Observable.throw(e))
          }
        } else
          return <Observable<SubscriptionResponse>>(
            (<any>Observable.throw(response_))
          )
      })
  }

  protected processCreateInvoice(
    response: HttpResponseBase,
  ): Observable<SubscriptionResponse> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = resultData200
          ? SubscriptionResponse.fromJS(resultData200)
          : <any>null
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<SubscriptionResponse>(<any>null)
  }

  getSubscriptionList(
    req: SubscriptionDataTableRequest,
  ): Observable<SubscriptionDataTableRespone> {
    let url_ = this.baseUrl + '/api/Subscription/GetSubscriptionList'
    url_ = url_.replace(/[?&]$/, '')

    const content_ = JSON.stringify(req)

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('post', url_, options_)
      .flatMap((response_: any) => {
        return this.processGetSubscriptionList(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processGetSubscriptionList(<any>response_)
          } catch (e) {
            return <Observable<SubscriptionDataTableRespone>>(
              (<any>Observable.throw(e))
            )
          }
        } else
          return <Observable<SubscriptionDataTableRespone>>(
            (<any>Observable.throw(response_))
          )
      })
  }

  protected processGetSubscriptionList(
    response: HttpResponseBase,
  ): Observable<SubscriptionDataTableRespone> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = resultData200
          ? SubscriptionDataTableRespone.fromJS(resultData200)
          : <any>null
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<SubscriptionDataTableRespone>(<any>null)
  }

  getSubscription(id: string): Observable<SubscriptionVm> {
    let url_ = this.baseUrl + '/api/Subscription/GetSubscription?'
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined and cannot be null.")
    else url_ += 'id=' + encodeURIComponent('' + id) + '&'
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('get', url_, options_)
      .flatMap((response_: any) => {
        return this.processGetSubscription(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processGetSubscription(<any>response_)
          } catch (e) {
            return <Observable<SubscriptionVm>>(<any>Observable.throw(e))
          }
        } else
          return <Observable<SubscriptionVm>>(<any>Observable.throw(response_))
      })
  }

  protected processGetSubscription(
    response: HttpResponseBase,
  ): Observable<SubscriptionVm> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = resultData200
          ? SubscriptionVm.fromJS(resultData200)
          : <any>null
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<SubscriptionVm>(<any>null)
  }

  addSubscription(products: ProductsVm): Observable<SubscriptionResponse> {
    let url_ = this.baseUrl + '/api/Subscription/AddSubscription'
    url_ = url_.replace(/[?&]$/, '')

    const content_ = JSON.stringify(products)

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('post', url_, options_)
      .flatMap((response_: any) => {
        return this.processAddSubscription(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processAddSubscription(<any>response_)
          } catch (e) {
            return <Observable<SubscriptionResponse>>(<any>Observable.throw(e))
          }
        } else
          return <Observable<SubscriptionResponse>>(
            (<any>Observable.throw(response_))
          )
      })
  }

  protected processAddSubscription(
    response: HttpResponseBase,
  ): Observable<SubscriptionResponse> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = resultData200
          ? SubscriptionResponse.fromJS(resultData200)
          : <any>null
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<SubscriptionResponse>(<any>null)
  }

  getCustomers(): Observable<Customer[]> {
    let url_ = this.baseUrl + '/api/Subscription/GetCustomers'
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('get', url_, options_)
      .flatMap((response_: any) => {
        return this.processGetCustomers(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processGetCustomers(<any>response_)
          } catch (e) {
            return <Observable<Customer[]>>(<any>Observable.throw(e))
          }
        } else return <Observable<Customer[]>>(<any>Observable.throw(response_))
      })
  }

  protected processGetCustomers(
    response: HttpResponseBase,
  ): Observable<Customer[]> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        if (resultData200 && resultData200.constructor === Array) {
          result200 = []
          for (let item of resultData200) result200.push(Customer.fromJS(item))
        }
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<Customer[]>(<any>null)
  }

  getCustomerById(customerid: string): Observable<Customer> {
    let url_ = this.baseUrl + '/api/Subscription/GetCustomerById?'
    if (customerid === undefined || customerid === null)
      throw new Error(
        "The parameter 'customerid' must be defined and cannot be null.",
      )
    else url_ += 'customerid=' + encodeURIComponent('' + customerid) + '&'
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('get', url_, options_)
      .flatMap((response_: any) => {
        return this.processGetCustomerById(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processGetCustomerById(<any>response_)
          } catch (e) {
            return <Observable<Customer>>(<any>Observable.throw(e))
          }
        } else return <Observable<Customer>>(<any>Observable.throw(response_))
      })
  }

  protected processGetCustomerById(
    response: HttpResponseBase,
  ): Observable<Customer> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = resultData200 ? Customer.fromJS(resultData200) : <any>null
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<Customer>(<any>null)
  }

  getProductList(id: string): Observable<ProductPackageRate[]> {
    let url_ = this.baseUrl + '/api/Subscription/GetProductList?'
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined and cannot be null.")
    else url_ += 'id=' + encodeURIComponent('' + id) + '&'
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('get', url_, options_)
      .flatMap((response_: any) => {
        return this.processGetProductList(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processGetProductList(<any>response_)
          } catch (e) {
            return <Observable<ProductPackageRate[]>>(<any>Observable.throw(e))
          }
        } else
          return <Observable<ProductPackageRate[]>>(
            (<any>Observable.throw(response_))
          )
      })
  }

  protected processGetProductList(
    response: HttpResponseBase,
  ): Observable<ProductPackageRate[]> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        if (resultData200 && resultData200.constructor === Array) {
          result200 = []
          for (let item of resultData200)
            result200.push(ProductPackageRate.fromJS(item))
        }
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<ProductPackageRate[]>(<any>null)
  }

  getProducts(id: string): Observable<Product[]> {
    let url_ = this.baseUrl + '/api/Subscription/GetProducts?'
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined and cannot be null.")
    else url_ += 'id=' + encodeURIComponent('' + id) + '&'
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('get', url_, options_)
      .flatMap((response_: any) => {
        return this.processGetProducts(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processGetProducts(<any>response_)
          } catch (e) {
            return <Observable<Product[]>>(<any>Observable.throw(e))
          }
        } else return <Observable<Product[]>>(<any>Observable.throw(response_))
      })
  }

  protected processGetProducts(
    response: HttpResponseBase,
  ): Observable<Product[]> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        if (resultData200 && resultData200.constructor === Array) {
          result200 = []
          for (let item of resultData200) result200.push(Product.fromJS(item))
        }
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<Product[]>(<any>null)
  }

  getData(): Observable<ProductsVm[]> {
    let url_ = this.baseUrl + '/api/Subscription/GetData'
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('post', url_, options_)
      .flatMap((response_: any) => {
        return this.processGetData(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processGetData(<any>response_)
          } catch (e) {
            return <Observable<ProductsVm[]>>(<any>Observable.throw(e))
          }
        } else
          return <Observable<ProductsVm[]>>(<any>Observable.throw(response_))
      })
  }

  protected processGetData(
    response: HttpResponseBase,
  ): Observable<ProductsVm[]> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        if (resultData200 && resultData200.constructor === Array) {
          result200 = []
          for (let item of resultData200)
            result200.push(ProductsVm.fromJS(item))
        }
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<ProductsVm[]>(<any>null)
  }
}

@Injectable()
export class UserService {
  private http: HttpClient
  private baseUrl: string
  protected jsonParseReviver: (key: string, value: any) => any = undefined

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string,
  ) {
    this.http = http
    this.baseUrl = baseUrl ? baseUrl : ''
  }

  userDataList(request: DataTableRequest): Observable<UserDataResponse> {
    let url_ = this.baseUrl + '/api/User/UserDataList'
    url_ = url_.replace(/[?&]$/, '')

    const content_ = JSON.stringify(request)

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('post', url_, options_)
      .flatMap((response_: any) => {
        return this.processUserDataList(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processUserDataList(<any>response_)
          } catch (e) {
            return <Observable<UserDataResponse>>(<any>Observable.throw(e))
          }
        } else
          return <Observable<UserDataResponse>>(
            (<any>Observable.throw(response_))
          )
      })
  }

  protected processUserDataList(
    response: HttpResponseBase,
  ): Observable<UserDataResponse> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = resultData200
          ? UserDataResponse.fromJS(resultData200)
          : <any>null
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<UserDataResponse>(<any>null)
  }

  insert(request: User): Observable<UserCrudResponse> {
    let url_ = this.baseUrl + '/api/User/Insert'
    url_ = url_.replace(/[?&]$/, '')

    const content_ = JSON.stringify(request)

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('post', url_, options_)
      .flatMap((response_: any) => {
        return this.processInsert(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processInsert(<any>response_)
          } catch (e) {
            return <Observable<UserCrudResponse>>(<any>Observable.throw(e))
          }
        } else
          return <Observable<UserCrudResponse>>(
            (<any>Observable.throw(response_))
          )
      })
  }

  protected processInsert(
    response: HttpResponseBase,
  ): Observable<UserCrudResponse> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = resultData200
          ? UserCrudResponse.fromJS(resultData200)
          : <any>null
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<UserCrudResponse>(<any>null)
  }

  update(request: User): Observable<UserCrudResponse> {
    let url_ = this.baseUrl + '/api/User/Update'
    url_ = url_.replace(/[?&]$/, '')

    const content_ = JSON.stringify(request)

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('post', url_, options_)
      .flatMap((response_: any) => {
        return this.processUpdate(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processUpdate(<any>response_)
          } catch (e) {
            return <Observable<UserCrudResponse>>(<any>Observable.throw(e))
          }
        } else
          return <Observable<UserCrudResponse>>(
            (<any>Observable.throw(response_))
          )
      })
  }

  protected processUpdate(
    response: HttpResponseBase,
  ): Observable<UserCrudResponse> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = resultData200
          ? UserCrudResponse.fromJS(resultData200)
          : <any>null
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<UserCrudResponse>(<any>null)
  }

  delete(id: string): Observable<UserCrudResponse> {
    let url_ = this.baseUrl + '/api/User/Delete?'
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined and cannot be null.")
    else url_ += 'id=' + encodeURIComponent('' + id) + '&'
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('post', url_, options_)
      .flatMap((response_: any) => {
        return this.processDelete(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processDelete(<any>response_)
          } catch (e) {
            return <Observable<UserCrudResponse>>(<any>Observable.throw(e))
          }
        } else
          return <Observable<UserCrudResponse>>(
            (<any>Observable.throw(response_))
          )
      })
  }

  protected processDelete(
    response: HttpResponseBase,
  ): Observable<UserCrudResponse> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = resultData200
          ? UserCrudResponse.fromJS(resultData200)
          : <any>null
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<UserCrudResponse>(<any>null)
  }

  view(id: string): Observable<User> {
    let url_ = this.baseUrl + '/api/User/View?'
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined and cannot be null.")
    else url_ += 'id=' + encodeURIComponent('' + id) + '&'
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('post', url_, options_)
      .flatMap((response_: any) => {
        return this.processView(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processView(<any>response_)
          } catch (e) {
            return <Observable<User>>(<any>Observable.throw(e))
          }
        } else return <Observable<User>>(<any>Observable.throw(response_))
      })
  }

  protected processView(response: HttpResponseBase): Observable<User> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = resultData200 ? User.fromJS(resultData200) : <any>null
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<User>(<any>null)
  }

  getUserMenu(): Observable<Menu[]> {
    let url_ = this.baseUrl + '/api/User/GetUserMenu'
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('get', url_, options_)
      .flatMap((response_: any) => {
        return this.processGetUserMenu(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processGetUserMenu(<any>response_)
          } catch (e) {
            return <Observable<Menu[]>>(<any>Observable.throw(e))
          }
        } else return <Observable<Menu[]>>(<any>Observable.throw(response_))
      })
  }

  protected processGetUserMenu(response: HttpResponseBase): Observable<Menu[]> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        if (resultData200 && resultData200.constructor === Array) {
          result200 = []
          for (let item of resultData200) result200.push(Menu.fromJS(item))
        }
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<Menu[]>(<any>null)
  }

  getPermission(id: string, formName: string): Observable<UserPermission> {
    let url_ = this.baseUrl + '/api/User/GetPermission?'
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined and cannot be null.")
    else url_ += 'id=' + encodeURIComponent('' + id) + '&'
    if (formName === undefined)
      throw new Error("The parameter 'formName' must be defined.")
    else url_ += 'FormName=' + encodeURIComponent('' + formName) + '&'
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('get', url_, options_)
      .flatMap((response_: any) => {
        return this.processGetPermission(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processGetPermission(<any>response_)
          } catch (e) {
            return <Observable<UserPermission>>(<any>Observable.throw(e))
          }
        } else
          return <Observable<UserPermission>>(<any>Observable.throw(response_))
      })
  }

  protected processGetPermission(
    response: HttpResponseBase,
  ): Observable<UserPermission> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = resultData200
          ? UserPermission.fromJS(resultData200)
          : <any>null
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<UserPermission>(<any>null)
  }

  removeUserperission(id: string): Observable<UserPermission[]> {
    let url_ = this.baseUrl + '/api/User/RemoveUserperission?'
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined and cannot be null.")
    else url_ += 'id=' + encodeURIComponent('' + id) + '&'
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('post', url_, options_)
      .flatMap((response_: any) => {
        return this.processRemoveUserperission(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processRemoveUserperission(<any>response_)
          } catch (e) {
            return <Observable<UserPermission[]>>(<any>Observable.throw(e))
          }
        } else
          return <Observable<UserPermission[]>>(
            (<any>Observable.throw(response_))
          )
      })
  }

  protected processRemoveUserperission(
    response: HttpResponseBase,
  ): Observable<UserPermission[]> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        if (resultData200 && resultData200.constructor === Array) {
          result200 = []
          for (let item of resultData200)
            result200.push(UserPermission.fromJS(item))
        }
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<UserPermission[]>(<any>null)
  }
}

@Injectable()
export class CustomerService {
  private http: HttpClient
  private baseUrl: string
  protected jsonParseReviver: (key: string, value: any) => any = undefined

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string,
  ) {
    this.http = http
    this.baseUrl = baseUrl ? baseUrl : ''
  }

  customerDetailList(
    request: DataTableRequest,
  ): Observable<CustomerDetailsResponse> {
    let url_ = this.baseUrl + '/api/Customer/CustomerDetailList'
    url_ = url_.replace(/[?&]$/, '')

    const content_ = JSON.stringify(request)

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('post', url_, options_)
      .flatMap((response_: any) => {
        return this.processCustomerDetailList(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processCustomerDetailList(<any>response_)
          } catch (e) {
            return <Observable<CustomerDetailsResponse>>(
              (<any>Observable.throw(e))
            )
          }
        } else
          return <Observable<CustomerDetailsResponse>>(
            (<any>Observable.throw(response_))
          )
      })
  }

  protected processCustomerDetailList(
    response: HttpResponseBase,
  ): Observable<CustomerDetailsResponse> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = resultData200
          ? CustomerDetailsResponse.fromJS(resultData200)
          : <any>null
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<CustomerDetailsResponse>(<any>null)
  }

  getName(id: string): Observable<string> {
    let url_ = this.baseUrl + '/api/Customer/GetName?'
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined and cannot be null.")
    else url_ += 'Id=' + encodeURIComponent('' + id) + '&'
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('get', url_, options_)
      .flatMap((response_: any) => {
        return this.processGetName(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processGetName(<any>response_)
          } catch (e) {
            return <Observable<string>>(<any>Observable.throw(e))
          }
        } else return <Observable<string>>(<any>Observable.throw(response_))
      })
  }

  protected processGetName(response: HttpResponseBase): Observable<string> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = resultData200 !== undefined ? resultData200 : <any>null
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<string>(<any>null)
  }

  insert(cust: CustomersVm): Observable<CustomerCrudResponse> {
    let url_ = this.baseUrl + '/api/Customer/Insert'
    url_ = url_.replace(/[?&]$/, '')

    const content_ = JSON.stringify(cust)

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('post', url_, options_)
      .flatMap((response_: any) => {
        return this.processInsert(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processInsert(<any>response_)
          } catch (e) {
            return <Observable<CustomerCrudResponse>>(<any>Observable.throw(e))
          }
        } else
          return <Observable<CustomerCrudResponse>>(
            (<any>Observable.throw(response_))
          )
      })
  }

  protected processInsert(
    response: HttpResponseBase,
  ): Observable<CustomerCrudResponse> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = resultData200
          ? CustomerCrudResponse.fromJS(resultData200)
          : <any>null
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<CustomerCrudResponse>(<any>null)
  }

  insertCustomerProduct(
    cust: CustomerProdcutVm,
  ): Observable<CustomerCrudResponse> {
    let url_ = this.baseUrl + '/api/Customer/InsertCustomerProduct'
    url_ = url_.replace(/[?&]$/, '')

    const content_ = JSON.stringify(cust)

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('post', url_, options_)
      .flatMap((response_: any) => {
        return this.processInsertCustomerProduct(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processInsertCustomerProduct(<any>response_)
          } catch (e) {
            return <Observable<CustomerCrudResponse>>(<any>Observable.throw(e))
          }
        } else
          return <Observable<CustomerCrudResponse>>(
            (<any>Observable.throw(response_))
          )
      })
  }

  protected processInsertCustomerProduct(
    response: HttpResponseBase,
  ): Observable<CustomerCrudResponse> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = resultData200
          ? CustomerCrudResponse.fromJS(resultData200)
          : <any>null
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<CustomerCrudResponse>(<any>null)
  }

  updateCustomerProduct(
    cust: CustomerProdcutVm,
  ): Observable<CustomerCrudResponse> {
    let url_ = this.baseUrl + '/api/Customer/UpdateCustomerProduct'
    url_ = url_.replace(/[?&]$/, '')

    const content_ = JSON.stringify(cust)

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('post', url_, options_)
      .flatMap((response_: any) => {
        return this.processUpdateCustomerProduct(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processUpdateCustomerProduct(<any>response_)
          } catch (e) {
            return <Observable<CustomerCrudResponse>>(<any>Observable.throw(e))
          }
        } else
          return <Observable<CustomerCrudResponse>>(
            (<any>Observable.throw(response_))
          )
      })
  }

  protected processUpdateCustomerProduct(
    response: HttpResponseBase,
  ): Observable<CustomerCrudResponse> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = resultData200
          ? CustomerCrudResponse.fromJS(resultData200)
          : <any>null
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<CustomerCrudResponse>(<any>null)
  }

  update(cust: CustomersVm): Observable<CustomerCrudResponse> {
    let url_ = this.baseUrl + '/api/Customer/Update'
    url_ = url_.replace(/[?&]$/, '')

    const content_ = JSON.stringify(cust)

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('post', url_, options_)
      .flatMap((response_: any) => {
        return this.processUpdate(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processUpdate(<any>response_)
          } catch (e) {
            return <Observable<CustomerCrudResponse>>(<any>Observable.throw(e))
          }
        } else
          return <Observable<CustomerCrudResponse>>(
            (<any>Observable.throw(response_))
          )
      })
  }

  protected processUpdate(
    response: HttpResponseBase,
  ): Observable<CustomerCrudResponse> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = resultData200
          ? CustomerCrudResponse.fromJS(resultData200)
          : <any>null
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<CustomerCrudResponse>(<any>null)
  }

  updateStatus(cust: CustomersVm): Observable<CustomerCrudResponse> {
    let url_ = this.baseUrl + '/api/Customer/UpdateStatus'
    url_ = url_.replace(/[?&]$/, '')

    const content_ = JSON.stringify(cust)

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('post', url_, options_)
      .flatMap((response_: any) => {
        return this.processUpdateStatus(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processUpdateStatus(<any>response_)
          } catch (e) {
            return <Observable<CustomerCrudResponse>>(<any>Observable.throw(e))
          }
        } else
          return <Observable<CustomerCrudResponse>>(
            (<any>Observable.throw(response_))
          )
      })
  }

  protected processUpdateStatus(
    response: HttpResponseBase,
  ): Observable<CustomerCrudResponse> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = resultData200
          ? CustomerCrudResponse.fromJS(resultData200)
          : <any>null
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<CustomerCrudResponse>(<any>null)
  }

  delete(id: string): Observable<CustomerCrudResponse> {
    let url_ = this.baseUrl + '/api/Customer/Delete?'
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined and cannot be null.")
    else url_ += 'id=' + encodeURIComponent('' + id) + '&'
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('post', url_, options_)
      .flatMap((response_: any) => {
        return this.processDelete(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processDelete(<any>response_)
          } catch (e) {
            return <Observable<CustomerCrudResponse>>(<any>Observable.throw(e))
          }
        } else
          return <Observable<CustomerCrudResponse>>(
            (<any>Observable.throw(response_))
          )
      })
  }

  protected processDelete(
    response: HttpResponseBase,
  ): Observable<CustomerCrudResponse> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = resultData200
          ? CustomerCrudResponse.fromJS(resultData200)
          : <any>null
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<CustomerCrudResponse>(<any>null)
  }

  view(id: string): Observable<CustomersVm> {
    let url_ = this.baseUrl + '/api/Customer/View?'
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined and cannot be null.")
    else url_ += 'id=' + encodeURIComponent('' + id) + '&'
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('post', url_, options_)
      .flatMap((response_: any) => {
        return this.processView(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processView(<any>response_)
          } catch (e) {
            return <Observable<CustomersVm>>(<any>Observable.throw(e))
          }
        } else
          return <Observable<CustomersVm>>(<any>Observable.throw(response_))
      })
  }

  protected processView(response: HttpResponseBase): Observable<CustomersVm> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = resultData200
          ? CustomersVm.fromJS(resultData200)
          : <any>null
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<CustomersVm>(<any>null)
  }

  viewCustomerProdcut(id: string): Observable<CustomerProdcutVm> {
    let url_ = this.baseUrl + '/api/Customer/ViewCustomerProdcut?'
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined and cannot be null.")
    else url_ += 'id=' + encodeURIComponent('' + id) + '&'
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('get', url_, options_)
      .flatMap((response_: any) => {
        return this.processViewCustomerProdcut(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processViewCustomerProdcut(<any>response_)
          } catch (e) {
            return <Observable<CustomerProdcutVm>>(<any>Observable.throw(e))
          }
        } else
          return <Observable<CustomerProdcutVm>>(
            (<any>Observable.throw(response_))
          )
      })
  }

  protected processViewCustomerProdcut(
    response: HttpResponseBase,
  ): Observable<CustomerProdcutVm> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = resultData200
          ? CustomerProdcutVm.fromJS(resultData200)
          : <any>null
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<CustomerProdcutVm>(<any>null)
  }

  getProducts(): Observable<Product[]> {
    let url_ = this.baseUrl + '/api/Customer/GetProducts'
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('get', url_, options_)
      .flatMap((response_: any) => {
        return this.processGetProducts(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processGetProducts(<any>response_)
          } catch (e) {
            return <Observable<Product[]>>(<any>Observable.throw(e))
          }
        } else return <Observable<Product[]>>(<any>Observable.throw(response_))
      })
  }

  protected processGetProducts(
    response: HttpResponseBase,
  ): Observable<Product[]> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        if (resultData200 && resultData200.constructor === Array) {
          result200 = []
          for (let item of resultData200) result200.push(Product.fromJS(item))
        }
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<Product[]>(<any>null)
  }

  getLookupDatas(): Observable<LookupData[]> {
    let url_ = this.baseUrl + '/api/Customer/GetLookupDatas'
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('get', url_, options_)
      .flatMap((response_: any) => {
        return this.processGetLookupDatas(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processGetLookupDatas(<any>response_)
          } catch (e) {
            return <Observable<LookupData[]>>(<any>Observable.throw(e))
          }
        } else
          return <Observable<LookupData[]>>(<any>Observable.throw(response_))
      })
  }

  getEnquiryReasonLookupDatas(): Observable<LookupData[]> {
    let url_ = this.baseUrl + '/api/Customer/GetEnquiryReasonLookupDatas'
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('get', url_, options_)
      .flatMap((response_: any) => {
        return this.processGetLookupDatas(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processGetLookupDatas(<any>response_)
          } catch (e) {
            return <Observable<LookupData[]>>(<any>Observable.throw(e))
          }
        } else
          return <Observable<LookupData[]>>(<any>Observable.throw(response_))
      })
  }

  protected processGetLookupDatas(
    response: HttpResponseBase,
  ): Observable<LookupData[]> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        if (resultData200 && resultData200.constructor === Array) {
          result200 = []
          for (let item of resultData200)
            result200.push(LookupData.fromJS(item))
        }
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<LookupData[]>(<any>null)
  }

  getCustomerProducts(): Observable<CustomerProdcutVm> {
    let url_ = this.baseUrl + '/api/Customer/GetCustomerProducts'
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('get', url_, options_)
      .flatMap((response_: any) => {
        return this.processGetCustomerProducts(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processGetCustomerProducts(<any>response_)
          } catch (e) {
            return <Observable<CustomerProdcutVm>>(<any>Observable.throw(e))
          }
        } else
          return <Observable<CustomerProdcutVm>>(
            (<any>Observable.throw(response_))
          )
      })
  }

  protected processGetCustomerProducts(
    response: HttpResponseBase,
  ): Observable<CustomerProdcutVm> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = resultData200
          ? CustomerProdcutVm.fromJS(resultData200)
          : <any>null
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<CustomerProdcutVm>(<any>null)
  }

  deleteFile(filePath: string): Observable<string> {
    let url_ = this.baseUrl + '/api/Customer/deleteFile?'
    if (filePath === undefined)
      throw new Error("The parameter 'filePath' must be defined.")
    else url_ += 'FilePath=' + encodeURIComponent('' + filePath) + '&'
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('post', url_, options_)
      .flatMap((response_: any) => {
        return this.processDeleteFile(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processDeleteFile(<any>response_)
          } catch (e) {
            return <Observable<string>>(<any>Observable.throw(e))
          }
        } else return <Observable<string>>(<any>Observable.throw(response_))
      })
  }

  protected processDeleteFile(response: HttpResponseBase): Observable<string> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = resultData200 !== undefined ? resultData200 : <any>null
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<string>(<any>null)
  }

  uploadFile(): Observable<FileResponse> {
    let url_ = this.baseUrl + '/api/Customer'
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('post', url_, options_)
      .flatMap((response_: any) => {
        return this.processUploadFile(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processUploadFile(<any>response_)
          } catch (e) {
            return <Observable<FileResponse>>(<any>Observable.throw(e))
          }
        } else
          return <Observable<FileResponse>>(<any>Observable.throw(response_))
      })
  }

  protected processUploadFile(
    response: HttpResponseBase,
  ): Observable<FileResponse> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers
        ? response.headers.get('content-disposition')
        : undefined
      const fileNameMatch = contentDisposition
        ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
        : undefined
      const fileName =
        fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined
      return Observable.of({
        fileName: fileName,
        data: <any>responseBlob,
        status: status,
        headers: _headers,
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<FileResponse>(<any>null)
  }

  downloadPdf(fileName: string, id: string): Observable<FileResponse> {
    let url_ = this.baseUrl + '/api/Customer/DownloadPdf?'
    if (fileName === undefined)
      throw new Error("The parameter 'fileName' must be defined.")
    else url_ += 'fileName=' + encodeURIComponent('' + fileName) + '&'
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined and cannot be null.")
    else url_ += 'Id=' + encodeURIComponent('' + id) + '&'
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('get', url_, options_)
      .flatMap((response_: any) => {
        return this.processDownloadPdf(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processDownloadPdf(<any>response_)
          } catch (e) {
            return <Observable<FileResponse>>(<any>Observable.throw(e))
          }
        } else
          return <Observable<FileResponse>>(<any>Observable.throw(response_))
      })
  }

  protected processDownloadPdf(
    response: HttpResponseBase,
  ): Observable<FileResponse> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers
        ? response.headers.get('content-disposition')
        : undefined
      const fileNameMatch = contentDisposition
        ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
        : undefined
      const fileName =
        fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined
      return Observable.of({
        fileName: fileName,
        data: <any>responseBlob,
        status: status,
        headers: _headers,
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<FileResponse>(<any>null)
  }

  getTabs(id: string): Observable<string> {
    let url_ = this.baseUrl + '/api/Customer/GetTabs?'
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined and cannot be null.")
    else url_ += 'Id=' + encodeURIComponent('' + id) + '&'
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('get', url_, options_)
      .flatMap((response_: any) => {
        return this.processGetTabs(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processGetTabs(<any>response_)
          } catch (e) {
            return <Observable<string>>(<any>Observable.throw(e))
          }
        } else return <Observable<string>>(<any>Observable.throw(response_))
      })
  }

  protected processGetTabs(response: HttpResponseBase): Observable<string> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = resultData200 !== undefined ? resultData200 : <any>null
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<string>(<any>null)
  }

  addTabs(tabs: string, customerId: string): Observable<string> {
    let url_ = this.baseUrl + '/api/Customer/AddTabs?'
    if (tabs === undefined)
      throw new Error("The parameter 'tabs' must be defined.")
    else url_ += 'tabs=' + encodeURIComponent('' + tabs) + '&'
    if (customerId === undefined || customerId === null)
      throw new Error(
        "The parameter 'customerId' must be defined and cannot be null.",
      )
    else url_ += 'CustomerId=' + encodeURIComponent('' + customerId) + '&'
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('get', url_, options_)
      .flatMap((response_: any) => {
        return this.processAddTabs(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processAddTabs(<any>response_)
          } catch (e) {
            return <Observable<string>>(<any>Observable.throw(e))
          }
        } else return <Observable<string>>(<any>Observable.throw(response_))
      })
  }

  protected processAddTabs(response: HttpResponseBase): Observable<string> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = resultData200 !== undefined ? resultData200 : <any>null
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<string>(<any>null)
  }
}

@Injectable()
export class DoNotCallRegistryService {
  private http: HttpClient
  private baseUrl: string
  protected jsonParseReviver: (key: string, value: any) => any = undefined

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string,
  ) {
    this.http = http
    this.baseUrl = baseUrl ? baseUrl : ''
  }

  getDoNotCallRegList(
    request: DonotCallRegistrySearchRequest,
  ): Observable<DncrResponse> {
    let url_ = this.baseUrl + '/api/DoNotCallRegistry/GetDoNotCallRegList'
    url_ = url_.replace(/[?&]$/, '')

    const content_ = JSON.stringify(request)

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('post', url_, options_)
      .flatMap((response_: any) => {
        return this.processGetDoNotCallRegList(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processGetDoNotCallRegList(<any>response_)
          } catch (e) {
            return <Observable<DncrResponse>>(<any>Observable.throw(e))
          }
        } else
          return <Observable<DncrResponse>>(<any>Observable.throw(response_))
      })
  }

  protected processGetDoNotCallRegList(
    response: HttpResponseBase,
  ): Observable<DncrResponse> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = resultData200
          ? DncrResponse.fromJS(resultData200)
          : <any>null
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<DncrResponse>(<any>null)
  }

  view(id: string): Observable<DoNotCallRegistry> {
    let url_ = this.baseUrl + '/api/DoNotCallRegistry/View?'
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined and cannot be null.")
    else url_ += 'id=' + encodeURIComponent('' + id) + '&'
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('post', url_, options_)
      .flatMap((response_: any) => {
        return this.processView(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processView(<any>response_)
          } catch (e) {
            return <Observable<DoNotCallRegistry>>(<any>Observable.throw(e))
          }
        } else
          return <Observable<DoNotCallRegistry>>(
            (<any>Observable.throw(response_))
          )
      })
  }

  protected processView(
    response: HttpResponseBase,
  ): Observable<DoNotCallRegistry> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = resultData200
          ? DoNotCallRegistry.fromJS(resultData200)
          : <any>null
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<DoNotCallRegistry>(<any>null)
  }

  update(request: DoNotCallRegistry): Observable<CrudResponseDonotCall> {
    let url_ = this.baseUrl + '/api/DoNotCallRegistry/Update'
    url_ = url_.replace(/[?&]$/, '')

    const content_ = JSON.stringify(request)

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('post', url_, options_)
      .flatMap((response_: any) => {
        return this.processUpdate(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processUpdate(<any>response_)
          } catch (e) {
            return <Observable<CrudResponseDonotCall>>(<any>Observable.throw(e))
          }
        } else
          return <Observable<CrudResponseDonotCall>>(
            (<any>Observable.throw(response_))
          )
      })
  }

  protected processUpdate(
    response: HttpResponseBase,
  ): Observable<CrudResponseDonotCall> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = resultData200
          ? CrudResponseDonotCall.fromJS(resultData200)
          : <any>null
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<CrudResponseDonotCall>(<any>null)
  }

  getColumns(filename: string): Observable<string[]> {
    let url_ = this.baseUrl + '/api/DoNotCallRegistry/GetColumns?'
    if (filename === undefined)
      throw new Error("The parameter 'filename' must be defined.")
    else url_ += 'filename=' + encodeURIComponent('' + filename) + '&'
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('get', url_, options_)
      .flatMap((response_: any) => {
        return this.processGetColumns(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processGetColumns(<any>response_)
          } catch (e) {
            return <Observable<string[]>>(<any>Observable.throw(e))
          }
        } else return <Observable<string[]>>(<any>Observable.throw(response_))
      })
  }

  protected processGetColumns(
    response: HttpResponseBase,
  ): Observable<string[]> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        if (resultData200 && resultData200.constructor === Array) {
          result200 = []
          for (let item of resultData200) result200.push(item)
        }
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<string[]>(<any>null)
  }

  excelValidation(filename: string): Observable<string> {
    let url_ = this.baseUrl + '/api/DoNotCallRegistry/ExcelValidation'
    url_ = url_.replace(/[?&]$/, '')

    const content_ = JSON.stringify(filename)

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('post', url_, options_)
      .flatMap((response_: any) => {
        return this.processExcelValidation(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processExcelValidation(<any>response_)
          } catch (e) {
            return <Observable<string>>(<any>Observable.throw(e))
          }
        } else return <Observable<string>>(<any>Observable.throw(response_))
      })
  }

  protected processExcelValidation(
    response: HttpResponseBase,
  ): Observable<string> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = resultData200 !== undefined ? resultData200 : <any>null
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<string>(<any>null)
  }

  excelInsert(filename: string): Observable<DoNotCallRegistryVM[]> {
    let url_ = this.baseUrl + '/api/DoNotCallRegistry/ExcelInsert'
    url_ = url_.replace(/[?&]$/, '')

    const content_ = JSON.stringify(filename)

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('post', url_, options_)
      .flatMap((response_: any) => {
        return this.processExcelInsert(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processExcelInsert(<any>response_)
          } catch (e) {
            return <Observable<DoNotCallRegistryVM[]>>(<any>Observable.throw(e))
          }
        } else
          return <Observable<DoNotCallRegistryVM[]>>(
            (<any>Observable.throw(response_))
          )
      })
  }

  protected processExcelInsert(
    response: HttpResponseBase,
  ): Observable<DoNotCallRegistryVM[]> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        if (resultData200 && resultData200.constructor === Array) {
          result200 = []
          for (let item of resultData200)
            result200.push(DoNotCallRegistryVM.fromJS(item))
        }
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<DoNotCallRegistryVM[]>(<any>null)
  }

  uploadFile(): Observable<FileResponse> {
    let url_ = this.baseUrl + '/api/DoNotCallRegistry'
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('post', url_, options_)
      .flatMap((response_: any) => {
        return this.processUploadFile(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processUploadFile(<any>response_)
          } catch (e) {
            return <Observable<FileResponse>>(<any>Observable.throw(e))
          }
        } else
          return <Observable<FileResponse>>(<any>Observable.throw(response_))
      })
  }

  protected processUploadFile(
    response: HttpResponseBase,
  ): Observable<FileResponse> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers
        ? response.headers.get('content-disposition')
        : undefined
      const fileNameMatch = contentDisposition
        ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
        : undefined
      const fileName =
        fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined
      return Observable.of({
        fileName: fileName,
        data: <any>responseBlob,
        status: status,
        headers: _headers,
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<FileResponse>(<any>null)
  }
}

@Injectable()
export class EmailTemplateService {
  private http: HttpClient
  private baseUrl: string
  protected jsonParseReviver: (key: string, value: any) => any = undefined

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string,
  ) {
    this.http = http
    this.baseUrl = baseUrl ? baseUrl : ''
  }

  emailTemplateList(
    request: DataTableRequest,
  ): Observable<EmailTemplateResponse> {
    let url_ = this.baseUrl + '/api/EmailTemplate/EmailTemplateList'
    url_ = url_.replace(/[?&]$/, '')

    const content_ = JSON.stringify(request)

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('post', url_, options_)
      .flatMap((response_: any) => {
        return this.processEmailTemplateList(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processEmailTemplateList(<any>response_)
          } catch (e) {
            return <Observable<EmailTemplateResponse>>(<any>Observable.throw(e))
          }
        } else
          return <Observable<EmailTemplateResponse>>(
            (<any>Observable.throw(response_))
          )
      })
  }

  protected processEmailTemplateList(
    response: HttpResponseBase,
  ): Observable<EmailTemplateResponse> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = resultData200
          ? EmailTemplateResponse.fromJS(resultData200)
          : <any>null
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<EmailTemplateResponse>(<any>null)
  }

  insert(request: EmailTemplate): Observable<CrudResponseemail> {
    let url_ = this.baseUrl + '/api/EmailTemplate/Insert'
    url_ = url_.replace(/[?&]$/, '')

    const content_ = JSON.stringify(request)

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('post', url_, options_)
      .flatMap((response_: any) => {
        return this.processInsert(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processInsert(<any>response_)
          } catch (e) {
            return <Observable<CrudResponseemail>>(<any>Observable.throw(e))
          }
        } else
          return <Observable<CrudResponseemail>>(
            (<any>Observable.throw(response_))
          )
      })
  }

  protected processInsert(
    response: HttpResponseBase,
  ): Observable<CrudResponseemail> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = resultData200
          ? CrudResponseemail.fromJS(resultData200)
          : <any>null
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<CrudResponseemail>(<any>null)
  }

  update(request: EmailTemplate): Observable<CrudResponseemail> {
    let url_ = this.baseUrl + '/api/EmailTemplate/Update'
    url_ = url_.replace(/[?&]$/, '')

    const content_ = JSON.stringify(request)

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('post', url_, options_)
      .flatMap((response_: any) => {
        return this.processUpdate(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processUpdate(<any>response_)
          } catch (e) {
            return <Observable<CrudResponseemail>>(<any>Observable.throw(e))
          }
        } else
          return <Observable<CrudResponseemail>>(
            (<any>Observable.throw(response_))
          )
      })
  }

  protected processUpdate(
    response: HttpResponseBase,
  ): Observable<CrudResponseemail> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = resultData200
          ? CrudResponseemail.fromJS(resultData200)
          : <any>null
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<CrudResponseemail>(<any>null)
  }

  delete(id: string): Observable<CrudResponseemail> {
    let url_ = this.baseUrl + '/api/EmailTemplate/Delete?'
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined and cannot be null.")
    else url_ += 'id=' + encodeURIComponent('' + id) + '&'
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('post', url_, options_)
      .flatMap((response_: any) => {
        return this.processDelete(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processDelete(<any>response_)
          } catch (e) {
            return <Observable<CrudResponseemail>>(<any>Observable.throw(e))
          }
        } else
          return <Observable<CrudResponseemail>>(
            (<any>Observable.throw(response_))
          )
      })
  }

  protected processDelete(
    response: HttpResponseBase,
  ): Observable<CrudResponseemail> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = resultData200
          ? CrudResponseemail.fromJS(resultData200)
          : <any>null
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<CrudResponseemail>(<any>null)
  }

  view(id: string): Observable<EmailTemplate> {
    let url_ = this.baseUrl + '/api/EmailTemplate/View?'
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined and cannot be null.")
    else url_ += 'id=' + encodeURIComponent('' + id) + '&'
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('post', url_, options_)
      .flatMap((response_: any) => {
        return this.processView(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processView(<any>response_)
          } catch (e) {
            return <Observable<EmailTemplate>>(<any>Observable.throw(e))
          }
        } else
          return <Observable<EmailTemplate>>(<any>Observable.throw(response_))
      })
  }

  protected processView(response: HttpResponseBase): Observable<EmailTemplate> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = resultData200
          ? EmailTemplate.fromJS(resultData200)
          : <any>null
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<EmailTemplate>(<any>null)
  }
}

@Injectable()
export class InvoiceService {
  private http: HttpClient
  private baseUrl: string
  protected jsonParseReviver: (key: string, value: any) => any = undefined

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string,
  ) {
    this.http = http
    this.baseUrl = baseUrl ? baseUrl : ''
  }

  invoiceDataList(
    request: InvoiceDataTableRequest,
  ): Observable<InvoiceDataResponse> {
    let url_ = this.baseUrl + '/api/Invoice/InvoiceDataList'
    url_ = url_.replace(/[?&]$/, '')

    const content_ = JSON.stringify(request)

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('post', url_, options_)
      .flatMap((response_: any) => {
        return this.processInvoiceDataList(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processInvoiceDataList(<any>response_)
          } catch (e) {
            return <Observable<InvoiceDataResponse>>(<any>Observable.throw(e))
          }
        } else
          return <Observable<InvoiceDataResponse>>(
            (<any>Observable.throw(response_))
          )
      })
  }

  protected processInvoiceDataList(
    response: HttpResponseBase,
  ): Observable<InvoiceDataResponse> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = resultData200
          ? InvoiceDataResponse.fromJS(resultData200)
          : <any>null
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<InvoiceDataResponse>(<any>null)
  }

  insert(request: Invoice): Observable<InvoiceCrudResponses> {
    let url_ = this.baseUrl + '/api/Invoice/Insert'
    url_ = url_.replace(/[?&]$/, '')

    const content_ = JSON.stringify(request)

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('post', url_, options_)
      .flatMap((response_: any) => {
        return this.processInsert(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processInsert(<any>response_)
          } catch (e) {
            return <Observable<InvoiceCrudResponses>>(<any>Observable.throw(e))
          }
        } else
          return <Observable<InvoiceCrudResponses>>(
            (<any>Observable.throw(response_))
          )
      })
  }

  protected processInsert(
    response: HttpResponseBase,
  ): Observable<InvoiceCrudResponses> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = resultData200
          ? InvoiceCrudResponses.fromJS(resultData200)
          : <any>null
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<InvoiceCrudResponses>(<any>null)
  }

  update(request: Invoice): Observable<InvoiceCrudResponses> {
    let url_ = this.baseUrl + '/api/Invoice/Update'
    url_ = url_.replace(/[?&]$/, '')

    const content_ = JSON.stringify(request)

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('post', url_, options_)
      .flatMap((response_: any) => {
        return this.processUpdate(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processUpdate(<any>response_)
          } catch (e) {
            return <Observable<InvoiceCrudResponses>>(<any>Observable.throw(e))
          }
        } else
          return <Observable<InvoiceCrudResponses>>(
            (<any>Observable.throw(response_))
          )
      })
  }

  protected processUpdate(
    response: HttpResponseBase,
  ): Observable<InvoiceCrudResponses> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = resultData200
          ? InvoiceCrudResponses.fromJS(resultData200)
          : <any>null
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<InvoiceCrudResponses>(<any>null)
  }

  delete(id: string): Observable<InvoiceCrudResponses> {
    let url_ = this.baseUrl + '/api/Invoice/Delete?'
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined and cannot be null.")
    else url_ += 'id=' + encodeURIComponent('' + id) + '&'
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('post', url_, options_)
      .flatMap((response_: any) => {
        return this.processDelete(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processDelete(<any>response_)
          } catch (e) {
            return <Observable<InvoiceCrudResponses>>(<any>Observable.throw(e))
          }
        } else
          return <Observable<InvoiceCrudResponses>>(
            (<any>Observable.throw(response_))
          )
      })
  }

  protected processDelete(
    response: HttpResponseBase,
  ): Observable<InvoiceCrudResponses> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = resultData200
          ? InvoiceCrudResponses.fromJS(resultData200)
          : <any>null
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<InvoiceCrudResponses>(<any>null)
  }

  cancel(id: string): Observable<InvoiceCrudResponses> {
    let url_ = this.baseUrl + '/api/Invoice/Cancel?'
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined and cannot be null.")
    else url_ += 'id=' + encodeURIComponent('' + id) + '&'
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('get', url_, options_)
      .flatMap((response_: any) => {
        return this.processCancel(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processCancel(<any>response_)
          } catch (e) {
            return <Observable<InvoiceCrudResponses>>(<any>Observable.throw(e))
          }
        } else
          return <Observable<InvoiceCrudResponses>>(
            (<any>Observable.throw(response_))
          )
      })
  }

  protected processCancel(
    response: HttpResponseBase,
  ): Observable<InvoiceCrudResponses> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = resultData200
          ? InvoiceCrudResponses.fromJS(resultData200)
          : <any>null
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<InvoiceCrudResponses>(<any>null)
  }

  view(id: string): Observable<TaxInvoiceReport> {
    let url_ = this.baseUrl + '/api/Invoice/View?'
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined and cannot be null.")
    else url_ += 'id=' + encodeURIComponent('' + id) + '&'
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('post', url_, options_)
      .flatMap((response_: any) => {
        return this.processView(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processView(<any>response_)
          } catch (e) {
            return <Observable<TaxInvoiceReport>>(<any>Observable.throw(e))
          }
        } else
          return <Observable<TaxInvoiceReport>>(
            (<any>Observable.throw(response_))
          )
      })
  }

  protected processView(
    response: HttpResponseBase,
  ): Observable<TaxInvoiceReport> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = resultData200
          ? TaxInvoiceReport.fromJS(resultData200)
          : <any>null
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<TaxInvoiceReport>(<any>null)
  }

  getCustomers(): Observable<Customer[]> {
    let url_ = this.baseUrl + '/api/Invoice/GetCustomers'
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('get', url_, options_)
      .flatMap((response_: any) => {
        return this.processGetCustomers(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processGetCustomers(<any>response_)
          } catch (e) {
            return <Observable<Customer[]>>(<any>Observable.throw(e))
          }
        } else return <Observable<Customer[]>>(<any>Observable.throw(response_))
      })
  }

  protected processGetCustomers(
    response: HttpResponseBase,
  ): Observable<Customer[]> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        if (resultData200 && resultData200.constructor === Array) {
          result200 = []
          for (let item of resultData200) result200.push(Customer.fromJS(item))
        }
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<Customer[]>(<any>null)
  }

  getCustomerById(customerid: string): Observable<Customer> {
    let url_ = this.baseUrl + '/api/Invoice/GetCustomerById?'
    if (customerid === undefined || customerid === null)
      throw new Error(
        "The parameter 'customerid' must be defined and cannot be null.",
      )
    else url_ += 'customerid=' + encodeURIComponent('' + customerid) + '&'
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('get', url_, options_)
      .flatMap((response_: any) => {
        return this.processGetCustomerById(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processGetCustomerById(<any>response_)
          } catch (e) {
            return <Observable<Customer>>(<any>Observable.throw(e))
          }
        } else return <Observable<Customer>>(<any>Observable.throw(response_))
      })
  }

  protected processGetCustomerById(
    response: HttpResponseBase,
  ): Observable<Customer> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = resultData200 ? Customer.fromJS(resultData200) : <any>null
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<Customer>(<any>null)
  }

  getCustlist(): Observable<CustomerVModel[]> {
    let url_ = this.baseUrl + '/api/Invoice/getCustlist'
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('get', url_, options_)
      .flatMap((response_: any) => {
        return this.processGetCustlist(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processGetCustlist(<any>response_)
          } catch (e) {
            return <Observable<CustomerVModel[]>>(<any>Observable.throw(e))
          }
        } else
          return <Observable<CustomerVModel[]>>(
            (<any>Observable.throw(response_))
          )
      })
  }

  protected processGetCustlist(
    response: HttpResponseBase,
  ): Observable<CustomerVModel[]> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        if (resultData200 && resultData200.constructor === Array) {
          result200 = []
          for (let item of resultData200)
            result200.push(CustomerVModel.fromJS(item))
        }
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<CustomerVModel[]>(<any>null)
  }

  getProducts(): Observable<ProductVm[]> {
    let url_ = this.baseUrl + '/api/Invoice/GetProducts'
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('get', url_, options_)
      .flatMap((response_: any) => {
        return this.processGetProducts(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processGetProducts(<any>response_)
          } catch (e) {
            return <Observable<ProductVm[]>>(<any>Observable.throw(e))
          }
        } else
          return <Observable<ProductVm[]>>(<any>Observable.throw(response_))
      })
  }

  protected processGetProducts(
    response: HttpResponseBase,
  ): Observable<ProductVm[]> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        if (resultData200 && resultData200.constructor === Array) {
          result200 = []
          for (let item of resultData200) result200.push(ProductVm.fromJS(item))
        }
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<ProductVm[]>(<any>null)
  }

  getProductRates(id: string): Observable<ProductPackageRate[]> {
    let url_ = this.baseUrl + '/api/Invoice/GetProductRates?'
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined and cannot be null.")
    else url_ += 'Id=' + encodeURIComponent('' + id) + '&'
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('get', url_, options_)
      .flatMap((response_: any) => {
        return this.processGetProductRates(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processGetProductRates(<any>response_)
          } catch (e) {
            return <Observable<ProductPackageRate[]>>(<any>Observable.throw(e))
          }
        } else
          return <Observable<ProductPackageRate[]>>(
            (<any>Observable.throw(response_))
          )
      })
  }

  protected processGetProductRates(
    response: HttpResponseBase,
  ): Observable<ProductPackageRate[]> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        if (resultData200 && resultData200.constructor === Array) {
          result200 = []
          for (let item of resultData200)
            result200.push(ProductPackageRate.fromJS(item))
        }
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<ProductPackageRate[]>(<any>null)
  }

  createPayment(
    invoiceId: string,
    paymentType: string,
    referance: string,
    comments: string,
    paymentAmountReceive: number,
    paymentReceievedDate: Date,
  ): Observable<SubscriptionResponse> {
    let url_ = this.baseUrl + '/api/Invoice/CreatePayment?'
    if (paymentType === undefined)
      throw new Error("The parameter 'paymentType' must be defined.")
    else url_ += 'paymentType=' + encodeURIComponent('' + paymentType) + '&'
    if (referance === undefined)
      throw new Error("The parameter 'referance' must be defined.")
    else url_ += 'referance=' + encodeURIComponent('' + referance) + '&'
    if (comments === undefined)
      throw new Error("The parameter 'comments' must be defined.")
    else url_ += 'comments=' + encodeURIComponent('' + comments) + '&'
    if (paymentAmountReceive === undefined || paymentAmountReceive === null)
      throw new Error(
        "The parameter 'paymentAmountReceive' must be defined and cannot be null.",
      )
    else
      url_ +=
        'PaymentAmountReceive=' +
        encodeURIComponent('' + paymentAmountReceive) +
        '&'
    if (paymentReceievedDate === undefined || paymentReceievedDate === null)
      throw new Error(
        "The parameter 'paymentReceievedDate' must be defined and cannot be null.",
      )
    else
      url_ +=
        'PaymentReceievedDate=' +
        encodeURIComponent(
          paymentReceievedDate ? '' + paymentReceievedDate.toJSON() : '',
        ) +
        '&'
    url_ = url_.replace(/[?&]$/, '')

    const content_ = JSON.stringify(invoiceId)

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('post', url_, options_)
      .flatMap((response_: any) => {
        return this.processCreatePayment(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processCreatePayment(<any>response_)
          } catch (e) {
            return <Observable<SubscriptionResponse>>(<any>Observable.throw(e))
          }
        } else
          return <Observable<SubscriptionResponse>>(
            (<any>Observable.throw(response_))
          )
      })
  }

  protected processCreatePayment(
    response: HttpResponseBase,
  ): Observable<SubscriptionResponse> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = resultData200
          ? SubscriptionResponse.fromJS(resultData200)
          : <any>null
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<SubscriptionResponse>(<any>null)
  }

  createCreditNote(note: Creditnote): Observable<SubscriptionResponse> {
    let url_ = this.baseUrl + '/api/Invoice/CreateCreditNote'
    url_ = url_.replace(/[?&]$/, '')

    const content_ = JSON.stringify(note)

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('post', url_, options_)
      .flatMap((response_: any) => {
        return this.processCreateCreditNote(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processCreateCreditNote(<any>response_)
          } catch (e) {
            return <Observable<SubscriptionResponse>>(<any>Observable.throw(e))
          }
        } else
          return <Observable<SubscriptionResponse>>(
            (<any>Observable.throw(response_))
          )
      })
  }

  protected processCreateCreditNote(
    response: HttpResponseBase,
  ): Observable<SubscriptionResponse> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = resultData200
          ? SubscriptionResponse.fromJS(resultData200)
          : <any>null
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<SubscriptionResponse>(<any>null)
  }

  checkExistingInvoiceId(invoiceId: string): Observable<InvoiceCrudResponses> {
    let url_ = this.baseUrl + '/api/Invoice/CheckExistingInvoiceId'
    url_ = url_.replace(/[?&]$/, '')

    const content_ = JSON.stringify(invoiceId)

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('post', url_, options_)
      .flatMap((response_: any) => {
        return this.processCheckExistingInvoiceId(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processCheckExistingInvoiceId(<any>response_)
          } catch (e) {
            return <Observable<InvoiceCrudResponses>>(<any>Observable.throw(e))
          }
        } else
          return <Observable<InvoiceCrudResponses>>(
            (<any>Observable.throw(response_))
          )
      })
  }

  protected processCheckExistingInvoiceId(
    response: HttpResponseBase,
  ): Observable<InvoiceCrudResponses> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = resultData200
          ? InvoiceCrudResponses.fromJS(resultData200)
          : <any>null
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<InvoiceCrudResponses>(<any>null)
  }

  checkExistingCreditNote(invoiceId: string): Observable<InvoiceCrudResponses> {
    let url_ = this.baseUrl + '/api/Invoice/CheckExistingCreditNote'
    url_ = url_.replace(/[?&]$/, '')

    const content_ = JSON.stringify(invoiceId)

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('post', url_, options_)
      .flatMap((response_: any) => {
        return this.processCheckExistingCreditNote(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processCheckExistingCreditNote(<any>response_)
          } catch (e) {
            return <Observable<InvoiceCrudResponses>>(<any>Observable.throw(e))
          }
        } else
          return <Observable<InvoiceCrudResponses>>(
            (<any>Observable.throw(response_))
          )
      })
  }

  protected processCheckExistingCreditNote(
    response: HttpResponseBase,
  ): Observable<InvoiceCrudResponses> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = resultData200
          ? InvoiceCrudResponses.fromJS(resultData200)
          : <any>null
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<InvoiceCrudResponses>(<any>null)
  }

  productRate(id: string): Observable<ProductPackageRate> {
    let url_ = this.baseUrl + '/api/Invoice/productRate?'
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined and cannot be null.")
    else url_ += 'id=' + encodeURIComponent('' + id) + '&'
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('get', url_, options_)
      .flatMap((response_: any) => {
        return this.processProductRate(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processProductRate(<any>response_)
          } catch (e) {
            return <Observable<ProductPackageRate>>(<any>Observable.throw(e))
          }
        } else
          return <Observable<ProductPackageRate>>(
            (<any>Observable.throw(response_))
          )
      })
  }

  protected processProductRate(
    response: HttpResponseBase,
  ): Observable<ProductPackageRate> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = resultData200
          ? ProductPackageRate.fromJS(resultData200)
          : <any>null
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<ProductPackageRate>(<any>null)
  }

  monthlyInvoice(req: InvoiceGenerationVm): Observable<string> {
    let url_ = this.baseUrl + '/api/Invoice/MonthlyInvoice'
    url_ = url_.replace(/[?&]$/, '')

    const content_ = JSON.stringify(req)

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('post', url_, options_)
      .flatMap((response_: any) => {
        return this.processMonthlyInvoice(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processMonthlyInvoice(<any>response_)
          } catch (e) {
            return <Observable<string>>(<any>Observable.throw(e))
          }
        } else return <Observable<string>>(<any>Observable.throw(response_))
      })
  }

  protected processMonthlyInvoice(
    response: HttpResponseBase,
  ): Observable<string> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = resultData200 !== undefined ? resultData200 : <any>null
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<string>(<any>null)
  }

  getValtAmount(): Observable<string> {
    let url_ = this.baseUrl + '/api/Invoice/GetValtAmount'
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('get', url_, options_)
      .flatMap((response_: any) => {
        return this.processGetValtAmount(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processGetValtAmount(<any>response_)
          } catch (e) {
            return <Observable<string>>(<any>Observable.throw(e))
          }
        } else return <Observable<string>>(<any>Observable.throw(response_))
      })
  }

  protected processGetValtAmount(
    response: HttpResponseBase,
  ): Observable<string> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = resultData200 !== undefined ? resultData200 : <any>null
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<string>(<any>null)
  }

  getValidCustomerlist(
    year: string,
    month: string,
  ): Observable<CustomerVModel[]> {
    let url_ = this.baseUrl + '/api/Invoice/GetValidCustomerlist?'
    if (year === undefined)
      throw new Error("The parameter 'year' must be defined.")
    else url_ += 'year=' + encodeURIComponent('' + year) + '&'
    if (month === undefined)
      throw new Error("The parameter 'month' must be defined.")
    else url_ += 'month=' + encodeURIComponent('' + month) + '&'
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('get', url_, options_)
      .flatMap((response_: any) => {
        return this.processGetValidCustomerlist(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processGetValidCustomerlist(<any>response_)
          } catch (e) {
            return <Observable<CustomerVModel[]>>(<any>Observable.throw(e))
          }
        } else
          return <Observable<CustomerVModel[]>>(
            (<any>Observable.throw(response_))
          )
      })
  }

  protected processGetValidCustomerlist(
    response: HttpResponseBase,
  ): Observable<CustomerVModel[]> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        if (resultData200 && resultData200.constructor === Array) {
          result200 = []
          for (let item of resultData200)
            result200.push(CustomerVModel.fromJS(item))
        }
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<CustomerVModel[]>(<any>null)
  }

  getInvoiceBulkEmail(
    styear: string,
    stmonth: string,
  ): Observable<InvoiceBulkEmail[]> {
    let url_ = this.baseUrl + '/api/Invoice/GetInvoiceBulkEmail?'
    if (styear === undefined)
      throw new Error("The parameter 'styear' must be defined.")
    else url_ += 'styear=' + encodeURIComponent('' + styear) + '&'
    if (stmonth === undefined)
      throw new Error("The parameter 'stmonth' must be defined.")
    else url_ += 'stmonth=' + encodeURIComponent('' + stmonth) + '&'
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('get', url_, options_)
      .flatMap((response_: any) => {
        return this.processGetInvoiceBulkEmail(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processGetInvoiceBulkEmail(<any>response_)
          } catch (e) {
            return <Observable<InvoiceBulkEmail[]>>(<any>Observable.throw(e))
          }
        } else
          return <Observable<InvoiceBulkEmail[]>>(
            (<any>Observable.throw(response_))
          )
      })
  }

  protected processGetInvoiceBulkEmail(
    response: HttpResponseBase,
  ): Observable<InvoiceBulkEmail[]> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        if (resultData200 && resultData200.constructor === Array) {
          result200 = []
          for (let item of resultData200)
            result200.push(InvoiceBulkEmail.fromJS(item))
        }
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<InvoiceBulkEmail[]>(<any>null)
  }

  getPDFFile(emailProperty: EmailProperty): Observable<string> {
    let url_ = this.baseUrl + '/api/Invoice/GetPDFFile'
    url_ = url_.replace(/[?&]$/, '')

    const content_ = JSON.stringify(emailProperty)

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('post', url_, options_)
      .flatMap((response_: any) => {
        return this.processGetPDFFile(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processGetPDFFile(<any>response_)
          } catch (e) {
            return <Observable<string>>(<any>Observable.throw(e))
          }
        } else return <Observable<string>>(<any>Observable.throw(response_))
      })
  }

  protected processGetPDFFile(response: HttpResponseBase): Observable<string> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = resultData200 !== undefined ? resultData200 : <any>null
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<string>(<any>null)
  }
}

@Injectable()
export class LookupDataService {
  private http: HttpClient
  private baseUrl: string
  protected jsonParseReviver: (key: string, value: any) => any = undefined

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string,
  ) {
    this.http = http
    this.baseUrl = baseUrl ? baseUrl : ''
  }

  lookupDataList(request: DataTableRequest): Observable<LookupDataResponse> {
    let url_ = this.baseUrl + '/api/LookupData/LookupDataList'
    url_ = url_.replace(/[?&]$/, '')

    const content_ = JSON.stringify(request)

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('post', url_, options_)
      .flatMap((response_: any) => {
        return this.processLookupDataList(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processLookupDataList(<any>response_)
          } catch (e) {
            return <Observable<LookupDataResponse>>(<any>Observable.throw(e))
          }
        } else
          return <Observable<LookupDataResponse>>(
            (<any>Observable.throw(response_))
          )
      })
  }

  protected processLookupDataList(
    response: HttpResponseBase,
  ): Observable<LookupDataResponse> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = resultData200
          ? LookupDataResponse.fromJS(resultData200)
          : <any>null
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<LookupDataResponse>(<any>null)
  }

  insert(request: LookupData): Observable<CrudResponse> {
    let url_ = this.baseUrl + '/api/LookupData/Insert'
    url_ = url_.replace(/[?&]$/, '')

    const content_ = JSON.stringify(request)

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('post', url_, options_)
      .flatMap((response_: any) => {
        return this.processInsert(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processInsert(<any>response_)
          } catch (e) {
            return <Observable<CrudResponse>>(<any>Observable.throw(e))
          }
        } else
          return <Observable<CrudResponse>>(<any>Observable.throw(response_))
      })
  }

  protected processInsert(
    response: HttpResponseBase,
  ): Observable<CrudResponse> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = resultData200
          ? CrudResponse.fromJS(resultData200)
          : <any>null
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<CrudResponse>(<any>null)
  }

  update(request: LookupData): Observable<CrudResponse> {
    let url_ = this.baseUrl + '/api/LookupData/Update'
    url_ = url_.replace(/[?&]$/, '')

    const content_ = JSON.stringify(request)

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('post', url_, options_)
      .flatMap((response_: any) => {
        return this.processUpdate(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processUpdate(<any>response_)
          } catch (e) {
            return <Observable<CrudResponse>>(<any>Observable.throw(e))
          }
        } else
          return <Observable<CrudResponse>>(<any>Observable.throw(response_))
      })
  }

  protected processUpdate(
    response: HttpResponseBase,
  ): Observable<CrudResponse> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = resultData200
          ? CrudResponse.fromJS(resultData200)
          : <any>null
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<CrudResponse>(<any>null)
  }

  delete(id: string): Observable<CrudResponse> {
    let url_ = this.baseUrl + '/api/LookupData/Delete?'
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined and cannot be null.")
    else url_ += 'id=' + encodeURIComponent('' + id) + '&'
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('get', url_, options_)
      .flatMap((response_: any) => {
        return this.processDelete(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processDelete(<any>response_)
          } catch (e) {
            return <Observable<CrudResponse>>(<any>Observable.throw(e))
          }
        } else
          return <Observable<CrudResponse>>(<any>Observable.throw(response_))
      })
  }

  protected processDelete(
    response: HttpResponseBase,
  ): Observable<CrudResponse> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = resultData200
          ? CrudResponse.fromJS(resultData200)
          : <any>null
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<CrudResponse>(<any>null)
  }

  view(id: string): Observable<LookupData> {
    let url_ = this.baseUrl + '/api/LookupData/View?'
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined and cannot be null.")
    else url_ += 'id=' + encodeURIComponent('' + id) + '&'
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('get', url_, options_)
      .flatMap((response_: any) => {
        return this.processView(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processView(<any>response_)
          } catch (e) {
            return <Observable<LookupData>>(<any>Observable.throw(e))
          }
        } else return <Observable<LookupData>>(<any>Observable.throw(response_))
      })
  }

  protected processView(response: HttpResponseBase): Observable<LookupData> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = resultData200 ? LookupData.fromJS(resultData200) : <any>null
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<LookupData>(<any>null)
  }
}

@Injectable()
export class PaymentService {
  private http: HttpClient
  private baseUrl: string
  protected jsonParseReviver: (key: string, value: any) => any = undefined

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string,
  ) {
    this.http = http
    this.baseUrl = baseUrl ? baseUrl : ''
  }

  paymentList(request: PaymentDataTableRequest): Observable<PaymentResponse> {
    let url_ = this.baseUrl + '/api/Payment/PaymentList'
    url_ = url_.replace(/[?&]$/, '')

    const content_ = JSON.stringify(request)

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('post', url_, options_)
      .flatMap((response_: any) => {
        return this.processPaymentList(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processPaymentList(<any>response_)
          } catch (e) {
            return <Observable<PaymentResponse>>(<any>Observable.throw(e))
          }
        } else
          return <Observable<PaymentResponse>>(<any>Observable.throw(response_))
      })
  }

  protected processPaymentList(
    response: HttpResponseBase,
  ): Observable<PaymentResponse> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = resultData200
          ? PaymentResponse.fromJS(resultData200)
          : <any>null
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<PaymentResponse>(<any>null)
  }

  insert(request: Payment): Observable<CrudResponsePayment> {
    let url_ = this.baseUrl + '/api/Payment/Insert'
    url_ = url_.replace(/[?&]$/, '')

    const content_ = JSON.stringify(request)

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('post', url_, options_)
      .flatMap((response_: any) => {
        return this.processInsert(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processInsert(<any>response_)
          } catch (e) {
            return <Observable<CrudResponsePayment>>(<any>Observable.throw(e))
          }
        } else
          return <Observable<CrudResponsePayment>>(
            (<any>Observable.throw(response_))
          )
      })
  }

  protected processInsert(
    response: HttpResponseBase,
  ): Observable<CrudResponsePayment> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = resultData200
          ? CrudResponsePayment.fromJS(resultData200)
          : <any>null
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<CrudResponsePayment>(<any>null)
  }

  update(request: Payment): Observable<CrudResponsePayment> {
    let url_ = this.baseUrl + '/api/Payment/Update'
    url_ = url_.replace(/[?&]$/, '')

    const content_ = JSON.stringify(request)

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('post', url_, options_)
      .flatMap((response_: any) => {
        return this.processUpdate(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processUpdate(<any>response_)
          } catch (e) {
            return <Observable<CrudResponsePayment>>(<any>Observable.throw(e))
          }
        } else
          return <Observable<CrudResponsePayment>>(
            (<any>Observable.throw(response_))
          )
      })
  }

  protected processUpdate(
    response: HttpResponseBase,
  ): Observable<CrudResponsePayment> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = resultData200
          ? CrudResponsePayment.fromJS(resultData200)
          : <any>null
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<CrudResponsePayment>(<any>null)
  }

  delete(id: string): Observable<CrudResponsePayment> {
    let url_ = this.baseUrl + '/api/Payment/Delete?'
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined and cannot be null.")
    else url_ += 'id=' + encodeURIComponent('' + id) + '&'
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('get', url_, options_)
      .flatMap((response_: any) => {
        return this.processDelete(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processDelete(<any>response_)
          } catch (e) {
            return <Observable<CrudResponsePayment>>(<any>Observable.throw(e))
          }
        } else
          return <Observable<CrudResponsePayment>>(
            (<any>Observable.throw(response_))
          )
      })
  }

  protected processDelete(
    response: HttpResponseBase,
  ): Observable<CrudResponsePayment> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = resultData200
          ? CrudResponsePayment.fromJS(resultData200)
          : <any>null
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<CrudResponsePayment>(<any>null)
  }

  getCustomers(): Observable<Customer[]> {
    let url_ = this.baseUrl + '/api/Payment/GetCustomers'
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('get', url_, options_)
      .flatMap((response_: any) => {
        return this.processGetCustomers(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processGetCustomers(<any>response_)
          } catch (e) {
            return <Observable<Customer[]>>(<any>Observable.throw(e))
          }
        } else return <Observable<Customer[]>>(<any>Observable.throw(response_))
      })
  }

  protected processGetCustomers(
    response: HttpResponseBase,
  ): Observable<Customer[]> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        if (resultData200 && resultData200.constructor === Array) {
          result200 = []
          for (let item of resultData200) result200.push(Customer.fromJS(item))
        }
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<Customer[]>(<any>null)
  }

  getCustomerById(customerid: string): Observable<Customer> {
    let url_ = this.baseUrl + '/api/Payment/GetCustomerById?'
    if (customerid === undefined || customerid === null)
      throw new Error(
        "The parameter 'customerid' must be defined and cannot be null.",
      )
    else url_ += 'customerid=' + encodeURIComponent('' + customerid) + '&'
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('get', url_, options_)
      .flatMap((response_: any) => {
        return this.processGetCustomerById(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processGetCustomerById(<any>response_)
          } catch (e) {
            return <Observable<Customer>>(<any>Observable.throw(e))
          }
        } else return <Observable<Customer>>(<any>Observable.throw(response_))
      })
  }

  protected processGetCustomerById(
    response: HttpResponseBase,
  ): Observable<Customer> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = resultData200 ? Customer.fromJS(resultData200) : <any>null
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<Customer>(<any>null)
  }

  getPaymentLookupvalues(): Observable<LookupData[]> {
    let url_ = this.baseUrl + '/api/Payment/GetPaymentLookupvalues'
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('get', url_, options_)
      .flatMap((response_: any) => {
        return this.processGetPaymentLookupvalues(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processGetPaymentLookupvalues(<any>response_)
          } catch (e) {
            return <Observable<LookupData[]>>(<any>Observable.throw(e))
          }
        } else
          return <Observable<LookupData[]>>(<any>Observable.throw(response_))
      })
  }

  protected processGetPaymentLookupvalues(
    response: HttpResponseBase,
  ): Observable<LookupData[]> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        if (resultData200 && resultData200.constructor === Array) {
          result200 = []
          for (let item of resultData200)
            result200.push(LookupData.fromJS(item))
        }
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<LookupData[]>(<any>null)
  }

  view(id: string): Observable<Payment> {
    let url_ = this.baseUrl + '/api/Payment/View?'
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined and cannot be null.")
    else url_ += 'id=' + encodeURIComponent('' + id) + '&'
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('get', url_, options_)
      .flatMap((response_: any) => {
        return this.processView(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processView(<any>response_)
          } catch (e) {
            return <Observable<Payment>>(<any>Observable.throw(e))
          }
        } else return <Observable<Payment>>(<any>Observable.throw(response_))
      })
  }

  protected processView(response: HttpResponseBase): Observable<Payment> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = resultData200 ? Payment.fromJS(resultData200) : <any>null
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<Payment>(<any>null)
  }
}

@Injectable()
export class ProFormaInvoiceService {
  private http: HttpClient
  private baseUrl: string
  protected jsonParseReviver: (key: string, value: any) => any = undefined

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string,
  ) {
    this.http = http
    this.baseUrl = baseUrl ? baseUrl : ''
  }

  proFormaInvoiceDataList(
    request: ProFormaInvoiceDataTableRequest,
  ): Observable<ProFormaInvoiceDataResponse> {
    let url_ = this.baseUrl + '/api/ProFormaInvoice/ProFormaInvoiceDataList'
    url_ = url_.replace(/[?&]$/, '')

    const content_ = JSON.stringify(request)

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('post', url_, options_)
      .flatMap((response_: any) => {
        return this.processProFormaInvoiceDataList(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processProFormaInvoiceDataList(<any>response_)
          } catch (e) {
            return <Observable<ProFormaInvoiceDataResponse>>(
              (<any>Observable.throw(e))
            )
          }
        } else
          return <Observable<ProFormaInvoiceDataResponse>>(
            (<any>Observable.throw(response_))
          )
      })
  }

  protected processProFormaInvoiceDataList(
    response: HttpResponseBase,
  ): Observable<ProFormaInvoiceDataResponse> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = resultData200
          ? ProFormaInvoiceDataResponse.fromJS(resultData200)
          : <any>null
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<ProFormaInvoiceDataResponse>(<any>null)
  }

  insert(request: ProFormaInvoice): Observable<ProFormaInvoiceCrudResponses> {
    let url_ = this.baseUrl + '/api/ProFormaInvoice/Insert'
    url_ = url_.replace(/[?&]$/, '')

    const content_ = JSON.stringify(request)

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('post', url_, options_)
      .flatMap((response_: any) => {
        return this.processInsert(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processInsert(<any>response_)
          } catch (e) {
            return <Observable<ProFormaInvoiceCrudResponses>>(
              (<any>Observable.throw(e))
            )
          }
        } else
          return <Observable<ProFormaInvoiceCrudResponses>>(
            (<any>Observable.throw(response_))
          )
      })
  }

  protected processInsert(
    response: HttpResponseBase,
  ): Observable<ProFormaInvoiceCrudResponses> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = resultData200
          ? ProFormaInvoiceCrudResponses.fromJS(resultData200)
          : <any>null
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<ProFormaInvoiceCrudResponses>(<any>null)
  }

  finalInvoiceSave(data: ProFormaInvoice): Observable<boolean> {
    let url_ = this.baseUrl + '/api/ProFormaInvoice/FinalInvoiceSave'
    url_ = url_.replace(/[?&]$/, '')

    const content_ = JSON.stringify(data)

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('post', url_, options_)
      .flatMap((response_: any) => {
        return this.processFinalInvoiceSave(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processFinalInvoiceSave(<any>response_)
          } catch (e) {
            return <Observable<boolean>>(<any>Observable.throw(e))
          }
        } else return <Observable<boolean>>(<any>Observable.throw(response_))
      })
  }

  protected processFinalInvoiceSave(
    response: HttpResponseBase,
  ): Observable<boolean> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = resultData200 !== undefined ? resultData200 : <any>null
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<boolean>(<any>null)
  }

  update(request: ProFormaInvoice): Observable<ProFormaInvoiceCrudResponses> {
    let url_ = this.baseUrl + '/api/ProFormaInvoice/Update'
    url_ = url_.replace(/[?&]$/, '')

    const content_ = JSON.stringify(request)

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('post', url_, options_)
      .flatMap((response_: any) => {
        return this.processUpdate(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processUpdate(<any>response_)
          } catch (e) {
            return <Observable<ProFormaInvoiceCrudResponses>>(
              (<any>Observable.throw(e))
            )
          }
        } else
          return <Observable<ProFormaInvoiceCrudResponses>>(
            (<any>Observable.throw(response_))
          )
      })
  }

  protected processUpdate(
    response: HttpResponseBase,
  ): Observable<ProFormaInvoiceCrudResponses> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = resultData200
          ? ProFormaInvoiceCrudResponses.fromJS(resultData200)
          : <any>null
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<ProFormaInvoiceCrudResponses>(<any>null)
  }

  cancel(request: ProFormaInvoice): Observable<ProFormaInvoiceCrudResponses> {
    let url_ = this.baseUrl + '/api/ProFormaInvoice/Cancel'
    url_ = url_.replace(/[?&]$/, '')

    const content_ = JSON.stringify(request)

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('post', url_, options_)
      .flatMap((response_: any) => {
        return this.processCancel(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processCancel(<any>response_)
          } catch (e) {
            return <Observable<ProFormaInvoiceCrudResponses>>(
              (<any>Observable.throw(e))
            )
          }
        } else
          return <Observable<ProFormaInvoiceCrudResponses>>(
            (<any>Observable.throw(response_))
          )
      })
  }

  protected processCancel(
    response: HttpResponseBase,
  ): Observable<ProFormaInvoiceCrudResponses> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = resultData200
          ? ProFormaInvoiceCrudResponses.fromJS(resultData200)
          : <any>null
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<ProFormaInvoiceCrudResponses>(<any>null)
  }

  delete(id: string): Observable<ProFormaInvoiceCrudResponses> {
    let url_ = this.baseUrl + '/api/ProFormaInvoice/Delete?'
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined and cannot be null.")
    else url_ += 'id=' + encodeURIComponent('' + id) + '&'
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('get', url_, options_)
      .flatMap((response_: any) => {
        return this.processDelete(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processDelete(<any>response_)
          } catch (e) {
            return <Observable<ProFormaInvoiceCrudResponses>>(
              (<any>Observable.throw(e))
            )
          }
        } else
          return <Observable<ProFormaInvoiceCrudResponses>>(
            (<any>Observable.throw(response_))
          )
      })
  }

  protected processDelete(
    response: HttpResponseBase,
  ): Observable<ProFormaInvoiceCrudResponses> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = resultData200
          ? ProFormaInvoiceCrudResponses.fromJS(resultData200)
          : <any>null
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<ProFormaInvoiceCrudResponses>(<any>null)
  }

  proformaProductsRemove(id: string): Observable<ProformaInvoiceLineItem[]> {
    let url_ = this.baseUrl + '/api/ProFormaInvoice/ProformaProductsRemove?'
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined and cannot be null.")
    else url_ += 'id=' + encodeURIComponent('' + id) + '&'
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('get', url_, options_)
      .flatMap((response_: any) => {
        return this.processProformaProductsRemove(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processProformaProductsRemove(<any>response_)
          } catch (e) {
            return <Observable<ProformaInvoiceLineItem[]>>(
              (<any>Observable.throw(e))
            )
          }
        } else
          return <Observable<ProformaInvoiceLineItem[]>>(
            (<any>Observable.throw(response_))
          )
      })
  }

  protected processProformaProductsRemove(
    response: HttpResponseBase,
  ): Observable<ProformaInvoiceLineItem[]> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        if (resultData200 && resultData200.constructor === Array) {
          result200 = []
          for (let item of resultData200)
            result200.push(ProformaInvoiceLineItem.fromJS(item))
        }
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<ProformaInvoiceLineItem[]>(<any>null)
  }

  applicationSetting(): Observable<number> {
    let url_ = this.baseUrl + '/api/ProFormaInvoice/ApplicationSetting'
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('get', url_, options_)
      .flatMap((response_: any) => {
        return this.processApplicationSetting(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processApplicationSetting(<any>response_)
          } catch (e) {
            return <Observable<number>>(<any>Observable.throw(e))
          }
        } else return <Observable<number>>(<any>Observable.throw(response_))
      })
  }

  protected processApplicationSetting(
    response: HttpResponseBase,
  ): Observable<number> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = resultData200 !== undefined ? resultData200 : <any>null
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<number>(<any>null)
  }

  view(id: string): Observable<ProFormaReport> {
    let url_ = this.baseUrl + '/api/ProFormaInvoice/View?'
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined and cannot be null.")
    else url_ += 'id=' + encodeURIComponent('' + id) + '&'
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('get', url_, options_)
      .flatMap((response_: any) => {
        return this.processView(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processView(<any>response_)
          } catch (e) {
            return <Observable<ProFormaReport>>(<any>Observable.throw(e))
          }
        } else
          return <Observable<ProFormaReport>>(<any>Observable.throw(response_))
      })
  }

  protected processView(
    response: HttpResponseBase,
  ): Observable<ProFormaReport> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = resultData200
          ? ProFormaReport.fromJS(resultData200)
          : <any>null
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<ProFormaReport>(<any>null)
  }

  getProFormaInvoiceBulkEmail(
    styear: string,
    stmonth: string,
  ): Observable<ProFormaInvoiceBulkEmail[]> {
    let url_ =
      this.baseUrl + '/api/ProFormaInvoice/GetProFormaInvoiceBulkEmail?'
    if (styear === undefined)
      throw new Error("The parameter 'styear' must be defined.")
    else url_ += 'styear=' + encodeURIComponent('' + styear) + '&'
    if (stmonth === undefined)
      throw new Error("The parameter 'stmonth' must be defined.")
    else url_ += 'stmonth=' + encodeURIComponent('' + stmonth) + '&'
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('get', url_, options_)
      .flatMap((response_: any) => {
        return this.processGetProFormaInvoiceBulkEmail(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processGetProFormaInvoiceBulkEmail(<any>response_)
          } catch (e) {
            return <Observable<ProFormaInvoiceBulkEmail[]>>(
              (<any>Observable.throw(e))
            )
          }
        } else
          return <Observable<ProFormaInvoiceBulkEmail[]>>(
            (<any>Observable.throw(response_))
          )
      })
  }

  protected processGetProFormaInvoiceBulkEmail(
    response: HttpResponseBase,
  ): Observable<ProFormaInvoiceBulkEmail[]> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        if (resultData200 && resultData200.constructor === Array) {
          result200 = []
          for (let item of resultData200)
            result200.push(ProFormaInvoiceBulkEmail.fromJS(item))
        }
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<ProFormaInvoiceBulkEmail[]>(<any>null)
  }

  ratesAdd(): Observable<ProFormaInvoice> {
    let url_ = this.baseUrl + '/api/ProFormaInvoice/RatesAdd'
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('get', url_, options_)
      .flatMap((response_: any) => {
        return this.processRatesAdd(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processRatesAdd(<any>response_)
          } catch (e) {
            return <Observable<ProFormaInvoice>>(<any>Observable.throw(e))
          }
        } else
          return <Observable<ProFormaInvoice>>(<any>Observable.throw(response_))
      })
  }

  protected processRatesAdd(
    response: HttpResponseBase,
  ): Observable<ProFormaInvoice> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = resultData200
          ? ProFormaInvoice.fromJS(resultData200)
          : <any>null
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<ProFormaInvoice>(<any>null)
  }

  getCustomers(): Observable<Customer[]> {
    let url_ = this.baseUrl + '/api/ProFormaInvoice/GetCustomers'
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('get', url_, options_)
      .flatMap((response_: any) => {
        return this.processGetCustomers(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processGetCustomers(<any>response_)
          } catch (e) {
            return <Observable<Customer[]>>(<any>Observable.throw(e))
          }
        } else return <Observable<Customer[]>>(<any>Observable.throw(response_))
      })
  }

  protected processGetCustomers(
    response: HttpResponseBase,
  ): Observable<Customer[]> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        if (resultData200 && resultData200.constructor === Array) {
          result200 = []
          for (let item of resultData200) result200.push(Customer.fromJS(item))
        }
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<Customer[]>(<any>null)
  }

  getCustomerById(customerid: string): Observable<Customer> {
    let url_ = this.baseUrl + '/api/ProFormaInvoice/GetCustomerById?'
    if (customerid === undefined || customerid === null)
      throw new Error(
        "The parameter 'customerid' must be defined and cannot be null.",
      )
    else url_ += 'customerid=' + encodeURIComponent('' + customerid) + '&'
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('get', url_, options_)
      .flatMap((response_: any) => {
        return this.processGetCustomerById(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processGetCustomerById(<any>response_)
          } catch (e) {
            return <Observable<Customer>>(<any>Observable.throw(e))
          }
        } else return <Observable<Customer>>(<any>Observable.throw(response_))
      })
  }

  protected processGetCustomerById(
    response: HttpResponseBase,
  ): Observable<Customer> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = resultData200 ? Customer.fromJS(resultData200) : <any>null
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<Customer>(<any>null)
  }

  getProducts(): Observable<ProductVmodel[]> {
    let url_ = this.baseUrl + '/api/ProFormaInvoice/GetProducts'
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('get', url_, options_)
      .flatMap((response_: any) => {
        return this.processGetProducts(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processGetProducts(<any>response_)
          } catch (e) {
            return <Observable<ProductVmodel[]>>(<any>Observable.throw(e))
          }
        } else
          return <Observable<ProductVmodel[]>>(<any>Observable.throw(response_))
      })
  }

  protected processGetProducts(
    response: HttpResponseBase,
  ): Observable<ProductVmodel[]> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        if (resultData200 && resultData200.constructor === Array) {
          result200 = []
          for (let item of resultData200)
            result200.push(ProductVmodel.fromJS(item))
        }
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<ProductVmodel[]>(<any>null)
  }

  createPayment(invoiceId: string): Observable<string> {
    let url_ = this.baseUrl + '/api/ProFormaInvoice/CreatePayment?'
    if (invoiceId === undefined || invoiceId === null)
      throw new Error(
        "The parameter 'invoiceId' must be defined and cannot be null.",
      )
    else url_ += 'invoiceId=' + encodeURIComponent('' + invoiceId) + '&'
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('get', url_, options_)
      .flatMap((response_: any) => {
        return this.processCreatePayment(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processCreatePayment(<any>response_)
          } catch (e) {
            return <Observable<string>>(<any>Observable.throw(e))
          }
        } else return <Observable<string>>(<any>Observable.throw(response_))
      })
  }

  protected processCreatePayment(
    response: HttpResponseBase,
  ): Observable<string> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = resultData200 !== undefined ? resultData200 : <any>null
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<string>(<any>null)
  }

  getPDFFile(emailProperty: EmailProperty): Observable<string> {
    let url_ = this.baseUrl + '/api/ProFormaInvoice/GetPDFFile'
    url_ = url_.replace(/[?&]$/, '')

    const content_ = JSON.stringify(emailProperty)

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('post', url_, options_)
      .flatMap((response_: any) => {
        return this.processGetPDFFile(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processGetPDFFile(<any>response_)
          } catch (e) {
            return <Observable<string>>(<any>Observable.throw(e))
          }
        } else return <Observable<string>>(<any>Observable.throw(response_))
      })
  }

  protected processGetPDFFile(response: HttpResponseBase): Observable<string> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = resultData200 !== undefined ? resultData200 : <any>null
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<string>(<any>null)
  }

  savePdfFile(emailProperty: EmailProperty): Observable<string> {
    let url_ = this.baseUrl + '/api/ProFormaInvoice/SavePdfFile'
    url_ = url_.replace(/[?&]$/, '')

    const content_ = JSON.stringify(emailProperty)

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('post', url_, options_)
      .flatMap((response_: any) => {
        return this.processSavePdfFile(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processSavePdfFile(<any>response_)
          } catch (e) {
            return <Observable<string>>(<any>Observable.throw(e))
          }
        } else return <Observable<string>>(<any>Observable.throw(response_))
      })
  }

  protected processSavePdfFile(response: HttpResponseBase): Observable<string> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = resultData200 !== undefined ? resultData200 : <any>null
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<string>(<any>null)
  }
}

@Injectable()
export class SecurityService {
  private http: HttpClient
  private baseUrl: string
  protected jsonParseReviver: (key: string, value: any) => any = undefined

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string,
  ) {
    this.http = http
    this.baseUrl = baseUrl ? baseUrl : ''
  }

  login(request: LoginRequest): Observable<LoginReponse> {
    let url_ = this.baseUrl + '/api/Security/Login'
    url_ = url_.replace(/[?&]$/, '')

    const content_ = JSON.stringify(request)

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('post', url_, options_)
      .flatMap((response_: any) => {
        return this.processLogin(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processLogin(<any>response_)
          } catch (e) {
            return <Observable<LoginReponse>>(<any>Observable.throw(e))
          }
        } else
          return <Observable<LoginReponse>>(<any>Observable.throw(response_))
      })
  }

  protected processLogin(response: HttpResponseBase): Observable<LoginReponse> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = resultData200
          ? LoginReponse.fromJS(resultData200)
          : <any>null
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<LoginReponse>(<any>null)
  }

  getUserMenu(id: string): Observable<Menu[]> {
    let url_ = this.baseUrl + '/api/Security/GetUserMenu?'
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined and cannot be null.")
    else url_ += 'Id=' + encodeURIComponent('' + id) + '&'
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('get', url_, options_)
      .flatMap((response_: any) => {
        return this.processGetUserMenu(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processGetUserMenu(<any>response_)
          } catch (e) {
            return <Observable<Menu[]>>(<any>Observable.throw(e))
          }
        } else return <Observable<Menu[]>>(<any>Observable.throw(response_))
      })
  }

  protected processGetUserMenu(response: HttpResponseBase): Observable<Menu[]> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        if (resultData200 && resultData200.constructor === Array) {
          result200 = []
          for (let item of resultData200) result200.push(Menu.fromJS(item))
        }
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<Menu[]>(<any>null)
  }

  getSearchCustomers(
    request: SearchCustomerRequest,
  ): Observable<SearchCustomerResponse[]> {
    let url_ = this.baseUrl + '/api/Security/GetSearchCustomers'
    url_ = url_.replace(/[?&]$/, '')

    const content_ = JSON.stringify(request)

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    }

    return this.http
      .request('post', url_, options_)
      .flatMap((response_: any) => {
        return this.processGetSearchCustomers(response_)
      })
      .catch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processGetSearchCustomers(<any>response_)
          } catch (e) {
            return <Observable<SearchCustomerResponse[]>>(
              (<any>Observable.throw(e))
            )
          }
        } else
          return <Observable<SearchCustomerResponse[]>>(
            (<any>Observable.throw(response_))
          )
      })
  }

  protected processGetSearchCustomers(
    response: HttpResponseBase,
  ): Observable<SearchCustomerResponse[]> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver)
        if (resultData200 && resultData200.constructor === Array) {
          result200 = []
          for (let item of resultData200)
            result200.push(SearchCustomerResponse.fromJS(item))
        }
        return Observable.of(result200)
      })
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).flatMap((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Observable.of<SearchCustomerResponse[]>(<any>null)
  }
}

export class DataTableRequest implements IDataTableRequest {
  id: string
  draw: number
  start: number
  length: number
  search?: Search
  order?: OrderColumn[]
  columns?: Column[]

  constructor(data?: IDataTableRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.id = data['id']
      this.draw = data['draw']
      this.start = data['start']
      this.length = data['length']
      this.search = data['search']
        ? Search.fromJS(data['search'])
        : <any>undefined
      if (data['order'] && data['order'].constructor === Array) {
        this.order = []
        for (let item of data['order'])
          this.order.push(OrderColumn.fromJS(item))
      }
      if (data['columns'] && data['columns'].constructor === Array) {
        this.columns = []
        for (let item of data['columns']) this.columns.push(Column.fromJS(item))
      }
    }
  }

  static fromJS(data: any): DataTableRequest {
    data = typeof data === 'object' ? data : {}
    let result = new DataTableRequest()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['id'] = this.id
    data['draw'] = this.draw
    data['start'] = this.start
    data['length'] = this.length
    data['search'] = this.search ? this.search.toJSON() : <any>undefined
    if (this.order && this.order.constructor === Array) {
      data['order'] = []
      for (let item of this.order) data['order'].push(item.toJSON())
    }
    if (this.columns && this.columns.constructor === Array) {
      data['columns'] = []
      for (let item of this.columns) data['columns'].push(item.toJSON())
    }
    return data
  }
}

export interface IDataTableRequest {
  id: string
  draw: number
  start: number
  length: number
  search?: Search
  order?: OrderColumn[]
  columns?: Column[]
}

export class Search implements ISearch {
  value?: string
  regex?: string

  constructor(data?: ISearch) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.value = data['value']
      this.regex = data['regex']
    }
  }

  static fromJS(data: any): Search {
    data = typeof data === 'object' ? data : {}
    let result = new Search()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['value'] = this.value
    data['regex'] = this.regex
    return data
  }
}

export interface ISearch {
  value?: string
  regex?: string
}

export class OrderColumn implements IOrderColumn {
  column?: string
  dir?: string

  constructor(data?: IOrderColumn) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.column = data['column']
      this.dir = data['dir']
    }
  }

  static fromJS(data: any): OrderColumn {
    data = typeof data === 'object' ? data : {}
    let result = new OrderColumn()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['column'] = this.column
    data['dir'] = this.dir
    return data
  }
}

export interface IOrderColumn {
  column?: string
  dir?: string
}

export class Column implements IColumn {
  data?: string
  name?: string
  searchable: boolean
  orderable?: string
  search?: Search

  constructor(data?: IColumn) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.data = data['data']
      this.name = data['name']
      this.searchable = data['searchable']
      this.orderable = data['orderable']
      this.search = data['search']
        ? Search.fromJS(data['search'])
        : <any>undefined
    }
  }

  static fromJS(data: any): Column {
    data = typeof data === 'object' ? data : {}
    let result = new Column()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['data'] = this.data
    data['name'] = this.name
    data['searchable'] = this.searchable
    data['orderable'] = this.orderable
    data['search'] = this.search ? this.search.toJSON() : <any>undefined
    return data
  }
}

export interface IColumn {
  data?: string
  name?: string
  searchable: boolean
  orderable?: string
  search?: Search
}

export class DataTableResponseOfSetting implements IDataTableResponseOfSetting {
  draw: number
  recordsFiltered: number
  recordsTotal: number
  data?: Setting[]

  constructor(data?: IDataTableResponseOfSetting) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.draw = data['draw']
      this.recordsFiltered = data['recordsFiltered']
      this.recordsTotal = data['recordsTotal']
      if (data['data'] && data['data'].constructor === Array) {
        this.data = []
        for (let item of data['data']) this.data.push(Setting.fromJS(item))
      }
    }
  }

  static fromJS(data: any): DataTableResponseOfSetting {
    data = typeof data === 'object' ? data : {}
    let result = new DataTableResponseOfSetting()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['draw'] = this.draw
    data['recordsFiltered'] = this.recordsFiltered
    data['recordsTotal'] = this.recordsTotal
    if (this.data && this.data.constructor === Array) {
      data['data'] = []
      for (let item of this.data) data['data'].push(item.toJSON())
    }
    return data
  }
}

export interface IDataTableResponseOfSetting {
  draw: number
  recordsFiltered: number
  recordsTotal: number
  data?: Setting[]
}

export class SettingDataResponse extends DataTableResponseOfSetting
  implements ISettingDataResponse {
  constructor(data?: ISettingDataResponse) {
    super(data)
  }

  init(data?: any) {
    super.init(data)
    if (data) {
    }
  }

  static fromJS(data: any): SettingDataResponse {
    data = typeof data === 'object' ? data : {}
    let result = new SettingDataResponse()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    super.toJSON(data)
    return data
  }
}

export interface ISettingDataResponse extends IDataTableResponseOfSetting {}

export class Setting implements ISetting {
  id: string
  settingName?: string
  settingValue?: string
  remarks?: string

  constructor(data?: ISetting) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.id = data['id']
      this.settingName = data['settingName']
      this.settingValue = data['settingValue']
      this.remarks = data['remarks']
    }
  }

  static fromJS(data: any): Setting {
    data = typeof data === 'object' ? data : {}
    let result = new Setting()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['id'] = this.id
    data['settingName'] = this.settingName
    data['settingValue'] = this.settingValue
    data['remarks'] = this.remarks
    return data
  }
}

export interface ISetting {
  id: string
  settingName?: string
  settingValue?: string
  remarks?: string
}

export class ApplicationSetting implements IApplicationSetting {
  id: string
  settingName?: string
  settingValue?: string
  remarks?: string

  constructor(data?: IApplicationSetting) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.id = data['id']
      this.settingName = data['settingName']
      this.settingValue = data['settingValue']
      this.remarks = data['remarks']
    }
  }

  static fromJS(data: any): ApplicationSetting {
    data = typeof data === 'object' ? data : {}
    let result = new ApplicationSetting()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['id'] = this.id
    data['settingName'] = this.settingName
    data['settingValue'] = this.settingValue
    data['remarks'] = this.remarks
    return data
  }
}

export interface IApplicationSetting {
  id: string
  settingName?: string
  settingValue?: string
  remarks?: string
}

export class SettingCrudResponse implements ISettingCrudResponse {
  message?: string
  isSuccess: boolean

  constructor(data?: ISettingCrudResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.message = data['message']
      this.isSuccess = data['isSuccess']
    }
  }

  static fromJS(data: any): SettingCrudResponse {
    data = typeof data === 'object' ? data : {}
    let result = new SettingCrudResponse()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['message'] = this.message
    data['isSuccess'] = this.isSuccess
    return data
  }
}

export interface ISettingCrudResponse {
  message?: string
  isSuccess: boolean
}

export class BatchDataTableRequest implements IBatchDataTableRequest {
  fromdate?: string
  todate?: string
  customerId: string
  dtRequest?: DataTableRequest
  isFileExists: boolean

  constructor(data?: IBatchDataTableRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.fromdate = data['fromdate']
      this.todate = data['todate']
      this.customerId = data['customerId']
      this.dtRequest = data['dtRequest']
        ? DataTableRequest.fromJS(data['dtRequest'])
        : <any>undefined
      this.isFileExists = data['isFileExists']
    }
  }

  static fromJS(data: any): BatchDataTableRequest {
    data = typeof data === 'object' ? data : {}
    let result = new BatchDataTableRequest()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['fromdate'] = this.fromdate
    data['todate'] = this.todate
    data['customerId'] = this.customerId
    data['dtRequest'] = this.dtRequest
      ? this.dtRequest.toJSON()
      : <any>undefined
    data['isFileExists'] = this.isFileExists
    return data
  }
}

export interface IBatchDataTableRequest {
  fromdate?: string
  todate?: string
  customerId: string
  dtRequest?: DataTableRequest
  isFileExists: boolean
}

export class DataTableResponseOfBatchTraceVM
  implements IDataTableResponseOfBatchTraceVM {
  draw: number
  recordsFiltered: number
  recordsTotal: number
  data?: BatchTraceVM[]

  constructor(data?: IDataTableResponseOfBatchTraceVM) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.draw = data['draw']
      this.recordsFiltered = data['recordsFiltered']
      this.recordsTotal = data['recordsTotal']
      if (data['data'] && data['data'].constructor === Array) {
        this.data = []
        for (let item of data['data']) this.data.push(BatchTraceVM.fromJS(item))
      }
    }
  }

  static fromJS(data: any): DataTableResponseOfBatchTraceVM {
    data = typeof data === 'object' ? data : {}
    let result = new DataTableResponseOfBatchTraceVM()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['draw'] = this.draw
    data['recordsFiltered'] = this.recordsFiltered
    data['recordsTotal'] = this.recordsTotal
    if (this.data && this.data.constructor === Array) {
      data['data'] = []
      for (let item of this.data) data['data'].push(item.toJSON())
    }
    return data
  }
}

export interface IDataTableResponseOfBatchTraceVM {
  draw: number
  recordsFiltered: number
  recordsTotal: number
  data?: BatchTraceVM[]
}

export class BatchTracingDataTableResponse
  extends DataTableResponseOfBatchTraceVM
  implements IBatchTracingDataTableResponse {
  constructor(data?: IBatchTracingDataTableResponse) {
    super(data)
  }

  init(data?: any) {
    super.init(data)
    if (data) {
    }
  }

  static fromJS(data: any): BatchTracingDataTableResponse {
    data = typeof data === 'object' ? data : {}
    let result = new BatchTracingDataTableResponse()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    super.toJSON(data)
    return data
  }
}

export interface IBatchTracingDataTableResponse
  extends IDataTableResponseOfBatchTraceVM {}

export class BatchTraceVM implements IBatchTraceVM {
  id: string
  customerUser?: CustomerUser
  customerUserID: string
  fileName?: string
  batchNumber?: string
  uploadDate?: string
  totalRecords: number
  foundRecords: number
  customerName?: string
  isDataDownloaded: boolean
  proFormaInvoiceId?: string
  proFormaInvoiceNumber?: string
  adminCertified: boolean
  customerId?: string
  isFileExists: boolean

  constructor(data?: IBatchTraceVM) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.id = data['id']
      this.customerUser = data['customerUser']
        ? CustomerUser.fromJS(data['customerUser'])
        : <any>undefined
      this.customerUserID = data['customerUserID']
      this.fileName = data['fileName']
      this.batchNumber = data['batchNumber']
      this.uploadDate = data['uploadDate']
      this.totalRecords = data['totalRecords']
      this.foundRecords = data['foundRecords']
      this.customerName = data['customerName']
      this.isDataDownloaded = data['isDataDownloaded']
      this.proFormaInvoiceId = data['proFormaInvoiceId']
      this.proFormaInvoiceNumber = data['proFormaInvoiceNumber']
      this.adminCertified = data['adminCertified']
      this.customerId = data['customerId']
      this.isFileExists = data['isFileExists']
    }
  }

  static fromJS(data: any): BatchTraceVM {
    data = typeof data === 'object' ? data : {}
    let result = new BatchTraceVM()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['id'] = this.id
    data['customerUser'] = this.customerUser
      ? this.customerUser.toJSON()
      : <any>undefined
    data['customerUserID'] = this.customerUserID
    data['fileName'] = this.fileName
    data['batchNumber'] = this.batchNumber
    data['uploadDate'] = this.uploadDate
    data['totalRecords'] = this.totalRecords
    data['foundRecords'] = this.foundRecords
    data['customerName'] = this.customerName
    data['isDataDownloaded'] = this.isDataDownloaded
    data['proFormaInvoiceId'] = this.proFormaInvoiceId
    data['proFormaInvoiceNumber'] = this.proFormaInvoiceNumber
    data['adminCertified'] = this.adminCertified
    data['customerId'] = this.customerId
    data['isFileExists'] = this.isFileExists
    return data
  }
}

export interface IBatchTraceVM {
  id: string
  customerUser?: CustomerUser
  customerUserID: string
  fileName?: string
  batchNumber?: string
  uploadDate?: string
  totalRecords: number
  foundRecords: number
  customerName?: string
  isDataDownloaded: boolean
  proFormaInvoiceId?: string
  proFormaInvoiceNumber?: string
  adminCertified: boolean
  customerId?: string
  isFileExists: boolean
}

export class CustomerUser implements ICustomerUser {
  id: string
  firstName: string
  lastName: string
  title: string
  idNumber: string
  email: string
  password?: string
  isAdmin?: boolean
  MAchAddressCHK?: boolean
  MacAddresses: string
  status?: string
  customerId: string
  customer?: Customer
  code?: string
  subscription?: Subscription
  subscriptionId?: string
  phoneNumber?: string
  message?: string
  createdDate?: Date
  createdBy?: string
  modifiedDate?: Date
  modifiedBy?: string
  activatedBy?: string
  activatedDate?: Date
  lastLoginDate?: Date
  batchwithoutSub?: boolean
  isUserLoggedIn?: boolean
  isRestricted?: boolean
  leadswithoutSub?: boolean

  constructor(data?: ICustomerUser) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.id = data['id']
      this.firstName = data['firstName']
      this.lastName = data['lastName']
      this.title = data['title']
      this.idNumber = data['idNumber']
      this.email = data['email']
      this.password = data['password']
      this.isAdmin = data['isAdmin']
      this.status = data['status']
      this.customerId = data['customerId']
      this.customer = data['customer']
        ? Customer.fromJS(data['customer'])
        : <any>undefined
      this.code = data['code']
      this.subscription = data['subscription']
        ? Subscription.fromJS(data['subscription'])
        : <any>undefined
      this.subscriptionId = data['subscriptionId']
      this.phoneNumber = data['phoneNumber']
      this.message = data['message']
      this.createdDate = data['createdDate']
        ? new Date(data['createdDate'].toString())
        : <any>undefined
      this.createdBy = data['createdBy']
      this.modifiedDate = data['modifiedDate']
        ? new Date(data['modifiedDate'].toString())
        : <any>undefined
      this.modifiedBy = data['modifiedBy']
      this.activatedBy = data['activatedBy']
      this.activatedDate = data['activatedDate']
        ? new Date(data['activatedDate'].toString())
        : <any>undefined
      this.lastLoginDate = data['lastLoginDate']
        ? new Date(data['lastLoginDate'].toString())
        : <any>undefined
      this.batchwithoutSub = data['batchwithoutSub']
      this.isUserLoggedIn = data['isUserLoggedIn']
      this.isRestricted = data['isRestricted']
      this.leadswithoutSub = data['leadswithoutSub']
    }
  }

  static fromJS(data: any): CustomerUser {
    data = typeof data === 'object' ? data : {}
    let result = new CustomerUser()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['id'] = this.id
    data['firstName'] = this.firstName
    data['lastName'] = this.lastName
    data['title'] = this.title
    data['idNumber'] = this.idNumber
    data['email'] = this.email
    data['password'] = this.password
    data['isAdmin'] = this.isAdmin
    data['MAchAddressCHK'] = this.MAchAddressCHK
    data['MacAddresses'] = this.MacAddresses
    data['status'] = this.status
    data['customerId'] = this.customerId
    data['customer'] = this.customer ? this.customer.toJSON() : <any>undefined
    data['code'] = this.code
    data['subscription'] = this.subscription
      ? this.subscription.toJSON()
      : <any>undefined
    data['subscriptionId'] = this.subscriptionId
    data['phoneNumber'] = this.phoneNumber
    data['message'] = this.message
    data['createdDate'] = this.createdDate
      ? this.createdDate.toISOString()
      : <any>undefined
    data['createdBy'] = this.createdBy
    data['modifiedDate'] = this.modifiedDate
      ? this.modifiedDate.toISOString()
      : <any>undefined
    data['modifiedBy'] = this.modifiedBy
    data['activatedBy'] = this.activatedBy
    data['activatedDate'] = this.activatedDate
      ? this.activatedDate.toISOString()
      : <any>undefined
    data['lastLoginDate'] = this.lastLoginDate
      ? this.lastLoginDate.toISOString()
      : <any>undefined
    data['batchwithoutSub'] = this.batchwithoutSub
    data['isUserLoggedIn'] = this.isUserLoggedIn
    data['isRestricted'] = this.isRestricted
    data['leadswithoutSub'] = this.leadswithoutSub
    return data
  }
}

export interface ICustomerUser {
  id: string
  firstName: string
  lastName: string
  title: string
  idNumber: string
  email: string
  password?: string
  isAdmin?: boolean
  status?: string
  customerId: string
  customer?: Customer
  code?: string
  subscription?: Subscription
  subscriptionId?: string
  phoneNumber?: string
  message?: string
  createdDate?: Date
  createdBy?: string
  modifiedDate?: Date
  modifiedBy?: string
  activatedBy?: string
  activatedDate?: Date
  lastLoginDate?: Date
  batchwithoutSub?: boolean
  isUserLoggedIn?: boolean
  isRestricted?: boolean
  leadswithoutSub?: boolean
}

export class Customer implements ICustomer {
  id: string
  tradingName: string
  registrationName: string
  registrationNumber: string
  vatNumber?: string
  branchLocation?: string
  physicalAddress: string
  typeOfBusiness: string
  telephoneNumber: string
  faxNumber?: string
  billingEmail?: string
  status?: string
  billingType?: string
  code?: string
  turnover: boolean
  isRestricted: boolean
  custOwnIDNumber?: string
  postalAddress?: string
  webAddress?: string
  accountDeptContactPerson?: string
  accountDeptTelephoneNumber?: string
  accountDeptFaxNumber?: string
  authIDNumber?: string
  authPosition?: string
  accountDeptEmail?: string
  authFirstName?: string
  authSurName?: string
  authCellNumber: string
  authEmail?: string
  businessDescription?: string
  creditBureauInformation?: string
  purpose?: string
  createdDate?: Date
  createdBy?: string
  modifiedDate?: Date
  modifiedBy?: string
  activatedBy?: string
  activatedDate?: Date
  customerUsers?: CustomerUser[]
  customerProducts?: CustomerProduct[]
  tabSelected?: string
  isXDS: boolean
  subscriberId?: string
  enquiryReason?: string
  constructor(data?: ICustomer) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.id = data['id']
      this.tradingName = data['tradingName']
      this.registrationName = data['registrationName']
      this.registrationNumber = data['registrationNumber']
      this.vatNumber = data['vatNumber']
      this.branchLocation = data['branchLocation']
      this.physicalAddress = data['physicalAddress']
      this.typeOfBusiness = data['typeOfBusiness']
      this.isXDS = data['isXDS']
      this.subscriberId = data['subscriberId']
      this.enquiryReason = data['enquiryReason']
      this.telephoneNumber = data['telephoneNumber']
      this.faxNumber = data['faxNumber']
      this.billingEmail = data['billingEmail']
      this.status = data['status']
      this.billingType = data['billingType']
      this.code = data['code']
      this.turnover = data['turnover']
      this.isRestricted = data['isRestricted']
      this.custOwnIDNumber = data['custOwnIDNumber']
      this.postalAddress = data['postalAddress']
      this.webAddress = data['webAddress']
      this.accountDeptContactPerson = data['accountDeptContactPerson']
      this.accountDeptTelephoneNumber = data['accountDeptTelephoneNumber']
      this.accountDeptFaxNumber = data['accountDeptFaxNumber']
      this.authIDNumber = data['authIDNumber']
      this.authPosition = data['authPosition']
      this.accountDeptEmail = data['accountDeptEmail']
      this.authFirstName = data['authFirstName']
      this.authSurName = data['authSurName']
      this.authCellNumber = data['authCellNumber']
      this.authEmail = data['authEmail']
      this.businessDescription = data['businessDescription']
      this.creditBureauInformation = data['creditBureauInformation']
      this.purpose = data['purpose']
      this.createdDate = data['createdDate']
        ? new Date(data['createdDate'].toString())
        : <any>undefined
      this.createdBy = data['createdBy']
      this.modifiedDate = data['modifiedDate']
        ? new Date(data['modifiedDate'].toString())
        : <any>undefined
      this.modifiedBy = data['modifiedBy']
      this.activatedBy = data['activatedBy']
      this.activatedDate = data['activatedDate']
        ? new Date(data['activatedDate'].toString())
        : <any>undefined
      if (
        data['customerUsers'] &&
        data['customerUsers'].constructor === Array
      ) {
        this.customerUsers = []
        for (let item of data['customerUsers'])
          this.customerUsers.push(CustomerUser.fromJS(item))
      }
      if (
        data['customerProducts'] &&
        data['customerProducts'].constructor === Array
      ) {
        this.customerProducts = []
        for (let item of data['customerProducts'])
          this.customerProducts.push(CustomerProduct.fromJS(item))
      }
      this.tabSelected = data['tabSelected']
    }
  }

  static fromJS(data: any): Customer {
    data = typeof data === 'object' ? data : {}
    let result = new Customer()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['id'] = this.id
    data['tradingName'] = this.tradingName
    data['registrationName'] = this.registrationName
    data['registrationNumber'] = this.registrationNumber
    data['vatNumber'] = this.vatNumber
    data['branchLocation'] = this.branchLocation
    data['physicalAddress'] = this.physicalAddress
    data['typeOfBusiness'] = this.typeOfBusiness

    data['isXDS'] = this.isXDS
    data['subscriberId'] = this.subscriberId
    data['enquiryReason'] = this.enquiryReason

    data['telephoneNumber'] = this.telephoneNumber
    data['faxNumber'] = this.faxNumber
    data['billingEmail'] = this.billingEmail
    data['status'] = this.status
    data['billingType'] = this.billingType
    data['code'] = this.code
    data['turnover'] = this.turnover
    data['isRestricted'] = this.isRestricted
    data['custOwnIDNumber'] = this.custOwnIDNumber
    data['postalAddress'] = this.postalAddress
    data['webAddress'] = this.webAddress
    data['accountDeptContactPerson'] = this.accountDeptContactPerson
    data['accountDeptTelephoneNumber'] = this.accountDeptTelephoneNumber
    data['accountDeptFaxNumber'] = this.accountDeptFaxNumber
    data['authIDNumber'] = this.authIDNumber
    data['authPosition'] = this.authPosition
    data['accountDeptEmail'] = this.accountDeptEmail
    data['authFirstName'] = this.authFirstName
    data['authSurName'] = this.authSurName
    data['authCellNumber'] = this.authCellNumber
    data['authEmail'] = this.authEmail
    data['businessDescription'] = this.businessDescription
    data['creditBureauInformation'] = this.creditBureauInformation
    data['purpose'] = this.purpose
    data['createdDate'] = this.createdDate
      ? this.createdDate.toISOString()
      : <any>undefined
    data['createdBy'] = this.createdBy
    data['modifiedDate'] = this.modifiedDate
      ? this.modifiedDate.toISOString()
      : <any>undefined
    data['modifiedBy'] = this.modifiedBy
    data['activatedBy'] = this.activatedBy
    data['activatedDate'] = this.activatedDate
      ? this.activatedDate.toISOString()
      : <any>undefined
    if (this.customerUsers && this.customerUsers.constructor === Array) {
      data['customerUsers'] = []
      for (let item of this.customerUsers)
        data['customerUsers'].push(item.toJSON())
    }
    if (this.customerProducts && this.customerProducts.constructor === Array) {
      data['customerProducts'] = []
      for (let item of this.customerProducts)
        data['customerProducts'].push(item.toJSON())
    }
    data['tabSelected'] = this.tabSelected

    return data
  }
}

export interface ICustomer {
  id: string
  tradingName: string
  registrationName: string
  registrationNumber: string
  vatNumber?: string
  branchLocation?: string
  physicalAddress: string
  typeOfBusiness: string
  telephoneNumber: string
  faxNumber?: string
  billingEmail?: string
  status?: string
  billingType?: string
  code?: string
  turnover: boolean
  isRestricted: boolean
  custOwnIDNumber?: string
  postalAddress?: string
  webAddress?: string
  accountDeptContactPerson?: string
  accountDeptTelephoneNumber?: string
  accountDeptFaxNumber?: string
  authIDNumber?: string
  authPosition?: string
  accountDeptEmail?: string
  authFirstName?: string
  authSurName?: string
  authCellNumber: string
  authEmail?: string
  businessDescription?: string
  creditBureauInformation?: string
  purpose?: string
  createdDate?: Date
  createdBy?: string
  modifiedDate?: Date
  modifiedBy?: string
  activatedBy?: string
  activatedDate?: Date
  customerUsers?: CustomerUser[]
  customerProducts?: CustomerProduct[]
  tabSelected?: string
  isXDS: boolean
  subscriberId?: string
  enquiryReason?: string
}

export class CustomerProduct implements ICustomerProduct {
  id: string
  customerId: string
  productId: string
  product?: Product
  active?: boolean
  createdDate?: Date
  modifiedDate?: Date
  createdBy?: string
  modifiedBy?: string

  constructor(data?: ICustomerProduct) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.id = data['id']
      this.customerId = data['customerId']
      this.productId = data['productId']
      this.product = data['product']
        ? Product.fromJS(data['product'])
        : <any>undefined
      this.active = data['active']
      this.createdDate = data['createdDate']
        ? new Date(data['createdDate'].toString())
        : <any>undefined
      this.modifiedDate = data['modifiedDate']
        ? new Date(data['modifiedDate'].toString())
        : <any>undefined
      this.createdBy = data['createdBy']
      this.modifiedBy = data['modifiedBy']
    }
  }

  static fromJS(data: any): CustomerProduct {
    data = typeof data === 'object' ? data : {}
    let result = new CustomerProduct()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['id'] = this.id
    data['customerId'] = this.customerId
    data['productId'] = this.productId
    data['product'] = this.product ? this.product.toJSON() : <any>undefined
    data['active'] = this.active
    data['createdDate'] = this.createdDate
      ? this.createdDate.toISOString()
      : <any>undefined
    data['modifiedDate'] = this.modifiedDate
      ? this.modifiedDate.toISOString()
      : <any>undefined
    data['createdBy'] = this.createdBy
    data['modifiedBy'] = this.modifiedBy
    return data
  }
}

export interface ICustomerProduct {
  id: string
  customerId: string
  productId: string
  product?: Product
  active?: boolean
  createdDate?: Date
  modifiedDate?: Date
  createdBy?: string
  modifiedBy?: string
}

export class Product implements IProduct {
  id: string
  name?: string
  packageRates?: ProductPackageRate[]
  status: boolean
  createdOn: Date
  activatedDate: Date
  deactivatedDate: Date
  lastUpdatedDate: Date
  service?: Service
  serviceId: string
  usageType?: string
  isPostpaid: boolean
  code?: string
  batchProduct?: boolean
  leadProduct?: boolean

  constructor(data?: IProduct) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.id = data['id']
      this.name = data['name']
      if (data['packageRates'] && data['packageRates'].constructor === Array) {
        this.packageRates = []
        for (let item of data['packageRates'])
          this.packageRates.push(ProductPackageRate.fromJS(item))
      }
      this.status = data['status']
      this.createdOn = data['createdOn']
        ? new Date(data['createdOn'].toString())
        : <any>undefined
      this.activatedDate = data['activatedDate']
        ? new Date(data['activatedDate'].toString())
        : <any>undefined
      this.deactivatedDate = data['deactivatedDate']
        ? new Date(data['deactivatedDate'].toString())
        : <any>undefined
      this.lastUpdatedDate = data['lastUpdatedDate']
        ? new Date(data['lastUpdatedDate'].toString())
        : <any>undefined
      this.service = data['service']
        ? Service.fromJS(data['service'])
        : <any>undefined
      this.serviceId = data['serviceId']
      this.usageType = data['usageType']
      this.isPostpaid = data['isPostpaid']
      this.code = data['code']
      this.batchProduct = data['batchProduct']
      this.leadProduct = data['leadProduct']
    }
  }

  static fromJS(data: any): Product {
    data = typeof data === 'object' ? data : {}
    let result = new Product()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['id'] = this.id
    data['name'] = this.name
    if (this.packageRates && this.packageRates.constructor === Array) {
      data['packageRates'] = []
      for (let item of this.packageRates)
        data['packageRates'].push(item.toJSON())
    }
    data['status'] = this.status
    data['createdOn'] = this.createdOn
      ? this.createdOn.toISOString()
      : <any>undefined
    data['activatedDate'] = this.activatedDate
      ? this.activatedDate.toISOString()
      : <any>undefined
    data['deactivatedDate'] = this.deactivatedDate
      ? this.deactivatedDate.toISOString()
      : <any>undefined
    data['lastUpdatedDate'] = this.lastUpdatedDate
      ? this.lastUpdatedDate.toISOString()
      : <any>undefined
    data['service'] = this.service ? this.service.toJSON() : <any>undefined
    data['serviceId'] = this.serviceId
    data['usageType'] = this.usageType
    data['isPostpaid'] = this.isPostpaid
    data['code'] = this.code
    data['batchProduct'] = this.batchProduct
    data['leadProduct'] = this.leadProduct
    return data
  }
}

export interface IProduct {
  id: string
  name?: string
  packageRates?: ProductPackageRate[]
  status: boolean
  createdOn: Date
  activatedDate: Date
  deactivatedDate: Date
  lastUpdatedDate: Date
  service?: Service
  serviceId: string
  usageType?: string
  isPostpaid: boolean
  code?: string
  batchProduct?: boolean
  leadProduct?: boolean
}

export class ProductPackageRate implements IProductPackageRate {
  id: string
  product?: Product
  productId: string
  minLimit: number
  maxLimit: number
  isDeleted: number
  unitPrice: number

  constructor(data?: IProductPackageRate) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.id = data['id']
      this.product = data['product']
        ? Product.fromJS(data['product'])
        : <any>undefined
      this.productId = data['productId']
      this.minLimit = data['minLimit']
      this.maxLimit = data['maxLimit']
      this.isDeleted = data['isDeleted']
      this.unitPrice = data['unitPrice']
    }
  }

  static fromJS(data: any): ProductPackageRate {
    data = typeof data === 'object' ? data : {}
    let result = new ProductPackageRate()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['id'] = this.id
    data['product'] = this.product ? this.product.toJSON() : <any>undefined
    data['productId'] = this.productId
    data['minLimit'] = this.minLimit
    data['maxLimit'] = this.maxLimit
    data['isDeleted'] = this.isDeleted
    data['unitPrice'] = this.unitPrice
    return data
  }
}

export interface IProductPackageRate {
  id: string
  product?: Product
  productId: string
  minLimit: number
  maxLimit: number
  isDeleted: number
  unitPrice: number
}

export class Service implements IService {
  id: string
  name?: string
  code?: string
  isActive: boolean
  createdDate?: Date
  createdBy?: string
  modifiedDate?: Date
  modifiedBy?: string

  constructor(data?: IService) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.id = data['id']
      this.name = data['name']
      this.code = data['code']
      this.isActive = data['isActive']
      this.createdDate = data['createdDate']
        ? new Date(data['createdDate'].toString())
        : <any>undefined
      this.createdBy = data['createdBy']
      this.modifiedDate = data['modifiedDate']
        ? new Date(data['modifiedDate'].toString())
        : <any>undefined
      this.modifiedBy = data['modifiedBy']
    }
  }

  static fromJS(data: any): Service {
    data = typeof data === 'object' ? data : {}
    let result = new Service()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['id'] = this.id
    data['name'] = this.name
    data['code'] = this.code
    data['isActive'] = this.isActive
    data['createdDate'] = this.createdDate
      ? this.createdDate.toISOString()
      : <any>undefined
    data['createdBy'] = this.createdBy
    data['modifiedDate'] = this.modifiedDate
      ? this.modifiedDate.toISOString()
      : <any>undefined
    data['modifiedBy'] = this.modifiedBy
    return data
  }
}

export interface IService {
  id: string
  name?: string
  code?: string
  isActive: boolean
  createdDate?: Date
  createdBy?: string
  modifiedDate?: Date
  modifiedBy?: string
}

export class Subscription implements ISubscription {
  id: string
  customer?: Customer
  customerId: string
  number: number
  date: Date
  subDisplayNumber?: string
  isAutoBilled: boolean
  subscriptionItems?: SubscriptionItem[]

  constructor(data?: ISubscription) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.id = data['id']
      this.customer = data['customer']
        ? Customer.fromJS(data['customer'])
        : <any>undefined
      this.customerId = data['customerId']
      this.number = data['number']
      this.date = data['date']
        ? new Date(data['date'].toString())
        : <any>undefined
      this.subDisplayNumber = data['subDisplayNumber']
      this.isAutoBilled = data['isAutoBilled']
      if (
        data['subscriptionItems'] &&
        data['subscriptionItems'].constructor === Array
      ) {
        this.subscriptionItems = []
        for (let item of data['subscriptionItems'])
          this.subscriptionItems.push(SubscriptionItem.fromJS(item))
      }
    }
  }

  static fromJS(data: any): Subscription {
    data = typeof data === 'object' ? data : {}
    let result = new Subscription()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['id'] = this.id
    data['customer'] = this.customer ? this.customer.toJSON() : <any>undefined
    data['customerId'] = this.customerId
    data['number'] = this.number
    data['date'] = this.date ? this.date.toISOString() : <any>undefined
    data['subDisplayNumber'] = this.subDisplayNumber
    data['isAutoBilled'] = this.isAutoBilled
    if (
      this.subscriptionItems &&
      this.subscriptionItems.constructor === Array
    ) {
      data['subscriptionItems'] = []
      for (let item of this.subscriptionItems)
        data['subscriptionItems'].push(item.toJSON())
    }
    return data
  }
}

export interface ISubscription {
  id: string
  customer?: Customer
  customerId: string
  number: number
  date: Date
  subDisplayNumber?: string
  isAutoBilled: boolean
  subscriptionItems?: SubscriptionItem[]
}

export class SubscriptionItem implements ISubscriptionItem {
  id: string
  productPackage?: ProductPackageRate
  productPackageId: string
  status?: string
  startDate: Date
  endDate: Date
  billingType?: string
  duration: number
  quantity: number
  rate: number
  subscription?: Subscription
  subscriptionId: string
  isBilled?: boolean
  proRataPrice: number
  proRataNetAmount: number

  constructor(data?: ISubscriptionItem) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.id = data['id']
      this.productPackage = data['productPackage']
        ? ProductPackageRate.fromJS(data['productPackage'])
        : <any>undefined
      this.productPackageId = data['productPackageId']
      this.status = data['status']
      this.startDate = data['startDate']
        ? new Date(data['startDate'].toString())
        : <any>undefined
      this.endDate = data['endDate']
        ? new Date(data['endDate'].toString())
        : <any>undefined
      this.billingType = data['billingType']
      this.duration = data['duration']
      this.quantity = data['quantity']
      this.rate = data['rate']
      this.subscription = data['subscription']
        ? Subscription.fromJS(data['subscription'])
        : <any>undefined
      this.subscriptionId = data['subscriptionId']
      this.isBilled = data['isBilled']
      this.proRataPrice = data['proRataPrice']
      this.proRataNetAmount = data['proRataNetAmount']
    }
  }

  static fromJS(data: any): SubscriptionItem {
    data = typeof data === 'object' ? data : {}
    let result = new SubscriptionItem()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['id'] = this.id
    data['productPackage'] = this.productPackage
      ? this.productPackage.toJSON()
      : <any>undefined
    data['productPackageId'] = this.productPackageId
    data['status'] = this.status
    data['startDate'] = this.startDate
      ? this.startDate.toISOString()
      : <any>undefined
    data['endDate'] = this.endDate ? this.endDate.toISOString() : <any>undefined
    data['billingType'] = this.billingType
    data['duration'] = this.duration
    data['quantity'] = this.quantity
    data['rate'] = this.rate
    data['subscription'] = this.subscription
      ? this.subscription.toJSON()
      : <any>undefined
    data['subscriptionId'] = this.subscriptionId
    data['isBilled'] = this.isBilled
    data['proRataPrice'] = this.proRataPrice
    data['proRataNetAmount'] = this.proRataNetAmount
    return data
  }
}

export interface ISubscriptionItem {
  id: string
  productPackage?: ProductPackageRate
  productPackageId: string
  status?: string
  startDate: Date
  endDate: Date
  billingType?: string
  duration: number
  quantity: number
  rate: number
  subscription?: Subscription
  subscriptionId: string
  isBilled?: boolean
  proRataPrice: number
  proRataNetAmount: number
}

export class BatchtraceResponse implements IBatchtraceResponse {
  message?: string
  isSuccess: boolean

  constructor(data?: IBatchtraceResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.message = data['message']
      this.isSuccess = data['isSuccess']
    }
  }

  static fromJS(data: any): BatchtraceResponse {
    data = typeof data === 'object' ? data : {}
    let result = new BatchtraceResponse()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['message'] = this.message
    data['isSuccess'] = this.isSuccess
    return data
  }
}

export interface IBatchtraceResponse {
  message?: string
  isSuccess: boolean
}

export class ContactUsSearchRequest implements IContactUsSearchRequest {
  isRead?: string
  fromdate?: string
  todate?: string
  dtRequest?: DataTableRequest

  constructor(data?: IContactUsSearchRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.isRead = data['isRead']
      this.fromdate = data['fromdate']
      this.todate = data['todate']
      this.dtRequest = data['dtRequest']
        ? DataTableRequest.fromJS(data['dtRequest'])
        : <any>undefined
    }
  }

  static fromJS(data: any): ContactUsSearchRequest {
    data = typeof data === 'object' ? data : {}
    let result = new ContactUsSearchRequest()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['isRead'] = this.isRead
    data['fromdate'] = this.fromdate
    data['todate'] = this.todate
    data['dtRequest'] = this.dtRequest
      ? this.dtRequest.toJSON()
      : <any>undefined
    return data
  }
}

export interface IContactUsSearchRequest {
  isRead?: string
  fromdate?: string
  todate?: string
  dtRequest?: DataTableRequest
}

export class DataTableResponseOfContactUsVm
  implements IDataTableResponseOfContactUsVm {
  draw: number
  recordsFiltered: number
  recordsTotal: number
  data?: ContactUsVm[]

  constructor(data?: IDataTableResponseOfContactUsVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.draw = data['draw']
      this.recordsFiltered = data['recordsFiltered']
      this.recordsTotal = data['recordsTotal']
      if (data['data'] && data['data'].constructor === Array) {
        this.data = []
        for (let item of data['data']) this.data.push(ContactUsVm.fromJS(item))
      }
    }
  }

  static fromJS(data: any): DataTableResponseOfContactUsVm {
    data = typeof data === 'object' ? data : {}
    let result = new DataTableResponseOfContactUsVm()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['draw'] = this.draw
    data['recordsFiltered'] = this.recordsFiltered
    data['recordsTotal'] = this.recordsTotal
    if (this.data && this.data.constructor === Array) {
      data['data'] = []
      for (let item of this.data) data['data'].push(item.toJSON())
    }
    return data
  }
}

export interface IDataTableResponseOfContactUsVm {
  draw: number
  recordsFiltered: number
  recordsTotal: number
  data?: ContactUsVm[]
}

export class ContactusResponse extends DataTableResponseOfContactUsVm
  implements IContactusResponse {
  constructor(data?: IContactusResponse) {
    super(data)
  }

  init(data?: any) {
    super.init(data)
    if (data) {
    }
  }

  static fromJS(data: any): ContactusResponse {
    data = typeof data === 'object' ? data : {}
    let result = new ContactusResponse()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    super.toJSON(data)
    return data
  }
}

export interface IContactusResponse extends IDataTableResponseOfContactUsVm {}

export class ContactUsVm implements IContactUsVm {
  id: string
  contactName?: string
  email?: string
  subject?: string
  message?: string
  date: Date
  isRead: boolean
  phoneNumber?: string
  business?: string

  constructor(data?: IContactUsVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.id = data['id']
      this.contactName = data['contactName']
      this.email = data['email']
      this.subject = data['subject']
      this.message = data['message']
      this.date = data['date']
        ? new Date(data['date'].toString())
        : <any>undefined
      this.isRead = data['isRead']
      this.phoneNumber = data['phoneNumber']
      this.business = data['business']
    }
  }

  static fromJS(data: any): ContactUsVm {
    data = typeof data === 'object' ? data : {}
    let result = new ContactUsVm()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['id'] = this.id
    data['contactName'] = this.contactName
    data['email'] = this.email
    data['subject'] = this.subject
    data['message'] = this.message
    data['date'] = this.date ? this.date.toISOString() : <any>undefined
    data['isRead'] = this.isRead
    data['phoneNumber'] = this.phoneNumber
    data['business'] = this.business
    return data
  }
}

export interface IContactUsVm {
  id: string
  contactName?: string
  email?: string
  subject?: string
  message?: string
  date: Date
  isRead: boolean
  phoneNumber?: string
  business?: string
}

export class ContactUs implements IContactUs {
  id: string
  name?: string
  email?: string
  phoneNumber?: string
  business?: string
  subject?: string
  message?: string
  date: Date
  isRead: boolean

  constructor(data?: IContactUs) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.id = data['id']
      this.name = data['name']
      this.email = data['email']
      this.phoneNumber = data['phoneNumber']
      this.business = data['business']
      this.subject = data['subject']
      this.message = data['message']
      this.date = data['date']
        ? new Date(data['date'].toString())
        : <any>undefined
      this.isRead = data['isRead']
    }
  }

  static fromJS(data: any): ContactUs {
    data = typeof data === 'object' ? data : {}
    let result = new ContactUs()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['id'] = this.id
    data['name'] = this.name
    data['email'] = this.email
    data['phoneNumber'] = this.phoneNumber
    data['business'] = this.business
    data['subject'] = this.subject
    data['message'] = this.message
    data['date'] = this.date ? this.date.toISOString() : <any>undefined
    data['isRead'] = this.isRead
    return data
  }
}

export interface IContactUs {
  id: string
  name?: string
  email?: string
  phoneNumber?: string
  business?: string
  subject?: string
  message?: string
  date: Date
  isRead: boolean
}

export class DataTableResponseOfApplicationmessage
  implements IDataTableResponseOfApplicationmessage {
  draw: number
  recordsFiltered: number
  recordsTotal: number
  data?: Applicationmessage[]

  constructor(data?: IDataTableResponseOfApplicationmessage) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.draw = data['draw']
      this.recordsFiltered = data['recordsFiltered']
      this.recordsTotal = data['recordsTotal']
      if (data['data'] && data['data'].constructor === Array) {
        this.data = []
        for (let item of data['data'])
          this.data.push(Applicationmessage.fromJS(item))
      }
    }
  }

  static fromJS(data: any): DataTableResponseOfApplicationmessage {
    data = typeof data === 'object' ? data : {}
    let result = new DataTableResponseOfApplicationmessage()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['draw'] = this.draw
    data['recordsFiltered'] = this.recordsFiltered
    data['recordsTotal'] = this.recordsTotal
    if (this.data && this.data.constructor === Array) {
      data['data'] = []
      for (let item of this.data) data['data'].push(item.toJSON())
    }
    return data
  }
}

export interface IDataTableResponseOfApplicationmessage {
  draw: number
  recordsFiltered: number
  recordsTotal: number
  data?: Applicationmessage[]
}

export class ApplicationmessageResponse
  extends DataTableResponseOfApplicationmessage
  implements IApplicationmessageResponse {
  constructor(data?: IApplicationmessageResponse) {
    super(data)
  }

  init(data?: any) {
    super.init(data)
    if (data) {
    }
  }

  static fromJS(data: any): ApplicationmessageResponse {
    data = typeof data === 'object' ? data : {}
    let result = new ApplicationmessageResponse()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    super.toJSON(data)
    return data
  }
}

export interface IApplicationmessageResponse
  extends IDataTableResponseOfApplicationmessage {}

export class Applicationmessage implements IApplicationmessage {
  id: string
  name?: string
  message?: string
  showmessage: boolean

  constructor(data?: IApplicationmessage) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.id = data['id']
      this.name = data['name']
      this.message = data['message']
      this.showmessage = data['showmessage']
    }
  }

  static fromJS(data: any): Applicationmessage {
    data = typeof data === 'object' ? data : {}
    let result = new Applicationmessage()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['id'] = this.id
    data['name'] = this.name
    data['message'] = this.message
    data['showmessage'] = this.showmessage
    return data
  }
}

export interface IApplicationmessage {
  id: string
  name?: string
  message?: string
  showmessage: boolean
}

export class ApplicationMessage implements IApplicationMessage {
  id: string
  name?: string
  message?: string
  showmessage: boolean

  constructor(data?: IApplicationMessage) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.id = data['id']
      this.name = data['name']
      this.message = data['message']
      this.showmessage = data['showmessage']
    }
  }

  static fromJS(data: any): ApplicationMessage {
    data = typeof data === 'object' ? data : {}
    let result = new ApplicationMessage()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['id'] = this.id
    data['name'] = this.name
    data['message'] = this.message
    data['showmessage'] = this.showmessage
    return data
  }
}

export interface IApplicationMessage {
  id: string
  name?: string
  message?: string
  showmessage: boolean
}

export class CrudResponseMessage implements ICrudResponseMessage {
  message?: string
  isSuccess: boolean

  constructor(data?: ICrudResponseMessage) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.message = data['message']
      this.isSuccess = data['isSuccess']
    }
  }

  static fromJS(data: any): CrudResponseMessage {
    data = typeof data === 'object' ? data : {}
    let result = new CrudResponseMessage()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['message'] = this.message
    data['isSuccess'] = this.isSuccess
    return data
  }
}

export interface ICrudResponseMessage {
  message?: string
  isSuccess: boolean
}

export class CustomerUserRequest implements ICustomerUserRequest {
  id: string
  dtRequest?: DataTableRequest

  constructor(data?: ICustomerUserRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.id = data['id']
      this.dtRequest = data['dtRequest']
        ? DataTableRequest.fromJS(data['dtRequest'])
        : <any>undefined
    }
  }

  static fromJS(data: any): CustomerUserRequest {
    data = typeof data === 'object' ? data : {}
    let result = new CustomerUserRequest()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['id'] = this.id
    data['dtRequest'] = this.dtRequest
      ? this.dtRequest.toJSON()
      : <any>undefined
    return data
  }
}

export interface ICustomerUserRequest {
  id: string
  dtRequest?: DataTableRequest
}

export class DataTableResponseOfcustomerusr
  implements IDataTableResponseOfcustomerusr {
  draw: number
  recordsFiltered: number
  recordsTotal: number
  data?: Customerusr[]

  constructor(data?: IDataTableResponseOfcustomerusr) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.draw = data['draw']
      this.recordsFiltered = data['recordsFiltered']
      this.recordsTotal = data['recordsTotal']
      if (data['data'] && data['data'].constructor === Array) {
        this.data = []
        for (let item of data['data']) this.data.push(Customerusr.fromJS(item))
      }
    }
  }

  static fromJS(data: any): DataTableResponseOfcustomerusr {
    data = typeof data === 'object' ? data : {}
    let result = new DataTableResponseOfcustomerusr()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['draw'] = this.draw
    data['recordsFiltered'] = this.recordsFiltered
    data['recordsTotal'] = this.recordsTotal
    if (this.data && this.data.constructor === Array) {
      data['data'] = []
      for (let item of this.data) data['data'].push(item.toJSON())
    }
    return data
  }
}

export interface IDataTableResponseOfcustomerusr {
  draw: number
  recordsFiltered: number
  recordsTotal: number
  data?: Customerusr[]
}

export class CustomerUserResponse extends DataTableResponseOfcustomerusr
  implements ICustomerUserResponse {
  constructor(data?: ICustomerUserResponse) {
    super(data)
  }

  init(data?: any) {
    super.init(data)
    if (data) {
    }
  }

  static fromJS(data: any): CustomerUserResponse {
    data = typeof data === 'object' ? data : {}
    let result = new CustomerUserResponse()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    super.toJSON(data)
    return data
  }
}

export interface ICustomerUserResponse
  extends IDataTableResponseOfcustomerusr {}

export class Customerusr implements ICustomerusr {
  id: string
  firstName?: string
  lastName?: string
  title?: string
  idNumber?: string
  email?: string
  password?: string
  isAdmin: boolean
  status?: string
  customerId: string
  customer?: Customer

  constructor(data?: ICustomerusr) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.id = data['id']
      this.firstName = data['firstName']
      this.lastName = data['lastName']
      this.title = data['title']
      this.idNumber = data['idNumber']
      this.email = data['email']
      this.password = data['password']
      this.isAdmin = data['isAdmin']
      this.status = data['status']
      this.customerId = data['customerId']
      this.customer = data['customer']
        ? Customer.fromJS(data['customer'])
        : <any>undefined
    }
  }

  static fromJS(data: any): Customerusr {
    data = typeof data === 'object' ? data : {}
    let result = new Customerusr()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['id'] = this.id
    data['firstName'] = this.firstName
    data['lastName'] = this.lastName
    data['title'] = this.title
    data['idNumber'] = this.idNumber
    data['email'] = this.email
    data['password'] = this.password
    data['isAdmin'] = this.isAdmin
    data['status'] = this.status
    data['customerId'] = this.customerId
    data['customer'] = this.customer ? this.customer.toJSON() : <any>undefined
    return data
  }
}

export interface ICustomerusr {
  id: string
  firstName?: string
  lastName?: string
  title?: string
  idNumber?: string
  email?: string
  password?: string
  isAdmin: boolean
  status?: string
  customerId: string
  customer?: Customer
}

export class CustomerUserVM implements ICustomerUserVM {
  idaSuserId: string
  customeruser?: CustomerUser

  constructor(data?: ICustomerUserVM) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.idaSuserId = data['idaSuserId']
      this.customeruser = data['customeruser']
        ? CustomerUser.fromJS(data['customeruser'])
        : <any>undefined
    }
  }

  static fromJS(data: any): CustomerUserVM {
    data = typeof data === 'object' ? data : {}
    let result = new CustomerUserVM()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['idaSuserId'] = this.idaSuserId
    data['customeruser'] = this.customeruser
      ? this.customeruser.toJSON()
      : <any>undefined
    return data
  }
}

export interface ICustomerUserVM {
  idaSuserId: string
  customeruser?: CustomerUser
}

export class CrudUserResponse implements ICrudUserResponse {
  message?: string
  isSuccess: boolean

  constructor(data?: ICrudUserResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.message = data['message']
      this.isSuccess = data['isSuccess']
    }
  }

  static fromJS(data: any): CrudUserResponse {
    data = typeof data === 'object' ? data : {}
    let result = new CrudUserResponse()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['message'] = this.message
    data['isSuccess'] = this.isSuccess
    return data
  }
}

export interface ICrudUserResponse {
  message?: string
  isSuccess: boolean
}

export class CustomerCrudResponse implements ICustomerCrudResponse {
  message?: string
  isSuccess: boolean

  constructor(data?: ICustomerCrudResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.message = data['message']
      this.isSuccess = data['isSuccess']
    }
  }

  static fromJS(data: any): CustomerCrudResponse {
    data = typeof data === 'object' ? data : {}
    let result = new CustomerCrudResponse()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['message'] = this.message
    data['isSuccess'] = this.isSuccess
    return data
  }
}

export interface ICustomerCrudResponse {
  message?: string
  isSuccess: boolean
}

export class CustomerCount implements ICustomerCount {
  total: number
  monthTotal: number
  activeTotalCount: number
  pendingTotalCount: number
  inActiveTotalCount: number
  activeMonthtTotal: number
  inactiveMonthTotal: number
  pendingMonthTotal: number

  constructor(data?: ICustomerCount) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.total = data['total']
      this.monthTotal = data['monthTotal']
      this.activeTotalCount = data['activeTotalCount']
      this.pendingTotalCount = data['pendingTotalCount']
      this.inActiveTotalCount = data['inActiveTotalCount']
      this.activeMonthtTotal = data['activeMonthtTotal']
      this.inactiveMonthTotal = data['inactiveMonthTotal']
      this.pendingMonthTotal = data['pendingMonthTotal']
    }
  }

  static fromJS(data: any): CustomerCount {
    data = typeof data === 'object' ? data : {}
    let result = new CustomerCount()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['total'] = this.total
    data['monthTotal'] = this.monthTotal
    data['activeTotalCount'] = this.activeTotalCount
    data['pendingTotalCount'] = this.pendingTotalCount
    data['inActiveTotalCount'] = this.inActiveTotalCount
    data['activeMonthtTotal'] = this.activeMonthtTotal
    data['inactiveMonthTotal'] = this.inactiveMonthTotal
    data['pendingMonthTotal'] = this.pendingMonthTotal
    return data
  }
}

export interface ICustomerCount {
  total: number
  monthTotal: number
  activeTotalCount: number
  pendingTotalCount: number
  inActiveTotalCount: number
  activeMonthtTotal: number
  inactiveMonthTotal: number
  pendingMonthTotal: number
}

export class CustomerUserCount implements ICustomerUserCount {
  total: number
  monthTotal: number
  activeTotalCount: number
  pendingTotalCount: number
  inActiveTotalCount: number
  activeMonthtTotal: number
  inactiveMonthTotal: number
  pendingMonthTotal: number

  constructor(data?: ICustomerUserCount) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.total = data['total']
      this.monthTotal = data['monthTotal']
      this.activeTotalCount = data['activeTotalCount']
      this.pendingTotalCount = data['pendingTotalCount']
      this.inActiveTotalCount = data['inActiveTotalCount']
      this.activeMonthtTotal = data['activeMonthtTotal']
      this.inactiveMonthTotal = data['inactiveMonthTotal']
      this.pendingMonthTotal = data['pendingMonthTotal']
    }
  }

  static fromJS(data: any): CustomerUserCount {
    data = typeof data === 'object' ? data : {}
    let result = new CustomerUserCount()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['total'] = this.total
    data['monthTotal'] = this.monthTotal
    data['activeTotalCount'] = this.activeTotalCount
    data['pendingTotalCount'] = this.pendingTotalCount
    data['inActiveTotalCount'] = this.inActiveTotalCount
    data['activeMonthtTotal'] = this.activeMonthtTotal
    data['inactiveMonthTotal'] = this.inactiveMonthTotal
    data['pendingMonthTotal'] = this.pendingMonthTotal
    return data
  }
}

export interface ICustomerUserCount {
  total: number
  monthTotal: number
  activeTotalCount: number
  pendingTotalCount: number
  inActiveTotalCount: number
  activeMonthtTotal: number
  inactiveMonthTotal: number
  pendingMonthTotal: number
}

export class DonotCallRegCount implements IDonotCallRegCount {
  total: number
  monthTotal: number

  constructor(data?: IDonotCallRegCount) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.total = data['total']
      this.monthTotal = data['monthTotal']
    }
  }

  static fromJS(data: any): DonotCallRegCount {
    data = typeof data === 'object' ? data : {}
    let result = new DonotCallRegCount()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['total'] = this.total
    data['monthTotal'] = this.monthTotal
    return data
  }
}

export interface IDonotCallRegCount {
  total: number
  monthTotal: number
}

export class CustomerLog implements ICustomerLog {
  customerUserId: string
  firstName?: string
  lastName?: string
  surname?: string
  creditsUsage: number
  customerId?: string
  customerName?: string

  constructor(data?: ICustomerLog) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.customerUserId = data['customerUserId']
      this.firstName = data['firstName']
      this.lastName = data['lastName']
      this.surname = data['surname']
      this.creditsUsage = data['creditsUsage']
      this.customerId = data['customerId']
      this.customerName = data['customerName']
    }
  }

  static fromJS(data: any): CustomerLog {
    data = typeof data === 'object' ? data : {}
    let result = new CustomerLog()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['customerUserId'] = this.customerUserId
    data['firstName'] = this.firstName
    data['lastName'] = this.lastName
    data['surname'] = this.surname
    data['creditsUsage'] = this.creditsUsage
    data['customerId'] = this.customerId
    data['customerName'] = this.customerName
    return data
  }
}

export interface ICustomerLog {
  customerUserId: string
  firstName?: string
  lastName?: string
  surname?: string
  creditsUsage: number
  customerId?: string
  customerName?: string
}

export class ContactUsCount implements IContactUsCount {
  total: number
  monthTotal: number
  notActionedTotal: number
  notActionedMonth: number
  actionedTotal: number
  actionedMonth: number

  constructor(data?: IContactUsCount) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.total = data['total']
      this.monthTotal = data['monthTotal']
      this.notActionedTotal = data['notActionedTotal']
      this.notActionedMonth = data['notActionedMonth']
      this.actionedTotal = data['actionedTotal']
      this.actionedMonth = data['actionedMonth']
    }
  }

  static fromJS(data: any): ContactUsCount {
    data = typeof data === 'object' ? data : {}
    let result = new ContactUsCount()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['total'] = this.total
    data['monthTotal'] = this.monthTotal
    data['notActionedTotal'] = this.notActionedTotal
    data['notActionedMonth'] = this.notActionedMonth
    data['actionedTotal'] = this.actionedTotal
    data['actionedMonth'] = this.actionedMonth
    return data
  }
}

export interface IContactUsCount {
  total: number
  monthTotal: number
  notActionedTotal: number
  notActionedMonth: number
  actionedTotal: number
  actionedMonth: number
}

export class PaymentCount implements IPaymentCount {
  notPaidTotal: number
  notPaidMonth: number
  paidTotal: number
  paidMonth: number
  shortPaidTotal: number
  shortPaidMonth: number
  notPaidPrevmonth: number
  paidprevmonth: number
  shortPaidprevmonth: number

  constructor(data?: IPaymentCount) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.notPaidTotal = data['notPaidTotal']
      this.notPaidMonth = data['notPaidMonth']
      this.paidTotal = data['paidTotal']
      this.paidMonth = data['paidMonth']
      this.shortPaidTotal = data['shortPaidTotal']
      this.shortPaidMonth = data['shortPaidMonth']
      this.notPaidPrevmonth = data['notPaidPrevmonth']
      this.paidprevmonth = data['paidprevmonth']
      this.shortPaidprevmonth = data['shortPaidprevmonth']
    }
  }

  static fromJS(data: any): PaymentCount {
    data = typeof data === 'object' ? data : {}
    let result = new PaymentCount()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['notPaidTotal'] = this.notPaidTotal
    data['notPaidMonth'] = this.notPaidMonth
    data['paidTotal'] = this.paidTotal
    data['paidMonth'] = this.paidMonth
    data['shortPaidTotal'] = this.shortPaidTotal
    data['shortPaidMonth'] = this.shortPaidMonth
    data['notPaidPrevmonth'] = this.notPaidPrevmonth
    data['paidprevmonth'] = this.paidprevmonth
    data['shortPaidprevmonth'] = this.shortPaidprevmonth
    return data
  }
}

export interface IPaymentCount {
  notPaidTotal: number
  notPaidMonth: number
  paidTotal: number
  paidMonth: number
  shortPaidTotal: number
  shortPaidMonth: number
  notPaidPrevmonth: number
  paidprevmonth: number
  shortPaidprevmonth: number
}

export class InvoiceCount implements IInvoiceCount {
  total: number
  monthTotal: number
  sentCustTotal: number
  sentCustMonth: number
  notSentTotal: number
  notSentMonth: number
  cancelTotal: number
  cancelMonth: number
  cancelPrevMonth: number
  taxinvTotal: number
  taxinvMonth: number

  constructor(data?: IInvoiceCount) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.total = data['total']
      this.monthTotal = data['monthTotal']
      this.sentCustTotal = data['sentCustTotal']
      this.sentCustMonth = data['sentCustMonth']
      this.notSentTotal = data['notSentTotal']
      this.notSentMonth = data['notSentMonth']
      this.cancelTotal = data['cancelTotal']
      this.cancelMonth = data['cancelMonth']
      this.cancelPrevMonth = data['cancelPrevMonth']
      this.taxinvTotal = data['taxinvTotal']
      this.taxinvMonth = data['taxinvMonth']
    }
  }

  static fromJS(data: any): InvoiceCount {
    data = typeof data === 'object' ? data : {}
    let result = new InvoiceCount()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['total'] = this.total
    data['monthTotal'] = this.monthTotal
    data['sentCustTotal'] = this.sentCustTotal
    data['sentCustMonth'] = this.sentCustMonth
    data['notSentTotal'] = this.notSentTotal
    data['notSentMonth'] = this.notSentMonth
    data['cancelTotal'] = this.cancelTotal
    data['cancelMonth'] = this.cancelMonth
    data['cancelPrevMonth'] = this.cancelPrevMonth
    data['taxinvTotal'] = this.taxinvTotal
    data['taxinvMonth'] = this.taxinvMonth
    return data
  }
}

export interface IInvoiceCount {
  total: number
  monthTotal: number
  sentCustTotal: number
  sentCustMonth: number
  notSentTotal: number
  notSentMonth: number
  cancelTotal: number
  cancelMonth: number
  cancelPrevMonth: number
  taxinvTotal: number
  taxinvMonth: number
}

export class SubscriptionCount implements ISubscriptionCount {
  monthTotal: number
  total: number

  constructor(data?: ISubscriptionCount) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.monthTotal = data['monthTotal']
      this.total = data['total']
    }
  }

  static fromJS(data: any): SubscriptionCount {
    data = typeof data === 'object' ? data : {}
    let result = new SubscriptionCount()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['monthTotal'] = this.monthTotal
    data['total'] = this.total
    return data
  }
}

export interface ISubscriptionCount {
  monthTotal: number
  total: number
}

export class DataServicesAgreement implements IDataServicesAgreement {
  id: string
  effectiveDate: Date
  version: number
  filePath?: string
  isPublished: boolean
  description?: string

  constructor(data?: IDataServicesAgreement) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.id = data['id']
      this.effectiveDate = data['effectiveDate']
        ? new Date(data['effectiveDate'].toString())
        : <any>undefined
      this.version = data['version']
      this.filePath = data['filePath']
      this.isPublished = data['isPublished']
      this.description = data['description']
    }
  }

  static fromJS(data: any): DataServicesAgreement {
    data = typeof data === 'object' ? data : {}
    let result = new DataServicesAgreement()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['id'] = this.id
    data['effectiveDate'] = this.effectiveDate
      ? this.effectiveDate.toISOString()
      : <any>undefined
    data['version'] = this.version
    data['filePath'] = this.filePath
    data['isPublished'] = this.isPublished
    data['description'] = this.description
    return data
  }
}

export interface IDataServicesAgreement {
  id: string
  effectiveDate: Date
  version: number
  filePath?: string
  isPublished: boolean
  description?: string
}

export class CrudDsaResponse implements ICrudDsaResponse {
  message?: string
  isSuccess: boolean

  constructor(data?: ICrudDsaResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.message = data['message']
      this.isSuccess = data['isSuccess']
    }
  }

  static fromJS(data: any): CrudDsaResponse {
    data = typeof data === 'object' ? data : {}
    let result = new CrudDsaResponse()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['message'] = this.message
    data['isSuccess'] = this.isSuccess
    return data
  }
}

export interface ICrudDsaResponse {
  message?: string
  isSuccess: boolean
}

export class DataTableResponseOfDsaList implements IDataTableResponseOfDsaList {
  draw: number
  recordsFiltered: number
  recordsTotal: number
  data?: DsaList[]

  constructor(data?: IDataTableResponseOfDsaList) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.draw = data['draw']
      this.recordsFiltered = data['recordsFiltered']
      this.recordsTotal = data['recordsTotal']
      if (data['data'] && data['data'].constructor === Array) {
        this.data = []
        for (let item of data['data']) this.data.push(DsaList.fromJS(item))
      }
    }
  }

  static fromJS(data: any): DataTableResponseOfDsaList {
    data = typeof data === 'object' ? data : {}
    let result = new DataTableResponseOfDsaList()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['draw'] = this.draw
    data['recordsFiltered'] = this.recordsFiltered
    data['recordsTotal'] = this.recordsTotal
    if (this.data && this.data.constructor === Array) {
      data['data'] = []
      for (let item of this.data) data['data'].push(item.toJSON())
    }
    return data
  }
}

export interface IDataTableResponseOfDsaList {
  draw: number
  recordsFiltered: number
  recordsTotal: number
  data?: DsaList[]
}

export class DsaResponse extends DataTableResponseOfDsaList
  implements IDsaResponse {
  constructor(data?: IDsaResponse) {
    super(data)
  }

  init(data?: any) {
    super.init(data)
    if (data) {
    }
  }

  static fromJS(data: any): DsaResponse {
    data = typeof data === 'object' ? data : {}
    let result = new DsaResponse()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    super.toJSON(data)
    return data
  }
}

export interface IDsaResponse extends IDataTableResponseOfDsaList {}

export class DsaList implements IDsaList {
  id: string
  effectiveDate: Date
  version: number
  termsAndCondition?: string
  filepath?: string
  fileName?: string
  isPublished: boolean

  constructor(data?: IDsaList) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.id = data['id']
      this.effectiveDate = data['effectiveDate']
        ? new Date(data['effectiveDate'].toString())
        : <any>undefined
      this.version = data['version']
      this.termsAndCondition = data['termsAndCondition']
      this.filepath = data['filepath']
      this.fileName = data['fileName']
      this.isPublished = data['isPublished']
    }
  }

  static fromJS(data: any): DsaList {
    data = typeof data === 'object' ? data : {}
    let result = new DsaList()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['id'] = this.id
    data['effectiveDate'] = this.effectiveDate
      ? this.effectiveDate.toISOString()
      : <any>undefined
    data['version'] = this.version
    data['termsAndCondition'] = this.termsAndCondition
    data['filepath'] = this.filepath
    data['fileName'] = this.fileName
    data['isPublished'] = this.isPublished
    return data
  }
}

export interface IDsaList {
  id: string
  effectiveDate: Date
  version: number
  termsAndCondition?: string
  filepath?: string
  fileName?: string
  isPublished: boolean
}

export class LeadDataTableRequest implements ILeadDataTableRequest {
  fromdate?: string
  todate?: string
  customerId: string
  dtRequest?: DataTableRequest
  isFileExists: boolean

  constructor(data?: ILeadDataTableRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.fromdate = data['fromdate']
      this.todate = data['todate']
      this.customerId = data['customerId']
      this.dtRequest = data['dtRequest']
        ? DataTableRequest.fromJS(data['dtRequest'])
        : <any>undefined
      this.isFileExists = data['isFileExists']
    }
  }

  static fromJS(data: any): LeadDataTableRequest {
    data = typeof data === 'object' ? data : {}
    let result = new LeadDataTableRequest()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['fromdate'] = this.fromdate
    data['todate'] = this.todate
    data['customerId'] = this.customerId
    data['dtRequest'] = this.dtRequest
      ? this.dtRequest.toJSON()
      : <any>undefined
    data['isFileExists'] = this.isFileExists
    return data
  }
}

export interface ILeadDataTableRequest {
  fromdate?: string
  todate?: string
  customerId: string
  dtRequest?: DataTableRequest
  isFileExists: boolean
}

export class DataTableResponseOfLeadGenerationVM
  implements IDataTableResponseOfLeadGenerationVM {
  draw: number
  recordsFiltered: number
  recordsTotal: number
  data?: LeadGenerationVM[]

  constructor(data?: IDataTableResponseOfLeadGenerationVM) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.draw = data['draw']
      this.recordsFiltered = data['recordsFiltered']
      this.recordsTotal = data['recordsTotal']
      if (data['data'] && data['data'].constructor === Array) {
        this.data = []
        for (let item of data['data'])
          this.data.push(LeadGenerationVM.fromJS(item))
      }
    }
  }

  static fromJS(data: any): DataTableResponseOfLeadGenerationVM {
    data = typeof data === 'object' ? data : {}
    let result = new DataTableResponseOfLeadGenerationVM()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['draw'] = this.draw
    data['recordsFiltered'] = this.recordsFiltered
    data['recordsTotal'] = this.recordsTotal
    if (this.data && this.data.constructor === Array) {
      data['data'] = []
      for (let item of this.data) data['data'].push(item.toJSON())
    }
    return data
  }
}

export interface IDataTableResponseOfLeadGenerationVM {
  draw: number
  recordsFiltered: number
  recordsTotal: number
  data?: LeadGenerationVM[]
}

export class LeadDataTableResponse extends DataTableResponseOfLeadGenerationVM
  implements ILeadDataTableResponse {
  constructor(data?: ILeadDataTableResponse) {
    super(data)
  }

  init(data?: any) {
    super.init(data)
    if (data) {
    }
  }

  static fromJS(data: any): LeadDataTableResponse {
    data = typeof data === 'object' ? data : {}
    let result = new LeadDataTableResponse()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    super.toJSON(data)
    return data
  }
}

export interface ILeadDataTableResponse
  extends IDataTableResponseOfLeadGenerationVM {}

export class LeadGenerationVM implements ILeadGenerationVM {
  id: string
  customerUser?: CustomerUser
  customerUserID: string
  fileName?: string
  leadNumber?: string
  uploadDate?: string
  totalRecords: number
  foundRecords: number
  customerName?: string
  isDataDownloaded: boolean
  proFormaInvoiceId?: string
  proFormaInvoiceNumber?: string
  adminCertified: boolean
  customerId?: string
  isFileExists: boolean

  constructor(data?: ILeadGenerationVM) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.id = data['id']
      this.customerUser = data['customerUser']
        ? CustomerUser.fromJS(data['customerUser'])
        : <any>undefined
      this.customerUserID = data['customerUserID']
      this.fileName = data['fileName']
      this.leadNumber = data['leadNumber']
      this.uploadDate = data['uploadDate']
      this.totalRecords = data['totalRecords']
      this.foundRecords = data['foundRecords']
      this.customerName = data['customerName']
      this.isDataDownloaded = data['isDataDownloaded']
      this.proFormaInvoiceId = data['proFormaInvoiceId']
      this.proFormaInvoiceNumber = data['proFormaInvoiceNumber']
      this.adminCertified = data['adminCertified']
      this.customerId = data['customerId']
      this.isFileExists = data['isFileExists']
    }
  }

  static fromJS(data: any): LeadGenerationVM {
    data = typeof data === 'object' ? data : {}
    let result = new LeadGenerationVM()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['id'] = this.id
    data['customerUser'] = this.customerUser
      ? this.customerUser.toJSON()
      : <any>undefined
    data['customerUserID'] = this.customerUserID
    data['fileName'] = this.fileName
    data['leadNumber'] = this.leadNumber
    data['uploadDate'] = this.uploadDate
    data['totalRecords'] = this.totalRecords
    data['foundRecords'] = this.foundRecords
    data['customerName'] = this.customerName
    data['isDataDownloaded'] = this.isDataDownloaded
    data['proFormaInvoiceId'] = this.proFormaInvoiceId
    data['proFormaInvoiceNumber'] = this.proFormaInvoiceNumber
    data['adminCertified'] = this.adminCertified
    data['customerId'] = this.customerId
    data['isFileExists'] = this.isFileExists
    return data
  }
}

export interface ILeadGenerationVM {
  id: string
  customerUser?: CustomerUser
  customerUserID: string
  fileName?: string
  leadNumber?: string
  uploadDate?: string
  totalRecords: number
  foundRecords: number
  customerName?: string
  isDataDownloaded: boolean
  proFormaInvoiceId?: string
  proFormaInvoiceNumber?: string
  adminCertified: boolean
  customerId?: string
  isFileExists: boolean
}

export class LeadResponse implements ILeadResponse {
  message?: string
  isSuccess: boolean

  constructor(data?: ILeadResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.message = data['message']
      this.isSuccess = data['isSuccess']
    }
  }

  static fromJS(data: any): LeadResponse {
    data = typeof data === 'object' ? data : {}
    let result = new LeadResponse()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['message'] = this.message
    data['isSuccess'] = this.isSuccess
    return data
  }
}

export interface ILeadResponse {
  message?: string
  isSuccess: boolean
}

export class DataTableResponseOfNewsData
  implements IDataTableResponseOfNewsData {
  draw: number
  recordsFiltered: number
  recordsTotal: number
  data?: NewsData[]

  constructor(data?: IDataTableResponseOfNewsData) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.draw = data['draw']
      this.recordsFiltered = data['recordsFiltered']
      this.recordsTotal = data['recordsTotal']
      if (data['data'] && data['data'].constructor === Array) {
        this.data = []
        for (let item of data['data']) this.data.push(NewsData.fromJS(item))
      }
    }
  }

  static fromJS(data: any): DataTableResponseOfNewsData {
    data = typeof data === 'object' ? data : {}
    let result = new DataTableResponseOfNewsData()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['draw'] = this.draw
    data['recordsFiltered'] = this.recordsFiltered
    data['recordsTotal'] = this.recordsTotal
    if (this.data && this.data.constructor === Array) {
      data['data'] = []
      for (let item of this.data) data['data'].push(item.toJSON())
    }
    return data
  }
}

export interface IDataTableResponseOfNewsData {
  draw: number
  recordsFiltered: number
  recordsTotal: number
  data?: NewsData[]
}

export class NewsDataTableResponse extends DataTableResponseOfNewsData
  implements INewsDataTableResponse {
  constructor(data?: INewsDataTableResponse) {
    super(data)
  }

  init(data?: any) {
    super.init(data)
    if (data) {
    }
  }

  static fromJS(data: any): NewsDataTableResponse {
    data = typeof data === 'object' ? data : {}
    let result = new NewsDataTableResponse()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    super.toJSON(data)
    return data
  }
}

export interface INewsDataTableResponse extends IDataTableResponseOfNewsData {}

export class NewsData implements INewsData {
  id: string
  content?: string
  createdDate: Date
  name?: string

  constructor(data?: INewsData) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.id = data['id']
      this.content = data['content']
      this.createdDate = data['createdDate']
        ? new Date(data['createdDate'].toString())
        : <any>undefined
      this.name = data['name']
    }
  }

  static fromJS(data: any): NewsData {
    data = typeof data === 'object' ? data : {}
    let result = new NewsData()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['id'] = this.id
    data['content'] = this.content
    data['createdDate'] = this.createdDate
      ? this.createdDate.toISOString()
      : <any>undefined
    data['name'] = this.name
    return data
  }
}

export interface INewsData {
  id: string
  content?: string
  createdDate: Date
  name?: string
}

export class News implements INews {
  id: string
  content?: string
  createdDate: Date
  blogName?: string

  constructor(data?: INews) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.id = data['id']
      this.content = data['content']
      this.createdDate = data['createdDate']
        ? new Date(data['createdDate'].toString())
        : <any>undefined
      this.blogName = data['blogName']
    }
  }

  static fromJS(data: any): News {
    data = typeof data === 'object' ? data : {}
    let result = new News()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['id'] = this.id
    data['content'] = this.content
    data['createdDate'] = this.createdDate
      ? this.createdDate.toISOString()
      : <any>undefined
    data['blogName'] = this.blogName
    return data
  }
}

export interface INews {
  id: string
  content?: string
  createdDate: Date
  blogName?: string
}

export class NewsCrudResponse implements INewsCrudResponse {
  message?: string
  isSuccess: boolean

  constructor(data?: INewsCrudResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.message = data['message']
      this.isSuccess = data['isSuccess']
    }
  }

  static fromJS(data: any): NewsCrudResponse {
    data = typeof data === 'object' ? data : {}
    let result = new NewsCrudResponse()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['message'] = this.message
    data['isSuccess'] = this.isSuccess
    return data
  }
}

export interface INewsCrudResponse {
  message?: string
  isSuccess: boolean
}

export class DataTableResponseOfServiceData
  implements IDataTableResponseOfServiceData {
  draw: number
  recordsFiltered: number
  recordsTotal: number
  data?: ServiceData[]

  constructor(data?: IDataTableResponseOfServiceData) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.draw = data['draw']
      this.recordsFiltered = data['recordsFiltered']
      this.recordsTotal = data['recordsTotal']
      if (data['data'] && data['data'].constructor === Array) {
        this.data = []
        for (let item of data['data']) this.data.push(ServiceData.fromJS(item))
      }
    }
  }

  static fromJS(data: any): DataTableResponseOfServiceData {
    data = typeof data === 'object' ? data : {}
    let result = new DataTableResponseOfServiceData()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['draw'] = this.draw
    data['recordsFiltered'] = this.recordsFiltered
    data['recordsTotal'] = this.recordsTotal
    if (this.data && this.data.constructor === Array) {
      data['data'] = []
      for (let item of this.data) data['data'].push(item.toJSON())
    }
    return data
  }
}

export interface IDataTableResponseOfServiceData {
  draw: number
  recordsFiltered: number
  recordsTotal: number
  data?: ServiceData[]
}

export class ServiceDataResponse extends DataTableResponseOfServiceData
  implements IServiceDataResponse {
  constructor(data?: IServiceDataResponse) {
    super(data)
  }

  init(data?: any) {
    super.init(data)
    if (data) {
    }
  }

  static fromJS(data: any): ServiceDataResponse {
    data = typeof data === 'object' ? data : {}
    let result = new ServiceDataResponse()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    super.toJSON(data)
    return data
  }
}

export interface IServiceDataResponse extends IDataTableResponseOfServiceData {}

export class ServiceData implements IServiceData {
  id: string
  name?: string
  code?: string
  isActive: boolean

  constructor(data?: IServiceData) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.id = data['id']
      this.name = data['name']
      this.code = data['code']
      this.isActive = data['isActive']
    }
  }

  static fromJS(data: any): ServiceData {
    data = typeof data === 'object' ? data : {}
    let result = new ServiceData()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['id'] = this.id
    data['name'] = this.name
    data['code'] = this.code
    data['isActive'] = this.isActive
    return data
  }
}

export interface IServiceData {
  id: string
  name?: string
  code?: string
  isActive: boolean
}

export class ServiceCrudResponse implements IServiceCrudResponse {
  message?: string
  isSuccess: boolean

  constructor(data?: IServiceCrudResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.message = data['message']
      this.isSuccess = data['isSuccess']
    }
  }

  static fromJS(data: any): ServiceCrudResponse {
    data = typeof data === 'object' ? data : {}
    let result = new ServiceCrudResponse()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['message'] = this.message
    data['isSuccess'] = this.isSuccess
    return data
  }
}

export interface IServiceCrudResponse {
  message?: string
  isSuccess: boolean
}

export class DataTableResponseOfProductDetails
  implements IDataTableResponseOfProductDetails {
  draw: number
  recordsFiltered: number
  recordsTotal: number
  data?: ProductDetails[]

  constructor(data?: IDataTableResponseOfProductDetails) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.draw = data['draw']
      this.recordsFiltered = data['recordsFiltered']
      this.recordsTotal = data['recordsTotal']
      if (data['data'] && data['data'].constructor === Array) {
        this.data = []
        for (let item of data['data'])
          this.data.push(ProductDetails.fromJS(item))
      }
    }
  }

  static fromJS(data: any): DataTableResponseOfProductDetails {
    data = typeof data === 'object' ? data : {}
    let result = new DataTableResponseOfProductDetails()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['draw'] = this.draw
    data['recordsFiltered'] = this.recordsFiltered
    data['recordsTotal'] = this.recordsTotal
    if (this.data && this.data.constructor === Array) {
      data['data'] = []
      for (let item of this.data) data['data'].push(item.toJSON())
    }
    return data
  }
}

export interface IDataTableResponseOfProductDetails {
  draw: number
  recordsFiltered: number
  recordsTotal: number
  data?: ProductDetails[]
}

export class ProductResponse extends DataTableResponseOfProductDetails
  implements IProductResponse {
  constructor(data?: IProductResponse) {
    super(data)
  }

  init(data?: any) {
    super.init(data)
    if (data) {
    }
  }

  static fromJS(data: any): ProductResponse {
    data = typeof data === 'object' ? data : {}
    let result = new ProductResponse()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    super.toJSON(data)
    return data
  }
}

export interface IProductResponse extends IDataTableResponseOfProductDetails {}

export class ProductDetails implements IProductDetails {
  id: string
  name?: string
  activatedDate: Date
  productPackageRates?: ProductPackageRate[]
  services?: Service[]
  service?: Service
  serviceId: string
  usageType?: string
  isActive: boolean
  productlist?: Product[]

  constructor(data?: IProductDetails) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.id = data['id']
      this.name = data['name']
      this.activatedDate = data['activatedDate']
        ? new Date(data['activatedDate'].toString())
        : <any>undefined
      if (
        data['productPackageRates'] &&
        data['productPackageRates'].constructor === Array
      ) {
        this.productPackageRates = []
        for (let item of data['productPackageRates'])
          this.productPackageRates.push(ProductPackageRate.fromJS(item))
      }
      if (data['services'] && data['services'].constructor === Array) {
        this.services = []
        for (let item of data['services'])
          this.services.push(Service.fromJS(item))
      }
      this.service = data['service']
        ? Service.fromJS(data['service'])
        : <any>undefined
      this.serviceId = data['serviceId']
      this.usageType = data['usageType']
      this.isActive = data['isActive']
      if (data['productlist'] && data['productlist'].constructor === Array) {
        this.productlist = []
        for (let item of data['productlist'])
          this.productlist.push(Product.fromJS(item))
      }
    }
  }

  static fromJS(data: any): ProductDetails {
    data = typeof data === 'object' ? data : {}
    let result = new ProductDetails()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['id'] = this.id
    data['name'] = this.name
    data['activatedDate'] = this.activatedDate
      ? this.activatedDate.toISOString()
      : <any>undefined
    if (
      this.productPackageRates &&
      this.productPackageRates.constructor === Array
    ) {
      data['productPackageRates'] = []
      for (let item of this.productPackageRates)
        data['productPackageRates'].push(item.toJSON())
    }
    if (this.services && this.services.constructor === Array) {
      data['services'] = []
      for (let item of this.services) data['services'].push(item.toJSON())
    }
    data['service'] = this.service ? this.service.toJSON() : <any>undefined
    data['serviceId'] = this.serviceId
    data['usageType'] = this.usageType
    data['isActive'] = this.isActive
    if (this.productlist && this.productlist.constructor === Array) {
      data['productlist'] = []
      for (let item of this.productlist) data['productlist'].push(item.toJSON())
    }
    return data
  }
}

export interface IProductDetails {
  id: string
  name?: string
  activatedDate: Date
  productPackageRates?: ProductPackageRate[]
  services?: Service[]
  service?: Service
  serviceId: string
  usageType?: string
  isActive: boolean
  productlist?: Product[]
}

export class ProductCrudResponse implements IProductCrudResponse {
  message?: string
  isSuccess: boolean

  constructor(data?: IProductCrudResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.message = data['message']
      this.isSuccess = data['isSuccess']
    }
  }

  static fromJS(data: any): ProductCrudResponse {
    data = typeof data === 'object' ? data : {}
    let result = new ProductCrudResponse()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['message'] = this.message
    data['isSuccess'] = this.isSuccess
    return data
  }
}

export interface IProductCrudResponse {
  message?: string
  isSuccess: boolean
}

export class SubscriptionResponse implements ISubscriptionResponse {
  message?: string
  isSuccess: boolean

  constructor(data?: ISubscriptionResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.message = data['message']
      this.isSuccess = data['isSuccess']
    }
  }

  static fromJS(data: any): SubscriptionResponse {
    data = typeof data === 'object' ? data : {}
    let result = new SubscriptionResponse()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['message'] = this.message
    data['isSuccess'] = this.isSuccess
    return data
  }
}

export interface ISubscriptionResponse {
  message?: string
  isSuccess: boolean
}

export class SubscriptionDataTableRequest
  implements ISubscriptionDataTableRequest {
  fromdate?: string
  todate?: string
  customerId: string
  dtRequest?: DataTableRequest

  constructor(data?: ISubscriptionDataTableRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.fromdate = data['fromdate']
      this.todate = data['todate']
      this.customerId = data['customerId']
      this.dtRequest = data['dtRequest']
        ? DataTableRequest.fromJS(data['dtRequest'])
        : <any>undefined
    }
  }

  static fromJS(data: any): SubscriptionDataTableRequest {
    data = typeof data === 'object' ? data : {}
    let result = new SubscriptionDataTableRequest()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['fromdate'] = this.fromdate
    data['todate'] = this.todate
    data['customerId'] = this.customerId
    data['dtRequest'] = this.dtRequest
      ? this.dtRequest.toJSON()
      : <any>undefined
    return data
  }
}

export interface ISubscriptionDataTableRequest {
  fromdate?: string
  todate?: string
  customerId: string
  dtRequest?: DataTableRequest
}

export class DataTableResponseOfSubscriptionVm
  implements IDataTableResponseOfSubscriptionVm {
  draw: number
  recordsFiltered: number
  recordsTotal: number
  data?: SubscriptionVm[]

  constructor(data?: IDataTableResponseOfSubscriptionVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.draw = data['draw']
      this.recordsFiltered = data['recordsFiltered']
      this.recordsTotal = data['recordsTotal']
      if (data['data'] && data['data'].constructor === Array) {
        this.data = []
        for (let item of data['data'])
          this.data.push(SubscriptionVm.fromJS(item))
      }
    }
  }

  static fromJS(data: any): DataTableResponseOfSubscriptionVm {
    data = typeof data === 'object' ? data : {}
    let result = new DataTableResponseOfSubscriptionVm()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['draw'] = this.draw
    data['recordsFiltered'] = this.recordsFiltered
    data['recordsTotal'] = this.recordsTotal
    if (this.data && this.data.constructor === Array) {
      data['data'] = []
      for (let item of this.data) data['data'].push(item.toJSON())
    }
    return data
  }
}

export interface IDataTableResponseOfSubscriptionVm {
  draw: number
  recordsFiltered: number
  recordsTotal: number
  data?: SubscriptionVm[]
}

export class SubscriptionDataTableRespone
  extends DataTableResponseOfSubscriptionVm
  implements ISubscriptionDataTableRespone {
  constructor(data?: ISubscriptionDataTableRespone) {
    super(data)
  }

  init(data?: any) {
    super.init(data)
    if (data) {
    }
  }

  static fromJS(data: any): SubscriptionDataTableRespone {
    data = typeof data === 'object' ? data : {}
    let result = new SubscriptionDataTableRespone()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    super.toJSON(data)
    return data
  }
}

export interface ISubscriptionDataTableRespone
  extends IDataTableResponseOfSubscriptionVm {}

export class SubscriptionVm implements ISubscriptionVm {
  subscriptionId: string
  subscriptionDate: Date
  customerName?: string
  number: number
  startDate: Date
  endDate: Date
  quantity: number
  usageType?: string
  numberofAssign: number
  productId: string
  productName?: string
  billingType?: string
  duration: number
  customerId: string
  subDisplayNumber?: string

  constructor(data?: ISubscriptionVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.subscriptionId = data['subscriptionId']
      this.subscriptionDate = data['subscriptionDate']
        ? new Date(data['subscriptionDate'].toString())
        : <any>undefined
      this.customerName = data['customerName']
      this.number = data['number']
      this.startDate = data['startDate']
        ? new Date(data['startDate'].toString())
        : <any>undefined
      this.endDate = data['endDate']
        ? new Date(data['endDate'].toString())
        : <any>undefined
      this.quantity = data['quantity']
      this.usageType = data['usageType']
      this.numberofAssign = data['numberofAssign']
      this.productId = data['productId']
      this.productName = data['productName']
      this.billingType = data['billingType']
      this.duration = data['duration']
      this.customerId = data['customerId']
      this.subDisplayNumber = data['subDisplayNumber']
    }
  }

  static fromJS(data: any): SubscriptionVm {
    data = typeof data === 'object' ? data : {}
    let result = new SubscriptionVm()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['subscriptionId'] = this.subscriptionId
    data['subscriptionDate'] = this.subscriptionDate
      ? this.subscriptionDate.toISOString()
      : <any>undefined
    data['customerName'] = this.customerName
    data['number'] = this.number
    data['startDate'] = this.startDate
      ? this.startDate.toISOString()
      : <any>undefined
    data['endDate'] = this.endDate ? this.endDate.toISOString() : <any>undefined
    data['quantity'] = this.quantity
    data['usageType'] = this.usageType
    data['numberofAssign'] = this.numberofAssign
    data['productId'] = this.productId
    data['productName'] = this.productName
    data['billingType'] = this.billingType
    data['duration'] = this.duration
    data['customerId'] = this.customerId
    data['subDisplayNumber'] = this.subDisplayNumber
    return data
  }
}

export interface ISubscriptionVm {
  subscriptionId: string
  subscriptionDate: Date
  customerName?: string
  number: number
  startDate: Date
  endDate: Date
  quantity: number
  usageType?: string
  numberofAssign: number
  productId: string
  productName?: string
  billingType?: string
  duration: number
  customerId: string
  subDisplayNumber?: string
}

export class ProductsVm implements IProductsVm {
  id: string
  name?: string
  customerId: string
  isSelect: boolean
  rates?: ProductPackageRate[]
  customers?: Customer[]
  billingType?: string
  duration: number
  quantity: number
  startDate?: string
  startMonth?: string
  startYear?: string

  constructor(data?: IProductsVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.id = data['id']
      this.name = data['name']
      this.customerId = data['customerId']
      this.isSelect = data['isSelect']
      if (data['rates'] && data['rates'].constructor === Array) {
        this.rates = []
        for (let item of data['rates'])
          this.rates.push(ProductPackageRate.fromJS(item))
      }
      if (data['customers'] && data['customers'].constructor === Array) {
        this.customers = []
        for (let item of data['customers'])
          this.customers.push(Customer.fromJS(item))
      }
      this.billingType = data['billingType']
      this.duration = data['duration']
      this.quantity = data['quantity']
      this.startDate = data['startDate']
      this.startMonth = data['startMonth']
      this.startYear = data['startYear']
    }
  }

  static fromJS(data: any): ProductsVm {
    data = typeof data === 'object' ? data : {}
    let result = new ProductsVm()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['id'] = this.id
    data['name'] = this.name
    data['customerId'] = this.customerId
    data['isSelect'] = this.isSelect
    if (this.rates && this.rates.constructor === Array) {
      data['rates'] = []
      for (let item of this.rates) data['rates'].push(item.toJSON())
    }
    if (this.customers && this.customers.constructor === Array) {
      data['customers'] = []
      for (let item of this.customers) data['customers'].push(item.toJSON())
    }
    data['billingType'] = this.billingType
    data['duration'] = this.duration
    data['quantity'] = this.quantity
    data['startDate'] = this.startDate
    data['startMonth'] = this.startMonth
    data['startYear'] = this.startYear
    return data
  }
}

export interface IProductsVm {
  id: string
  name?: string
  customerId: string
  isSelect: boolean
  rates?: ProductPackageRate[]
  customers?: Customer[]
  billingType?: string
  duration: number
  quantity: number
  startDate?: string
  startMonth?: string
  startYear?: string
}

export class DataTableResponseOfUsersData
  implements IDataTableResponseOfUsersData {
  draw: number
  recordsFiltered: number
  recordsTotal: number
  data?: UsersData[]

  constructor(data?: IDataTableResponseOfUsersData) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.draw = data['draw']
      this.recordsFiltered = data['recordsFiltered']
      this.recordsTotal = data['recordsTotal']
      if (data['data'] && data['data'].constructor === Array) {
        this.data = []
        for (let item of data['data']) this.data.push(UsersData.fromJS(item))
      }
    }
  }

  static fromJS(data: any): DataTableResponseOfUsersData {
    data = typeof data === 'object' ? data : {}
    let result = new DataTableResponseOfUsersData()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['draw'] = this.draw
    data['recordsFiltered'] = this.recordsFiltered
    data['recordsTotal'] = this.recordsTotal
    if (this.data && this.data.constructor === Array) {
      data['data'] = []
      for (let item of this.data) data['data'].push(item.toJSON())
    }
    return data
  }
}

export interface IDataTableResponseOfUsersData {
  draw: number
  recordsFiltered: number
  recordsTotal: number
  data?: UsersData[]
}

export class UserDataResponse extends DataTableResponseOfUsersData
  implements IUserDataResponse {
  constructor(data?: IUserDataResponse) {
    super(data)
  }

  init(data?: any) {
    super.init(data)
    if (data) {
    }
  }

  static fromJS(data: any): UserDataResponse {
    data = typeof data === 'object' ? data : {}
    let result = new UserDataResponse()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    super.toJSON(data)
    return data
  }
}

export interface IUserDataResponse extends IDataTableResponseOfUsersData {}

export class UsersData implements IUsersData {
  id: string
  loginName?: string
  firstName?: string
  lastName?: string
  password?: string
  emailid?: string
  isActive: boolean

  constructor(data?: IUsersData) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.id = data['id']
      this.loginName = data['loginName']
      this.firstName = data['firstName']
      this.lastName = data['lastName']
      this.password = data['password']
      this.emailid = data['emailid']
      this.isActive = data['isActive']
    }
  }

  static fromJS(data: any): UsersData {
    data = typeof data === 'object' ? data : {}
    let result = new UsersData()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['id'] = this.id
    data['loginName'] = this.loginName
    data['firstName'] = this.firstName
    data['lastName'] = this.lastName
    data['password'] = this.password
    data['emailid'] = this.emailid
    data['isActive'] = this.isActive
    return data
  }
}

export interface IUsersData {
  id: string
  loginName?: string
  firstName?: string
  lastName?: string
  password?: string
  emailid?: string
  isActive: boolean
}

export class User implements IUser {
  id: string
  loginName?: string
  firstName?: string
  lastName?: string
  password?: string
  emailid?: string
  isActive: boolean
  isAdmin: boolean
  userPermissionslist?: UserPermission[]

  constructor(data?: IUser) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.id = data['id']
      this.loginName = data['loginName']
      this.firstName = data['firstName']
      this.lastName = data['lastName']
      this.password = data['password']
      this.emailid = data['emailid']
      this.isActive = data['isActive']
      this.isAdmin = data['isAdmin']
      if (
        data['userPermissionslist'] &&
        data['userPermissionslist'].constructor === Array
      ) {
        this.userPermissionslist = []
        for (let item of data['userPermissionslist'])
          this.userPermissionslist.push(UserPermission.fromJS(item))
      }
    }
  }

  static fromJS(data: any): User {
    data = typeof data === 'object' ? data : {}
    let result = new User()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['id'] = this.id
    data['loginName'] = this.loginName
    data['firstName'] = this.firstName
    data['lastName'] = this.lastName
    data['password'] = this.password
    data['emailid'] = this.emailid
    data['isActive'] = this.isActive
    data['isAdmin'] = this.isAdmin
    if (
      this.userPermissionslist &&
      this.userPermissionslist.constructor === Array
    ) {
      data['userPermissionslist'] = []
      for (let item of this.userPermissionslist)
        data['userPermissionslist'].push(item.toJSON())
    }
    return data
  }
}

export interface IUser {
  id: string
  loginName?: string
  firstName?: string
  lastName?: string
  password?: string
  emailid?: string
  isActive: boolean
  isAdmin: boolean
  userPermissionslist?: UserPermission[]
}

export class UserPermission implements IUserPermission {
  id: string
  userId: string
  formName?: string
  viewAction: boolean
  addAction: boolean
  editAction: boolean
  privileged: boolean

  constructor(data?: IUserPermission) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.id = data['id']
      this.userId = data['userId']
      this.formName = data['formName']
      this.viewAction = data['viewAction']
      this.addAction = data['addAction']
      this.editAction = data['editAction']
      this.privileged = data['privileged']
    }
  }

  static fromJS(data: any): UserPermission {
    data = typeof data === 'object' ? data : {}
    let result = new UserPermission()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['id'] = this.id
    data['userId'] = this.userId
    data['formName'] = this.formName
    data['viewAction'] = this.viewAction
    data['addAction'] = this.addAction
    data['editAction'] = this.editAction
    data['privileged'] = this.privileged
    return data
  }
}

export interface IUserPermission {
  id: string
  userId: string
  formName?: string
  viewAction: boolean
  addAction: boolean
  editAction: boolean
  privileged: boolean
}

export class UserCrudResponse implements IUserCrudResponse {
  message?: string
  isSuccess: boolean

  constructor(data?: IUserCrudResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.message = data['message']
      this.isSuccess = data['isSuccess']
    }
  }

  static fromJS(data: any): UserCrudResponse {
    data = typeof data === 'object' ? data : {}
    let result = new UserCrudResponse()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['message'] = this.message
    data['isSuccess'] = this.isSuccess
    return data
  }
}

export interface IUserCrudResponse {
  message?: string
  isSuccess: boolean
}

export class Menu implements IMenu {
  caption?: string
  image?: string
  url?: string
  isSelected: boolean
  subMenus?: Menu[]

  constructor(data?: IMenu) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.caption = data['caption']
      this.image = data['image']
      this.url = data['url']
      this.isSelected = data['isSelected']
      if (data['subMenus'] && data['subMenus'].constructor === Array) {
        this.subMenus = []
        for (let item of data['subMenus']) this.subMenus.push(Menu.fromJS(item))
      }
    }
  }

  static fromJS(data: any): Menu {
    data = typeof data === 'object' ? data : {}
    let result = new Menu()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['caption'] = this.caption
    data['image'] = this.image
    data['url'] = this.url
    data['isSelected'] = this.isSelected
    if (this.subMenus && this.subMenus.constructor === Array) {
      data['subMenus'] = []
      for (let item of this.subMenus) data['subMenus'].push(item.toJSON())
    }
    return data
  }
}

export interface IMenu {
  caption?: string
  image?: string
  url?: string
  isSelected: boolean
  subMenus?: Menu[]
}

export class DataTableResponseOfCustomerData
  implements IDataTableResponseOfCustomerData {
  draw: number
  recordsFiltered: number
  recordsTotal: number
  data?: CustomerData[]

  constructor(data?: IDataTableResponseOfCustomerData) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.draw = data['draw']
      this.recordsFiltered = data['recordsFiltered']
      this.recordsTotal = data['recordsTotal']
      if (data['data'] && data['data'].constructor === Array) {
        this.data = []
        for (let item of data['data']) this.data.push(CustomerData.fromJS(item))
      }
    }
  }

  static fromJS(data: any): DataTableResponseOfCustomerData {
    data = typeof data === 'object' ? data : {}
    let result = new DataTableResponseOfCustomerData()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['draw'] = this.draw
    data['recordsFiltered'] = this.recordsFiltered
    data['recordsTotal'] = this.recordsTotal
    if (this.data && this.data.constructor === Array) {
      data['data'] = []
      for (let item of this.data) data['data'].push(item.toJSON())
    }
    return data
  }
}

export interface IDataTableResponseOfCustomerData {
  draw: number
  recordsFiltered: number
  recordsTotal: number
  data?: CustomerData[]
}

export class CustomerDetailsResponse extends DataTableResponseOfCustomerData
  implements ICustomerDetailsResponse {
  constructor(data?: ICustomerDetailsResponse) {
    super(data)
  }

  init(data?: any) {
    super.init(data)
    if (data) {
    }
  }

  static fromJS(data: any): CustomerDetailsResponse {
    data = typeof data === 'object' ? data : {}
    let result = new CustomerDetailsResponse()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    super.toJSON(data)
    return data
  }
}

export interface ICustomerDetailsResponse
  extends IDataTableResponseOfCustomerData {}

export class CustomerData implements ICustomerData {
  id: string
  tradingName?: string
  registrationName?: string
  registrationNumber?: string
  vatNumber?: string
  branchLocation?: string
  physicalAddress?: string
  typeOfBusiness?: string
  telephoneNumber?: string
  faxNumber?: string
  billingEmail?: string
  status?: string
  code?: string
  billingType?: string

  constructor(data?: ICustomerData) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.id = data['id']
      this.tradingName = data['tradingName']
      this.registrationName = data['registrationName']
      this.registrationNumber = data['registrationNumber']
      this.vatNumber = data['vatNumber']
      this.branchLocation = data['branchLocation']
      this.physicalAddress = data['physicalAddress']
      this.typeOfBusiness = data['typeOfBusiness']
      this.telephoneNumber = data['telephoneNumber']
      this.faxNumber = data['faxNumber']
      this.billingEmail = data['billingEmail']
      this.status = data['status']
      this.code = data['code']
      this.billingType = data['billingType']
    }
  }

  static fromJS(data: any): CustomerData {
    data = typeof data === 'object' ? data : {}
    let result = new CustomerData()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['id'] = this.id
    data['tradingName'] = this.tradingName
    data['registrationName'] = this.registrationName
    data['registrationNumber'] = this.registrationNumber
    data['vatNumber'] = this.vatNumber
    data['branchLocation'] = this.branchLocation
    data['physicalAddress'] = this.physicalAddress
    data['typeOfBusiness'] = this.typeOfBusiness
    data['telephoneNumber'] = this.telephoneNumber
    data['faxNumber'] = this.faxNumber
    data['billingEmail'] = this.billingEmail
    data['status'] = this.status
    data['code'] = this.code
    data['billingType'] = this.billingType
    return data
  }
}

export interface ICustomerData {
  id: string
  tradingName?: string
  registrationName?: string
  registrationNumber?: string
  vatNumber?: string
  branchLocation?: string
  physicalAddress?: string
  typeOfBusiness?: string
  telephoneNumber?: string
  faxNumber?: string
  billingEmail?: string
  status?: string
  code?: string
  billingType?: string
}

export class CustomersVm implements ICustomersVm {
  customer?: Customer
  idaSuserId: string
  filenames?: FileNames[]

  constructor(data?: ICustomersVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.customer = data['customer']
        ? Customer.fromJS(data['customer'])
        : <any>undefined
      this.idaSuserId = data['idaSuserId']
      if (data['filenames'] && data['filenames'].constructor === Array) {
        this.filenames = []
        for (let item of data['filenames'])
          this.filenames.push(FileNames.fromJS(item))
      }
    }
  }

  static fromJS(data: any): CustomersVm {
    data = typeof data === 'object' ? data : {}
    let result = new CustomersVm()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['customer'] = this.customer ? this.customer.toJSON() : <any>undefined
    data['idaSuserId'] = this.idaSuserId
    if (this.filenames && this.filenames.constructor === Array) {
      data['filenames'] = []
      for (let item of this.filenames) data['filenames'].push(item.toJSON())
    }
    return data
  }
}

export interface ICustomersVm {
  customer?: Customer
  idaSuserId: string
  filenames?: FileNames[]
}

export class FileNames implements IFileNames {
  path?: string
  name?: string

  constructor(data?: IFileNames) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.path = data['path']
      this.name = data['name']
    }
  }

  static fromJS(data: any): FileNames {
    data = typeof data === 'object' ? data : {}
    let result = new FileNames()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['path'] = this.path
    data['name'] = this.name
    return data
  }
}

export interface IFileNames {
  path?: string
  name?: string
}

export class CustomerProdcutVm implements ICustomerProdcutVm {
  customerProductProperties?: CustomerProductProperty[]
  customerId: string

  constructor(data?: ICustomerProdcutVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      if (
        data['customerProductProperties'] &&
        data['customerProductProperties'].constructor === Array
      ) {
        this.customerProductProperties = []
        for (let item of data['customerProductProperties'])
          this.customerProductProperties.push(
            CustomerProductProperty.fromJS(item),
          )
      }
      this.customerId = data['customerId']
    }
  }

  static fromJS(data: any): CustomerProdcutVm {
    data = typeof data === 'object' ? data : {}
    let result = new CustomerProdcutVm()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    if (
      this.customerProductProperties &&
      this.customerProductProperties.constructor === Array
    ) {
      data['customerProductProperties'] = []
      for (let item of this.customerProductProperties)
        data['customerProductProperties'].push(item.toJSON())
    }
    data['customerId'] = this.customerId
    return data
  }
}

export interface ICustomerProdcutVm {
  customerProductProperties?: CustomerProductProperty[]
  customerId: string
}

export class CustomerProductProperty implements ICustomerProductProperty {
  id: string
  productId: string
  isActive: boolean

  constructor(data?: ICustomerProductProperty) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.id = data['id']
      this.productId = data['productId']
      this.isActive = data['isActive']
    }
  }

  static fromJS(data: any): CustomerProductProperty {
    data = typeof data === 'object' ? data : {}
    let result = new CustomerProductProperty()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['id'] = this.id
    data['productId'] = this.productId
    data['isActive'] = this.isActive
    return data
  }
}

export interface ICustomerProductProperty {
  id: string
  productId: string
  isActive: boolean
}

export class LookupData implements ILookupData {
  id: string
  type?: string
  value?: string
  text?: string
  isActive: boolean

  constructor(data?: ILookupData) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.id = data['id']
      this.type = data['type']
      this.value = data['value']
      this.text = data['text']
      this.isActive = data['isActive']
    }
  }

  static fromJS(data: any): LookupData {
    data = typeof data === 'object' ? data : {}
    let result = new LookupData()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['id'] = this.id
    data['type'] = this.type
    data['value'] = this.value
    data['text'] = this.text
    data['isActive'] = this.isActive
    return data
  }
}

export interface ILookupData {
  id: string
  type?: string
  value?: string
  text?: string
  isActive: boolean
}

export class DonotCallRegistrySearchRequest
  implements IDonotCallRegistrySearchRequest {
  fromdate?: string
  todate?: string
  dtRequest?: DataTableRequest

  constructor(data?: IDonotCallRegistrySearchRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.fromdate = data['fromdate']
      this.todate = data['todate']
      this.dtRequest = data['dtRequest']
        ? DataTableRequest.fromJS(data['dtRequest'])
        : <any>undefined
    }
  }

  static fromJS(data: any): DonotCallRegistrySearchRequest {
    data = typeof data === 'object' ? data : {}
    let result = new DonotCallRegistrySearchRequest()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['fromdate'] = this.fromdate
    data['todate'] = this.todate
    data['dtRequest'] = this.dtRequest
      ? this.dtRequest.toJSON()
      : <any>undefined
    return data
  }
}

export interface IDonotCallRegistrySearchRequest {
  fromdate?: string
  todate?: string
  dtRequest?: DataTableRequest
}

export class DataTableResponseOfDncrList
  implements IDataTableResponseOfDncrList {
  draw: number
  recordsFiltered: number
  recordsTotal: number
  data?: DncrList[]

  constructor(data?: IDataTableResponseOfDncrList) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.draw = data['draw']
      this.recordsFiltered = data['recordsFiltered']
      this.recordsTotal = data['recordsTotal']
      if (data['data'] && data['data'].constructor === Array) {
        this.data = []
        for (let item of data['data']) this.data.push(DncrList.fromJS(item))
      }
    }
  }

  static fromJS(data: any): DataTableResponseOfDncrList {
    data = typeof data === 'object' ? data : {}
    let result = new DataTableResponseOfDncrList()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['draw'] = this.draw
    data['recordsFiltered'] = this.recordsFiltered
    data['recordsTotal'] = this.recordsTotal
    if (this.data && this.data.constructor === Array) {
      data['data'] = []
      for (let item of this.data) data['data'].push(item.toJSON())
    }
    return data
  }
}

export interface IDataTableResponseOfDncrList {
  draw: number
  recordsFiltered: number
  recordsTotal: number
  data?: DncrList[]
}

export class DncrResponse extends DataTableResponseOfDncrList
  implements IDncrResponse {
  constructor(data?: IDncrResponse) {
    super(data)
  }

  init(data?: any) {
    super.init(data)
    if (data) {
    }
  }

  static fromJS(data: any): DncrResponse {
    data = typeof data === 'object' ? data : {}
    let result = new DncrResponse()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    super.toJSON(data)
    return data
  }
}

export interface IDncrResponse extends IDataTableResponseOfDncrList {}

export class DncrList implements IDncrList {
  id: string
  name?: string
  surname?: string
  emailId?: string
  idNumber?: string
  phoneNumber?: string
  currentDate: Date
  isApproved: boolean

  constructor(data?: IDncrList) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.id = data['id']
      this.name = data['name']
      this.surname = data['surname']
      this.emailId = data['emailId']
      this.idNumber = data['idNumber']
      this.phoneNumber = data['phoneNumber']
      this.currentDate = data['currentDate']
        ? new Date(data['currentDate'].toString())
        : <any>undefined
      this.isApproved = data['isApproved']
    }
  }

  static fromJS(data: any): DncrList {
    data = typeof data === 'object' ? data : {}
    let result = new DncrList()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['id'] = this.id
    data['name'] = this.name
    data['surname'] = this.surname
    data['emailId'] = this.emailId
    data['idNumber'] = this.idNumber
    data['phoneNumber'] = this.phoneNumber
    data['currentDate'] = this.currentDate
      ? this.currentDate.toISOString()
      : <any>undefined
    data['isApproved'] = this.isApproved
    return data
  }
}

export interface IDncrList {
  id: string
  name?: string
  surname?: string
  emailId?: string
  idNumber?: string
  phoneNumber?: string
  currentDate: Date
  isApproved: boolean
}

export class DoNotCallRegistry implements IDoNotCallRegistry {
  id: string
  name?: string
  surname?: string
  emailid?: string
  idnumber?: string
  phoneNumber?: string
  currentDate: Date
  isApproved: boolean

  constructor(data?: IDoNotCallRegistry) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.id = data['id']
      this.name = data['name']
      this.surname = data['surname']
      this.emailid = data['emailid']
      this.idnumber = data['idnumber']
      this.phoneNumber = data['phoneNumber']
      this.currentDate = data['currentDate']
        ? new Date(data['currentDate'].toString())
        : <any>undefined
      this.isApproved = data['isApproved']
    }
  }

  static fromJS(data: any): DoNotCallRegistry {
    data = typeof data === 'object' ? data : {}
    let result = new DoNotCallRegistry()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['id'] = this.id
    data['name'] = this.name
    data['surname'] = this.surname
    data['emailid'] = this.emailid
    data['idnumber'] = this.idnumber
    data['phoneNumber'] = this.phoneNumber
    data['currentDate'] = this.currentDate
      ? this.currentDate.toISOString()
      : <any>undefined
    data['isApproved'] = this.isApproved
    return data
  }
}

export interface IDoNotCallRegistry {
  id: string
  name?: string
  surname?: string
  emailid?: string
  idnumber?: string
  phoneNumber?: string
  currentDate: Date
  isApproved: boolean
}

export class CrudResponseDonotCall implements ICrudResponseDonotCall {
  message?: string
  isSuccess: boolean

  constructor(data?: ICrudResponseDonotCall) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.message = data['message']
      this.isSuccess = data['isSuccess']
    }
  }

  static fromJS(data: any): CrudResponseDonotCall {
    data = typeof data === 'object' ? data : {}
    let result = new CrudResponseDonotCall()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['message'] = this.message
    data['isSuccess'] = this.isSuccess
    return data
  }
}

export interface ICrudResponseDonotCall {
  message?: string
  isSuccess: boolean
}

export class DoNotCallRegistryVM implements IDoNotCallRegistryVM {
  surname?: string
  name?: string
  idNo?: string
  emailId?: string
  phoneNumber?: string
  isApproved?: string
  remarks?: string

  constructor(data?: IDoNotCallRegistryVM) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.surname = data['surname']
      this.name = data['name']
      this.idNo = data['idNo']
      this.emailId = data['emailId']
      this.phoneNumber = data['phoneNumber']
      this.isApproved = data['isApproved']
      this.remarks = data['remarks']
    }
  }

  static fromJS(data: any): DoNotCallRegistryVM {
    data = typeof data === 'object' ? data : {}
    let result = new DoNotCallRegistryVM()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['surname'] = this.surname
    data['name'] = this.name
    data['idNo'] = this.idNo
    data['emailId'] = this.emailId
    data['phoneNumber'] = this.phoneNumber
    data['isApproved'] = this.isApproved
    data['remarks'] = this.remarks
    return data
  }
}

export interface IDoNotCallRegistryVM {
  surname?: string
  name?: string
  idNo?: string
  emailId?: string
  phoneNumber?: string
  isApproved?: string
  remarks?: string
}

export class DataTableResponseOfEmailTemplateList
  implements IDataTableResponseOfEmailTemplateList {
  draw: number
  recordsFiltered: number
  recordsTotal: number
  data?: EmailTemplateList[]

  constructor(data?: IDataTableResponseOfEmailTemplateList) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.draw = data['draw']
      this.recordsFiltered = data['recordsFiltered']
      this.recordsTotal = data['recordsTotal']
      if (data['data'] && data['data'].constructor === Array) {
        this.data = []
        for (let item of data['data'])
          this.data.push(EmailTemplateList.fromJS(item))
      }
    }
  }

  static fromJS(data: any): DataTableResponseOfEmailTemplateList {
    data = typeof data === 'object' ? data : {}
    let result = new DataTableResponseOfEmailTemplateList()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['draw'] = this.draw
    data['recordsFiltered'] = this.recordsFiltered
    data['recordsTotal'] = this.recordsTotal
    if (this.data && this.data.constructor === Array) {
      data['data'] = []
      for (let item of this.data) data['data'].push(item.toJSON())
    }
    return data
  }
}

export interface IDataTableResponseOfEmailTemplateList {
  draw: number
  recordsFiltered: number
  recordsTotal: number
  data?: EmailTemplateList[]
}

export class EmailTemplateResponse extends DataTableResponseOfEmailTemplateList
  implements IEmailTemplateResponse {
  constructor(data?: IEmailTemplateResponse) {
    super(data)
  }

  init(data?: any) {
    super.init(data)
    if (data) {
    }
  }

  static fromJS(data: any): EmailTemplateResponse {
    data = typeof data === 'object' ? data : {}
    let result = new EmailTemplateResponse()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    super.toJSON(data)
    return data
  }
}

export interface IEmailTemplateResponse
  extends IDataTableResponseOfEmailTemplateList {}

export class EmailTemplateList implements IEmailTemplateList {
  id: string
  subject?: string
  mailContent?: string
  type?: string

  constructor(data?: IEmailTemplateList) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.id = data['id']
      this.subject = data['subject']
      this.mailContent = data['mailContent']
      this.type = data['type']
    }
  }

  static fromJS(data: any): EmailTemplateList {
    data = typeof data === 'object' ? data : {}
    let result = new EmailTemplateList()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['id'] = this.id
    data['subject'] = this.subject
    data['mailContent'] = this.mailContent
    data['type'] = this.type
    return data
  }
}

export interface IEmailTemplateList {
  id: string
  subject?: string
  mailContent?: string
  type?: string
}

export class EmailTemplate implements IEmailTemplate {
  id: string
  subject?: string
  mailContent?: string
  type?: string

  constructor(data?: IEmailTemplate) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.id = data['id']
      this.subject = data['subject']
      this.mailContent = data['mailContent']
      this.type = data['type']
    }
  }

  static fromJS(data: any): EmailTemplate {
    data = typeof data === 'object' ? data : {}
    let result = new EmailTemplate()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['id'] = this.id
    data['subject'] = this.subject
    data['mailContent'] = this.mailContent
    data['type'] = this.type
    return data
  }
}

export interface IEmailTemplate {
  id: string
  subject?: string
  mailContent?: string
  type?: string
}

export class CrudResponseemail implements ICrudResponseemail {
  message?: string
  isSuccess: boolean

  constructor(data?: ICrudResponseemail) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.message = data['message']
      this.isSuccess = data['isSuccess']
    }
  }

  static fromJS(data: any): CrudResponseemail {
    data = typeof data === 'object' ? data : {}
    let result = new CrudResponseemail()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['message'] = this.message
    data['isSuccess'] = this.isSuccess
    return data
  }
}

export interface ICrudResponseemail {
  message?: string
  isSuccess: boolean
}

export class InvoiceDataTableRequest implements IInvoiceDataTableRequest {
  fromdate?: string
  todate?: string
  customerId: string
  ispaid?: string
  isCreditNoteRaised: boolean
  dtRequest?: DataTableRequest

  constructor(data?: IInvoiceDataTableRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.fromdate = data['fromdate']
      this.todate = data['todate']
      this.customerId = data['customerId']
      this.ispaid = data['ispaid']
      this.isCreditNoteRaised = data['isCreditNoteRaised']
      this.dtRequest = data['dtRequest']
        ? DataTableRequest.fromJS(data['dtRequest'])
        : <any>undefined
    }
  }

  static fromJS(data: any): InvoiceDataTableRequest {
    data = typeof data === 'object' ? data : {}
    let result = new InvoiceDataTableRequest()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['fromdate'] = this.fromdate
    data['todate'] = this.todate
    data['customerId'] = this.customerId
    data['ispaid'] = this.ispaid
    data['isCreditNoteRaised'] = this.isCreditNoteRaised
    data['dtRequest'] = this.dtRequest
      ? this.dtRequest.toJSON()
      : <any>undefined
    return data
  }
}

export interface IInvoiceDataTableRequest {
  fromdate?: string
  todate?: string
  customerId: string
  ispaid?: string
  isCreditNoteRaised: boolean
  dtRequest?: DataTableRequest
}

export class DataTableResponseOfInvoiceVm
  implements IDataTableResponseOfInvoiceVm {
  draw: number
  recordsFiltered: number
  recordsTotal: number
  data?: InvoiceVm[]

  constructor(data?: IDataTableResponseOfInvoiceVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.draw = data['draw']
      this.recordsFiltered = data['recordsFiltered']
      this.recordsTotal = data['recordsTotal']
      if (data['data'] && data['data'].constructor === Array) {
        this.data = []
        for (let item of data['data']) this.data.push(InvoiceVm.fromJS(item))
      }
    }
  }

  static fromJS(data: any): DataTableResponseOfInvoiceVm {
    data = typeof data === 'object' ? data : {}
    let result = new DataTableResponseOfInvoiceVm()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['draw'] = this.draw
    data['recordsFiltered'] = this.recordsFiltered
    data['recordsTotal'] = this.recordsTotal
    if (this.data && this.data.constructor === Array) {
      data['data'] = []
      for (let item of this.data) data['data'].push(item.toJSON())
    }
    return data
  }
}

export interface IDataTableResponseOfInvoiceVm {
  draw: number
  recordsFiltered: number
  recordsTotal: number
  data?: InvoiceVm[]
}

export class InvoiceDataResponse extends DataTableResponseOfInvoiceVm
  implements IInvoiceDataResponse {
  constructor(data?: IInvoiceDataResponse) {
    super(data)
  }

  init(data?: any) {
    super.init(data)
    if (data) {
    }
  }

  static fromJS(data: any): InvoiceDataResponse {
    data = typeof data === 'object' ? data : {}
    let result = new InvoiceDataResponse()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    super.toJSON(data)
    return data
  }
}

export interface IInvoiceDataResponse extends IDataTableResponseOfInvoiceVm {}

export class InvoiceVm implements IInvoiceVm {
  id: string
  invoiceNumber: number
  proFormaInvoice: boolean
  date: Date
  emailDate: Date
  paymentReceivedDate: Date
  referenceNumber: number
  subTotal: number
  discount: number
  vatTotal: number
  total: number
  billingType?: string
  tradingName?: string
  customerCode?: string
  invoiceLineItems?: InvoiceLineItem[]
  customer?: Customer
  customerId: string
  subscription?: Subscription
  subscriptionID?: string
  isCancelled: boolean
  isPayed: boolean
  isCreditNoteRaised: boolean
  creditNoteNumber?: string
  creditNoteTotal: number
  msg?: string
  paymentValue?: number
  invoiceDate: Date
  isProformaInvoice: boolean
  invoiceDisplayNumber?: string
  isTacinvSent: boolean

  constructor(data?: IInvoiceVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.id = data['id']
      this.invoiceNumber = data['invoiceNumber']
      this.proFormaInvoice = data['proFormaInvoice']
      this.date = data['date']
        ? new Date(data['date'].toString())
        : <any>undefined
      this.emailDate = data['emailDate']
        ? new Date(data['emailDate'].toString())
        : <any>undefined
      this.paymentReceivedDate = data['paymentReceivedDate']
        ? new Date(data['paymentReceivedDate'].toString())
        : <any>undefined
      this.referenceNumber = data['referenceNumber']
      this.subTotal = data['subTotal']
      this.discount = data['discount']
      this.vatTotal = data['vatTotal']
      this.total = data['total']
      this.billingType = data['billingType']
      this.tradingName = data['tradingName']
      this.customerCode = data['customerCode']
      if (
        data['invoiceLineItems'] &&
        data['invoiceLineItems'].constructor === Array
      ) {
        this.invoiceLineItems = []
        for (let item of data['invoiceLineItems'])
          this.invoiceLineItems.push(InvoiceLineItem.fromJS(item))
      }
      this.customer = data['customer']
        ? Customer.fromJS(data['customer'])
        : <any>undefined
      this.customerId = data['customerId']
      this.subscription = data['subscription']
        ? Subscription.fromJS(data['subscription'])
        : <any>undefined
      this.subscriptionID = data['subscriptionID']
      this.isCancelled = data['isCancelled']
      this.isPayed = data['isPayed']
      this.isCreditNoteRaised = data['isCreditNoteRaised']
      this.creditNoteNumber = data['creditNoteNumber']
      this.creditNoteTotal = data['creditNoteTotal']
      this.msg = data['msg']
      this.paymentValue = data['paymentValue']
      this.invoiceDate = data['invoiceDate']
        ? new Date(data['invoiceDate'].toString())
        : <any>undefined
      this.isProformaInvoice = data['isProformaInvoice']
      this.invoiceDisplayNumber = data['invoiceDisplayNumber']
      this.isTacinvSent = data['isTacinvSent']
    }
  }

  static fromJS(data: any): InvoiceVm {
    data = typeof data === 'object' ? data : {}
    let result = new InvoiceVm()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['id'] = this.id
    data['invoiceNumber'] = this.invoiceNumber
    data['proFormaInvoice'] = this.proFormaInvoice
    data['date'] = this.date ? this.date.toISOString() : <any>undefined
    data['emailDate'] = this.emailDate
      ? this.emailDate.toISOString()
      : <any>undefined
    data['paymentReceivedDate'] = this.paymentReceivedDate
      ? this.paymentReceivedDate.toISOString()
      : <any>undefined
    data['referenceNumber'] = this.referenceNumber
    data['subTotal'] = this.subTotal
    data['discount'] = this.discount
    data['vatTotal'] = this.vatTotal
    data['total'] = this.total
    data['billingType'] = this.billingType
    data['tradingName'] = this.tradingName
    data['customerCode'] = this.customerCode
    if (this.invoiceLineItems && this.invoiceLineItems.constructor === Array) {
      data['invoiceLineItems'] = []
      for (let item of this.invoiceLineItems)
        data['invoiceLineItems'].push(item.toJSON())
    }
    data['customer'] = this.customer ? this.customer.toJSON() : <any>undefined
    data['customerId'] = this.customerId
    data['subscription'] = this.subscription
      ? this.subscription.toJSON()
      : <any>undefined
    data['subscriptionID'] = this.subscriptionID
    data['isCancelled'] = this.isCancelled
    data['isPayed'] = this.isPayed
    data['isCreditNoteRaised'] = this.isCreditNoteRaised
    data['creditNoteNumber'] = this.creditNoteNumber
    data['creditNoteTotal'] = this.creditNoteTotal
    data['msg'] = this.msg
    data['paymentValue'] = this.paymentValue
    data['invoiceDate'] = this.invoiceDate
      ? this.invoiceDate.toISOString()
      : <any>undefined
    data['isProformaInvoice'] = this.isProformaInvoice
    data['invoiceDisplayNumber'] = this.invoiceDisplayNumber
    data['isTacinvSent'] = this.isTacinvSent
    return data
  }
}

export interface IInvoiceVm {
  id: string
  invoiceNumber: number
  proFormaInvoice: boolean
  date: Date
  emailDate: Date
  paymentReceivedDate: Date
  referenceNumber: number
  subTotal: number
  discount: number
  vatTotal: number
  total: number
  billingType?: string
  tradingName?: string
  customerCode?: string
  invoiceLineItems?: InvoiceLineItem[]
  customer?: Customer
  customerId: string
  subscription?: Subscription
  subscriptionID?: string
  isCancelled: boolean
  isPayed: boolean
  isCreditNoteRaised: boolean
  creditNoteNumber?: string
  creditNoteTotal: number
  msg?: string
  paymentValue?: number
  invoiceDate: Date
  isProformaInvoice: boolean
  invoiceDisplayNumber?: string
  isTacinvSent: boolean
}

export class InvoiceLineItem implements IInvoiceLineItem {
  id: string
  invoiceID: string
  productPackageRate?: ProductPackageRate
  productPackageRateID?: string
  description?: string
  quantity: number
  unitPrice: number
  netAmount: number
  vatAmount: number
  billingType?: string
  usageType?: string
  subscription?: Subscription
  subscriptionID?: string

  constructor(data?: IInvoiceLineItem) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.id = data['id']
      this.invoiceID = data['invoiceID']
      this.productPackageRate = data['productPackageRate']
        ? ProductPackageRate.fromJS(data['productPackageRate'])
        : <any>undefined
      this.productPackageRateID = data['productPackageRateID']
      this.description = data['description']
      this.quantity = data['quantity']
      this.unitPrice = data['unitPrice']
      this.netAmount = data['netAmount']
      this.vatAmount = data['vatAmount']
      this.billingType = data['billingType']
      this.usageType = data['usageType']
      this.subscription = data['subscription']
        ? Subscription.fromJS(data['subscription'])
        : <any>undefined
      this.subscriptionID = data['subscriptionID']
    }
  }

  static fromJS(data: any): InvoiceLineItem {
    data = typeof data === 'object' ? data : {}
    let result = new InvoiceLineItem()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['id'] = this.id
    data['invoiceID'] = this.invoiceID
    data['productPackageRate'] = this.productPackageRate
      ? this.productPackageRate.toJSON()
      : <any>undefined
    data['productPackageRateID'] = this.productPackageRateID
    data['description'] = this.description
    data['quantity'] = this.quantity
    data['unitPrice'] = this.unitPrice
    data['netAmount'] = this.netAmount
    data['vatAmount'] = this.vatAmount
    data['billingType'] = this.billingType
    data['usageType'] = this.usageType
    data['subscription'] = this.subscription
      ? this.subscription.toJSON()
      : <any>undefined
    data['subscriptionID'] = this.subscriptionID
    return data
  }
}

export interface IInvoiceLineItem {
  id: string
  invoiceID: string
  productPackageRate?: ProductPackageRate
  productPackageRateID?: string
  description?: string
  quantity: number
  unitPrice: number
  netAmount: number
  vatAmount: number
  billingType?: string
  usageType?: string
  subscription?: Subscription
  subscriptionID?: string
}

export class Invoice implements IInvoice {
  id: string
  invoiceNumber: number
  proFormaInvoice: boolean
  date: Date
  referenceNumber: number
  subTotal: number
  discount: number
  vatTotal: number
  total: number
  billingType?: string
  remarks?: string
  invoiceLineItems?: InvoiceLineItem[]
  customer?: Customer
  customerId: string
  subscription?: Subscription
  subscriptionID?: string
  ispaid: boolean
  isCreditNoteRaised: boolean
  isSubmited: boolean
  isCancelled: boolean
  isEmailSend: boolean
  emailSendDate: Date
  invoiceDate: Date
  invoiceDisplayNumber?: string
  isTaxinvSent: boolean

  constructor(data?: IInvoice) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.id = data['id']
      this.invoiceNumber = data['invoiceNumber']
      this.proFormaInvoice = data['proFormaInvoice']
      this.date = data['date']
        ? new Date(data['date'].toString())
        : <any>undefined
      this.referenceNumber = data['referenceNumber']
      this.subTotal = data['subTotal']
      this.discount = data['discount']
      this.vatTotal = data['vatTotal']
      this.total = data['total']
      this.billingType = data['billingType']
      this.remarks = data['remarks']
      if (
        data['invoiceLineItems'] &&
        data['invoiceLineItems'].constructor === Array
      ) {
        this.invoiceLineItems = []
        for (let item of data['invoiceLineItems'])
          this.invoiceLineItems.push(InvoiceLineItem.fromJS(item))
      }
      this.customer = data['customer']
        ? Customer.fromJS(data['customer'])
        : <any>undefined
      this.customerId = data['customerId']
      this.subscription = data['subscription']
        ? Subscription.fromJS(data['subscription'])
        : <any>undefined
      this.subscriptionID = data['subscriptionID']
      this.ispaid = data['ispaid']
      this.isCreditNoteRaised = data['isCreditNoteRaised']
      this.isSubmited = data['isSubmited']
      this.isCancelled = data['isCancelled']
      this.isEmailSend = data['isEmailSend']
      this.emailSendDate = data['emailSendDate']
        ? new Date(data['emailSendDate'].toString())
        : <any>undefined
      this.invoiceDate = data['invoiceDate']
        ? new Date(data['invoiceDate'].toString())
        : <any>undefined
      this.invoiceDisplayNumber = data['invoiceDisplayNumber']
      this.isTaxinvSent = data['isTaxinvSent']
    }
  }

  static fromJS(data: any): Invoice {
    data = typeof data === 'object' ? data : {}
    let result = new Invoice()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['id'] = this.id
    data['invoiceNumber'] = this.invoiceNumber
    data['proFormaInvoice'] = this.proFormaInvoice
    data['date'] = this.date ? this.date.toISOString() : <any>undefined
    data['referenceNumber'] = this.referenceNumber
    data['subTotal'] = this.subTotal
    data['discount'] = this.discount
    data['vatTotal'] = this.vatTotal
    data['total'] = this.total
    data['billingType'] = this.billingType
    data['remarks'] = this.remarks
    if (this.invoiceLineItems && this.invoiceLineItems.constructor === Array) {
      data['invoiceLineItems'] = []
      for (let item of this.invoiceLineItems)
        data['invoiceLineItems'].push(item.toJSON())
    }
    data['customer'] = this.customer ? this.customer.toJSON() : <any>undefined
    data['customerId'] = this.customerId
    data['subscription'] = this.subscription
      ? this.subscription.toJSON()
      : <any>undefined
    data['subscriptionID'] = this.subscriptionID
    data['ispaid'] = this.ispaid
    data['isCreditNoteRaised'] = this.isCreditNoteRaised
    data['isSubmited'] = this.isSubmited
    data['isCancelled'] = this.isCancelled
    data['isEmailSend'] = this.isEmailSend
    data['emailSendDate'] = this.emailSendDate
      ? this.emailSendDate.toISOString()
      : <any>undefined
    data['invoiceDate'] = this.invoiceDate
      ? this.invoiceDate.toISOString()
      : <any>undefined
    data['invoiceDisplayNumber'] = this.invoiceDisplayNumber
    data['isTaxinvSent'] = this.isTaxinvSent
    return data
  }
}

export interface IInvoice {
  id: string
  invoiceNumber: number
  proFormaInvoice: boolean
  date: Date
  referenceNumber: number
  subTotal: number
  discount: number
  vatTotal: number
  total: number
  billingType?: string
  remarks?: string
  invoiceLineItems?: InvoiceLineItem[]
  customer?: Customer
  customerId: string
  subscription?: Subscription
  subscriptionID?: string
  ispaid: boolean
  isCreditNoteRaised: boolean
  isSubmited: boolean
  isCancelled: boolean
  isEmailSend: boolean
  emailSendDate: Date
  invoiceDate: Date
  invoiceDisplayNumber?: string
  isTaxinvSent: boolean
}

export class InvoiceCrudResponses implements IInvoiceCrudResponses {
  message?: string
  isSuccess: boolean

  constructor(data?: IInvoiceCrudResponses) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.message = data['message']
      this.isSuccess = data['isSuccess']
    }
  }

  static fromJS(data: any): InvoiceCrudResponses {
    data = typeof data === 'object' ? data : {}
    let result = new InvoiceCrudResponses()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['message'] = this.message
    data['isSuccess'] = this.isSuccess
    return data
  }
}

export interface IInvoiceCrudResponses {
  message?: string
  isSuccess: boolean
}

export class TaxInvoiceReport implements ITaxInvoiceReport {
  clientName?: string
  refrenceNumber?: string
  address?: string
  date?: string
  code?: string
  vatNumber?: string
  telePhoneNumber?: string
  email?: string
  comments?: string
  bankName?: string
  accountNumber?: string
  branchCode?: string
  idasCompanyAddress?: string
  invoice?: Invoice

  constructor(data?: ITaxInvoiceReport) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.clientName = data['clientName']
      this.refrenceNumber = data['refrenceNumber']
      this.address = data['address']
      this.date = data['date']
      this.code = data['code']
      this.vatNumber = data['vatNumber']
      this.telePhoneNumber = data['telePhoneNumber']
      this.email = data['email']
      this.comments = data['comments']
      this.bankName = data['bankName']
      this.accountNumber = data['accountNumber']
      this.branchCode = data['branchCode']
      this.idasCompanyAddress = data['idasCompanyAddress']
      this.invoice = data['invoice']
        ? Invoice.fromJS(data['invoice'])
        : <any>undefined
    }
  }

  static fromJS(data: any): TaxInvoiceReport {
    data = typeof data === 'object' ? data : {}
    let result = new TaxInvoiceReport()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['clientName'] = this.clientName
    data['refrenceNumber'] = this.refrenceNumber
    data['address'] = this.address
    data['date'] = this.date
    data['code'] = this.code
    data['vatNumber'] = this.vatNumber
    data['telePhoneNumber'] = this.telePhoneNumber
    data['email'] = this.email
    data['comments'] = this.comments
    data['bankName'] = this.bankName
    data['accountNumber'] = this.accountNumber
    data['branchCode'] = this.branchCode
    data['idasCompanyAddress'] = this.idasCompanyAddress
    data['invoice'] = this.invoice ? this.invoice.toJSON() : <any>undefined
    return data
  }
}

export interface ITaxInvoiceReport {
  clientName?: string
  refrenceNumber?: string
  address?: string
  date?: string
  code?: string
  vatNumber?: string
  telePhoneNumber?: string
  email?: string
  comments?: string
  bankName?: string
  accountNumber?: string
  branchCode?: string
  idasCompanyAddress?: string
  invoice?: Invoice
}

export class CustomerVModel implements ICustomerVModel {
  customerId: string
  customerName?: string
  registrationNumber?: string
  isSelected: boolean

  constructor(data?: ICustomerVModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.customerId = data['customerId']
      this.customerName = data['customerName']
      this.registrationNumber = data['registrationNumber']
      this.isSelected = data['isSelected']
    }
  }

  static fromJS(data: any): CustomerVModel {
    data = typeof data === 'object' ? data : {}
    let result = new CustomerVModel()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['customerId'] = this.customerId
    data['customerName'] = this.customerName
    data['registrationNumber'] = this.registrationNumber
    data['isSelected'] = this.isSelected
    return data
  }
}

export interface ICustomerVModel {
  customerId: string
  customerName?: string
  registrationNumber?: string
  isSelected: boolean
}

export class ProductVm implements IProductVm {
  id: string
  name?: string
  packageRates?: ProductPackageRateVm[]
  service?: Service
  serviceId: string
  usageType?: string

  constructor(data?: IProductVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.id = data['id']
      this.name = data['name']
      if (data['packageRates'] && data['packageRates'].constructor === Array) {
        this.packageRates = []
        for (let item of data['packageRates'])
          this.packageRates.push(ProductPackageRateVm.fromJS(item))
      }
      this.service = data['service']
        ? Service.fromJS(data['service'])
        : <any>undefined
      this.serviceId = data['serviceId']
      this.usageType = data['usageType']
    }
  }

  static fromJS(data: any): ProductVm {
    data = typeof data === 'object' ? data : {}
    let result = new ProductVm()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['id'] = this.id
    data['name'] = this.name
    if (this.packageRates && this.packageRates.constructor === Array) {
      data['packageRates'] = []
      for (let item of this.packageRates)
        data['packageRates'].push(item.toJSON())
    }
    data['service'] = this.service ? this.service.toJSON() : <any>undefined
    data['serviceId'] = this.serviceId
    data['usageType'] = this.usageType
    return data
  }
}

export interface IProductVm {
  id: string
  name?: string
  packageRates?: ProductPackageRateVm[]
  service?: Service
  serviceId: string
  usageType?: string
}

export class ProductPackageRateVm implements IProductPackageRateVm {
  id: string
  productId: string
  minLimit: number
  maxLimit: number
  unitPrice: number

  constructor(data?: IProductPackageRateVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.id = data['id']
      this.productId = data['productId']
      this.minLimit = data['minLimit']
      this.maxLimit = data['maxLimit']
      this.unitPrice = data['unitPrice']
    }
  }

  static fromJS(data: any): ProductPackageRateVm {
    data = typeof data === 'object' ? data : {}
    let result = new ProductPackageRateVm()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['id'] = this.id
    data['productId'] = this.productId
    data['minLimit'] = this.minLimit
    data['maxLimit'] = this.maxLimit
    data['unitPrice'] = this.unitPrice
    return data
  }
}

export interface IProductPackageRateVm {
  id: string
  productId: string
  minLimit: number
  maxLimit: number
  unitPrice: number
}

export class Creditnote implements ICreditnote {
  id: string
  invoice?: Invoice
  invoiceId: string
  creditNoteNumber: number
  creditNoteValue: number
  creditNoteDate: Date
  comments?: string

  constructor(data?: ICreditnote) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.id = data['id']
      this.invoice = data['invoice']
        ? Invoice.fromJS(data['invoice'])
        : <any>undefined
      this.invoiceId = data['invoiceId']
      this.creditNoteNumber = data['creditNoteNumber']
      this.creditNoteValue = data['creditNoteValue']
      this.creditNoteDate = data['creditNoteDate']
        ? new Date(data['creditNoteDate'].toString())
        : <any>undefined
      this.comments = data['comments']
    }
  }

  static fromJS(data: any): Creditnote {
    data = typeof data === 'object' ? data : {}
    let result = new Creditnote()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['id'] = this.id
    data['invoice'] = this.invoice ? this.invoice.toJSON() : <any>undefined
    data['invoiceId'] = this.invoiceId
    data['creditNoteNumber'] = this.creditNoteNumber
    data['creditNoteValue'] = this.creditNoteValue
    data['creditNoteDate'] = this.creditNoteDate
      ? this.creditNoteDate.toISOString()
      : <any>undefined
    data['comments'] = this.comments
    return data
  }
}

export interface ICreditnote {
  id: string
  invoice?: Invoice
  invoiceId: string
  creditNoteNumber: number
  creditNoteValue: number
  creditNoteDate: Date
  comments?: string
}

export class InvoiceGenerationVm implements IInvoiceGenerationVm {
  startMonth?: string
  startYear?: string
  date?: string
  customers?: CustomerVModel[]

  constructor(data?: IInvoiceGenerationVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.startMonth = data['startMonth']
      this.startYear = data['startYear']
      this.date = data['date']
      if (data['customers'] && data['customers'].constructor === Array) {
        this.customers = []
        for (let item of data['customers'])
          this.customers.push(CustomerVModel.fromJS(item))
      }
    }
  }

  static fromJS(data: any): InvoiceGenerationVm {
    data = typeof data === 'object' ? data : {}
    let result = new InvoiceGenerationVm()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['startMonth'] = this.startMonth
    data['startYear'] = this.startYear
    data['date'] = this.date
    if (this.customers && this.customers.constructor === Array) {
      data['customers'] = []
      for (let item of this.customers) data['customers'].push(item.toJSON())
    }
    return data
  }
}

export interface IInvoiceGenerationVm {
  startMonth?: string
  startYear?: string
  date?: string
  customers?: CustomerVModel[]
}

export class InvoiceBulkEmail implements IInvoiceBulkEmail {
  clientName?: string
  refrenceNumber?: string
  address?: string
  date?: string
  code?: string
  vatNumber?: string
  telePhoneNumber?: string
  email?: string
  comments?: string
  bankName?: string
  accountNumber?: string
  branchCode?: string
  idasCompanyAddress?: string
  invoicevalue: number
  isSelected: boolean
  isPaid: boolean
  invoice?: Invoice

  constructor(data?: IInvoiceBulkEmail) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.clientName = data['clientName']
      this.refrenceNumber = data['refrenceNumber']
      this.address = data['address']
      this.date = data['date']
      this.code = data['code']
      this.vatNumber = data['vatNumber']
      this.telePhoneNumber = data['telePhoneNumber']
      this.email = data['email']
      this.comments = data['comments']
      this.bankName = data['bankName']
      this.accountNumber = data['accountNumber']
      this.branchCode = data['branchCode']
      this.idasCompanyAddress = data['idasCompanyAddress']
      this.invoicevalue = data['invoicevalue']
      this.isSelected = data['isSelected']
      this.isPaid = data['isPaid']
      this.invoice = data['invoice']
        ? Invoice.fromJS(data['invoice'])
        : <any>undefined
    }
  }

  static fromJS(data: any): InvoiceBulkEmail {
    data = typeof data === 'object' ? data : {}
    let result = new InvoiceBulkEmail()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['clientName'] = this.clientName
    data['refrenceNumber'] = this.refrenceNumber
    data['address'] = this.address
    data['date'] = this.date
    data['code'] = this.code
    data['vatNumber'] = this.vatNumber
    data['telePhoneNumber'] = this.telePhoneNumber
    data['email'] = this.email
    data['comments'] = this.comments
    data['bankName'] = this.bankName
    data['accountNumber'] = this.accountNumber
    data['branchCode'] = this.branchCode
    data['idasCompanyAddress'] = this.idasCompanyAddress
    data['invoicevalue'] = this.invoicevalue
    data['isSelected'] = this.isSelected
    data['isPaid'] = this.isPaid
    data['invoice'] = this.invoice ? this.invoice.toJSON() : <any>undefined
    return data
  }
}

export interface IInvoiceBulkEmail {
  clientName?: string
  refrenceNumber?: string
  address?: string
  date?: string
  code?: string
  vatNumber?: string
  telePhoneNumber?: string
  email?: string
  comments?: string
  bankName?: string
  accountNumber?: string
  branchCode?: string
  idasCompanyAddress?: string
  invoicevalue: number
  isSelected: boolean
  isPaid: boolean
  invoice?: Invoice
}

export class EmailProperty implements IEmailProperty {
  id: string
  base64?: string
  toMail?: string
  fileName?: string
  istaxinv: boolean
  ispaid: boolean
  invoiceNumber?: string

  constructor(data?: IEmailProperty) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.id = data['id']
      this.base64 = data['base64']
      this.toMail = data['toMail']
      this.fileName = data['fileName']
      this.istaxinv = data['istaxinv']
      this.ispaid = data['ispaid']
      this.invoiceNumber = data['invoiceNumber']
    }
  }

  static fromJS(data: any): EmailProperty {
    data = typeof data === 'object' ? data : {}
    let result = new EmailProperty()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['id'] = this.id
    data['base64'] = this.base64
    data['toMail'] = this.toMail
    data['fileName'] = this.fileName
    data['istaxinv'] = this.istaxinv
    data['ispaid'] = this.ispaid
    data['invoiceNumber'] = this.invoiceNumber
    return data
  }
}

export interface IEmailProperty {
  id: string
  base64?: string
  toMail?: string
  fileName?: string
  istaxinv: boolean
  ispaid: boolean
  invoiceNumber?: string
}

export class DataTableResponseOfLookup implements IDataTableResponseOfLookup {
  draw: number
  recordsFiltered: number
  recordsTotal: number
  data?: Lookup[]

  constructor(data?: IDataTableResponseOfLookup) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.draw = data['draw']
      this.recordsFiltered = data['recordsFiltered']
      this.recordsTotal = data['recordsTotal']
      if (data['data'] && data['data'].constructor === Array) {
        this.data = []
        for (let item of data['data']) this.data.push(Lookup.fromJS(item))
      }
    }
  }

  static fromJS(data: any): DataTableResponseOfLookup {
    data = typeof data === 'object' ? data : {}
    let result = new DataTableResponseOfLookup()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['draw'] = this.draw
    data['recordsFiltered'] = this.recordsFiltered
    data['recordsTotal'] = this.recordsTotal
    if (this.data && this.data.constructor === Array) {
      data['data'] = []
      for (let item of this.data) data['data'].push(item.toJSON())
    }
    return data
  }
}

export interface IDataTableResponseOfLookup {
  draw: number
  recordsFiltered: number
  recordsTotal: number
  data?: Lookup[]
}

export class LookupDataResponse extends DataTableResponseOfLookup
  implements ILookupDataResponse {
  constructor(data?: ILookupDataResponse) {
    super(data)
  }

  init(data?: any) {
    super.init(data)
    if (data) {
    }
  }

  static fromJS(data: any): LookupDataResponse {
    data = typeof data === 'object' ? data : {}
    let result = new LookupDataResponse()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    super.toJSON(data)
    return data
  }
}

export interface ILookupDataResponse extends IDataTableResponseOfLookup {}

export class Lookup implements ILookup {
  id: string
  type?: string
  value?: string
  text?: string
  isActive: boolean

  constructor(data?: ILookup) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.id = data['id']
      this.type = data['type']
      this.value = data['value']
      this.text = data['text']
      this.isActive = data['isActive']
    }
  }

  static fromJS(data: any): Lookup {
    data = typeof data === 'object' ? data : {}
    let result = new Lookup()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['id'] = this.id
    data['type'] = this.type
    data['value'] = this.value
    data['text'] = this.text
    data['isActive'] = this.isActive
    return data
  }
}

export interface ILookup {
  id: string
  type?: string
  value?: string
  text?: string
  isActive: boolean
}

export class CrudResponse implements ICrudResponse {
  message?: string
  isSuccess: boolean

  constructor(data?: ICrudResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.message = data['message']
      this.isSuccess = data['isSuccess']
    }
  }

  static fromJS(data: any): CrudResponse {
    data = typeof data === 'object' ? data : {}
    let result = new CrudResponse()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['message'] = this.message
    data['isSuccess'] = this.isSuccess
    return data
  }
}

export interface ICrudResponse {
  message?: string
  isSuccess: boolean
}

export class PaymentDataTableRequest implements IPaymentDataTableRequest {
  fromdate?: string
  todate?: string
  customerId: string
  dtRequest?: DataTableRequest

  constructor(data?: IPaymentDataTableRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.fromdate = data['fromdate']
      this.todate = data['todate']
      this.customerId = data['customerId']
      this.dtRequest = data['dtRequest']
        ? DataTableRequest.fromJS(data['dtRequest'])
        : <any>undefined
    }
  }

  static fromJS(data: any): PaymentDataTableRequest {
    data = typeof data === 'object' ? data : {}
    let result = new PaymentDataTableRequest()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['fromdate'] = this.fromdate
    data['todate'] = this.todate
    data['customerId'] = this.customerId
    data['dtRequest'] = this.dtRequest
      ? this.dtRequest.toJSON()
      : <any>undefined
    return data
  }
}

export interface IPaymentDataTableRequest {
  fromdate?: string
  todate?: string
  customerId: string
  dtRequest?: DataTableRequest
}

export class DataTableResponseOfPaymentVm
  implements IDataTableResponseOfPaymentVm {
  draw: number
  recordsFiltered: number
  recordsTotal: number
  data?: PaymentVm[]

  constructor(data?: IDataTableResponseOfPaymentVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.draw = data['draw']
      this.recordsFiltered = data['recordsFiltered']
      this.recordsTotal = data['recordsTotal']
      if (data['data'] && data['data'].constructor === Array) {
        this.data = []
        for (let item of data['data']) this.data.push(PaymentVm.fromJS(item))
      }
    }
  }

  static fromJS(data: any): DataTableResponseOfPaymentVm {
    data = typeof data === 'object' ? data : {}
    let result = new DataTableResponseOfPaymentVm()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['draw'] = this.draw
    data['recordsFiltered'] = this.recordsFiltered
    data['recordsTotal'] = this.recordsTotal
    if (this.data && this.data.constructor === Array) {
      data['data'] = []
      for (let item of this.data) data['data'].push(item.toJSON())
    }
    return data
  }
}

export interface IDataTableResponseOfPaymentVm {
  draw: number
  recordsFiltered: number
  recordsTotal: number
  data?: PaymentVm[]
}

export class PaymentResponse extends DataTableResponseOfPaymentVm
  implements IPaymentResponse {
  constructor(data?: IPaymentResponse) {
    super(data)
  }

  init(data?: any) {
    super.init(data)
    if (data) {
    }
  }

  static fromJS(data: any): PaymentResponse {
    data = typeof data === 'object' ? data : {}
    let result = new PaymentResponse()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    super.toJSON(data)
    return data
  }
}

export interface IPaymentResponse extends IDataTableResponseOfPaymentVm {}

export class PaymentVm implements IPaymentVm {
  id: string
  invoiceId: string
  customerName?: string
  customerCode?: string
  customerId: string
  number?: string
  date: Date
  invoiceDate: Date
  paymentReceivedDate: Date
  invoiceNumber?: string
  reference?: string
  amount: number
  paymentReceivedAmount?: number
  comments?: string

  constructor(data?: IPaymentVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.id = data['id']
      this.invoiceId = data['invoiceId']
      this.customerName = data['customerName']
      this.customerCode = data['customerCode']
      this.customerId = data['customerId']
      this.number = data['number']
      this.date = data['date']
        ? new Date(data['date'].toString())
        : <any>undefined
      this.invoiceDate = data['invoiceDate']
        ? new Date(data['invoiceDate'].toString())
        : <any>undefined
      this.paymentReceivedDate = data['paymentReceivedDate']
        ? new Date(data['paymentReceivedDate'].toString())
        : <any>undefined
      this.invoiceNumber = data['invoiceNumber']
      this.reference = data['reference']
      this.amount = data['amount']
      this.paymentReceivedAmount = data['paymentReceivedAmount']
      this.comments = data['comments']
    }
  }

  static fromJS(data: any): PaymentVm {
    data = typeof data === 'object' ? data : {}
    let result = new PaymentVm()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['id'] = this.id
    data['invoiceId'] = this.invoiceId
    data['customerName'] = this.customerName
    data['customerCode'] = this.customerCode
    data['customerId'] = this.customerId
    data['number'] = this.number
    data['date'] = this.date ? this.date.toISOString() : <any>undefined
    data['invoiceDate'] = this.invoiceDate
      ? this.invoiceDate.toISOString()
      : <any>undefined
    data['paymentReceivedDate'] = this.paymentReceivedDate
      ? this.paymentReceivedDate.toISOString()
      : <any>undefined
    data['invoiceNumber'] = this.invoiceNumber
    data['reference'] = this.reference
    data['amount'] = this.amount
    data['paymentReceivedAmount'] = this.paymentReceivedAmount
    data['comments'] = this.comments
    return data
  }
}

export interface IPaymentVm {
  id: string
  invoiceId: string
  customerName?: string
  customerCode?: string
  customerId: string
  number?: string
  date: Date
  invoiceDate: Date
  paymentReceivedDate: Date
  invoiceNumber?: string
  reference?: string
  amount: number
  paymentReceivedAmount?: number
  comments?: string
}

export class Payment implements IPayment {
  id: string
  invoice?: Invoice
  invoiceId: string
  customer?: Customer
  customerId: string
  number: number
  date: Date
  paymentType?: string
  reference?: string
  amount: number
  paymentAmountReceive?: number
  paymentReceivedDate?: Date
  comments?: string

  constructor(data?: IPayment) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.id = data['id']
      this.invoice = data['invoice']
        ? Invoice.fromJS(data['invoice'])
        : <any>undefined
      this.invoiceId = data['invoiceId']
      this.customer = data['customer']
        ? Customer.fromJS(data['customer'])
        : <any>undefined
      this.customerId = data['customerId']
      this.number = data['number']
      this.date = data['date']
        ? new Date(data['date'].toString())
        : <any>undefined
      this.paymentType = data['paymentType']
      this.reference = data['reference']
      this.amount = data['amount']
      this.paymentAmountReceive = data['paymentAmountReceive']
      this.paymentReceivedDate = data['paymentReceivedDate']
        ? new Date(data['paymentReceivedDate'].toString())
        : <any>undefined
      this.comments = data['comments']
    }
  }

  static fromJS(data: any): Payment {
    data = typeof data === 'object' ? data : {}
    let result = new Payment()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['id'] = this.id
    data['invoice'] = this.invoice ? this.invoice.toJSON() : <any>undefined
    data['invoiceId'] = this.invoiceId
    data['customer'] = this.customer ? this.customer.toJSON() : <any>undefined
    data['customerId'] = this.customerId
    data['number'] = this.number
    data['date'] = this.date ? this.date.toISOString() : <any>undefined
    data['paymentType'] = this.paymentType
    data['reference'] = this.reference
    data['amount'] = this.amount
    data['paymentAmountReceive'] = this.paymentAmountReceive
    data['paymentReceivedDate'] = this.paymentReceivedDate
      ? this.paymentReceivedDate.toISOString()
      : <any>undefined
    data['comments'] = this.comments
    return data
  }
}

export interface IPayment {
  id: string
  invoice?: Invoice
  invoiceId: string
  customer?: Customer
  customerId: string
  number: number
  date: Date
  paymentType?: string
  reference?: string
  amount: number
  paymentAmountReceive?: number
  paymentReceivedDate?: Date
  comments?: string
}

export class CrudResponsePayment implements ICrudResponsePayment {
  message?: string
  isSuccess: boolean

  constructor(data?: ICrudResponsePayment) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.message = data['message']
      this.isSuccess = data['isSuccess']
    }
  }

  static fromJS(data: any): CrudResponsePayment {
    data = typeof data === 'object' ? data : {}
    let result = new CrudResponsePayment()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['message'] = this.message
    data['isSuccess'] = this.isSuccess
    return data
  }
}

export interface ICrudResponsePayment {
  message?: string
  isSuccess: boolean
}

export class ProFormaInvoiceDataTableRequest
  implements IProFormaInvoiceDataTableRequest {
  fromdate?: string
  todate?: string
  status?: string
  customerId: string
  dtRequest?: DataTableRequest

  constructor(data?: IProFormaInvoiceDataTableRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.fromdate = data['fromdate']
      this.todate = data['todate']
      this.status = data['status']
      this.customerId = data['customerId']
      this.dtRequest = data['dtRequest']
        ? DataTableRequest.fromJS(data['dtRequest'])
        : <any>undefined
    }
  }

  static fromJS(data: any): ProFormaInvoiceDataTableRequest {
    data = typeof data === 'object' ? data : {}
    let result = new ProFormaInvoiceDataTableRequest()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['fromdate'] = this.fromdate
    data['todate'] = this.todate
    data['status'] = this.status
    data['customerId'] = this.customerId
    data['dtRequest'] = this.dtRequest
      ? this.dtRequest.toJSON()
      : <any>undefined
    return data
  }
}

export interface IProFormaInvoiceDataTableRequest {
  fromdate?: string
  todate?: string
  status?: string
  customerId: string
  dtRequest?: DataTableRequest
}

export class DataTableResponseOfProFormaInvoiceVm
  implements IDataTableResponseOfProFormaInvoiceVm {
  draw: number
  recordsFiltered: number
  recordsTotal: number
  data?: ProFormaInvoiceVm[]

  constructor(data?: IDataTableResponseOfProFormaInvoiceVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.draw = data['draw']
      this.recordsFiltered = data['recordsFiltered']
      this.recordsTotal = data['recordsTotal']
      if (data['data'] && data['data'].constructor === Array) {
        this.data = []
        for (let item of data['data'])
          this.data.push(ProFormaInvoiceVm.fromJS(item))
      }
    }
  }

  static fromJS(data: any): DataTableResponseOfProFormaInvoiceVm {
    data = typeof data === 'object' ? data : {}
    let result = new DataTableResponseOfProFormaInvoiceVm()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['draw'] = this.draw
    data['recordsFiltered'] = this.recordsFiltered
    data['recordsTotal'] = this.recordsTotal
    if (this.data && this.data.constructor === Array) {
      data['data'] = []
      for (let item of this.data) data['data'].push(item.toJSON())
    }
    return data
  }
}

export interface IDataTableResponseOfProFormaInvoiceVm {
  draw: number
  recordsFiltered: number
  recordsTotal: number
  data?: ProFormaInvoiceVm[]
}

export class ProFormaInvoiceDataResponse
  extends DataTableResponseOfProFormaInvoiceVm
  implements IProFormaInvoiceDataResponse {
  constructor(data?: IProFormaInvoiceDataResponse) {
    super(data)
  }

  init(data?: any) {
    super.init(data)
    if (data) {
    }
  }

  static fromJS(data: any): ProFormaInvoiceDataResponse {
    data = typeof data === 'object' ? data : {}
    let result = new ProFormaInvoiceDataResponse()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    super.toJSON(data)
    return data
  }
}

export interface IProFormaInvoiceDataResponse
  extends IDataTableResponseOfProFormaInvoiceVm {}

export class ProFormaInvoiceVm implements IProFormaInvoiceVm {
  id: string
  proFormaInvoiceNumber: number
  proFormaInvoice: boolean
  date: Date
  emailDate: Date
  referenceNumber: number
  subTotal: number
  discount: number
  vatTotal: number
  total: number
  billingType?: string
  isSubmitted: boolean
  invoiceLineItems?: InvoiceLineItem[]
  customer?: Customer
  customerId: string
  customerName?: string
  customerCode?: string
  subscription?: Subscription
  subscriptionID?: string
  status?: string
  proDisplayNumber?: string

  constructor(data?: IProFormaInvoiceVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.id = data['id']
      this.proFormaInvoiceNumber = data['proFormaInvoiceNumber']
      this.proFormaInvoice = data['proFormaInvoice']
      this.date = data['date']
        ? new Date(data['date'].toString())
        : <any>undefined
      this.emailDate = data['emailDate']
        ? new Date(data['emailDate'].toString())
        : <any>undefined
      this.referenceNumber = data['referenceNumber']
      this.subTotal = data['subTotal']
      this.discount = data['discount']
      this.vatTotal = data['vatTotal']
      this.total = data['total']
      this.billingType = data['billingType']
      this.isSubmitted = data['isSubmitted']
      if (
        data['invoiceLineItems'] &&
        data['invoiceLineItems'].constructor === Array
      ) {
        this.invoiceLineItems = []
        for (let item of data['invoiceLineItems'])
          this.invoiceLineItems.push(InvoiceLineItem.fromJS(item))
      }
      this.customer = data['customer']
        ? Customer.fromJS(data['customer'])
        : <any>undefined
      this.customerId = data['customerId']
      this.customerName = data['customerName']
      this.customerCode = data['customerCode']
      this.subscription = data['subscription']
        ? Subscription.fromJS(data['subscription'])
        : <any>undefined
      this.subscriptionID = data['subscriptionID']
      this.status = data['status']
      this.proDisplayNumber = data['proDisplayNumber']
    }
  }

  static fromJS(data: any): ProFormaInvoiceVm {
    data = typeof data === 'object' ? data : {}
    let result = new ProFormaInvoiceVm()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['id'] = this.id
    data['proFormaInvoiceNumber'] = this.proFormaInvoiceNumber
    data['proFormaInvoice'] = this.proFormaInvoice
    data['date'] = this.date ? this.date.toISOString() : <any>undefined
    data['emailDate'] = this.emailDate
      ? this.emailDate.toISOString()
      : <any>undefined
    data['referenceNumber'] = this.referenceNumber
    data['subTotal'] = this.subTotal
    data['discount'] = this.discount
    data['vatTotal'] = this.vatTotal
    data['total'] = this.total
    data['billingType'] = this.billingType
    data['isSubmitted'] = this.isSubmitted
    if (this.invoiceLineItems && this.invoiceLineItems.constructor === Array) {
      data['invoiceLineItems'] = []
      for (let item of this.invoiceLineItems)
        data['invoiceLineItems'].push(item.toJSON())
    }
    data['customer'] = this.customer ? this.customer.toJSON() : <any>undefined
    data['customerId'] = this.customerId
    data['customerName'] = this.customerName
    data['customerCode'] = this.customerCode
    data['subscription'] = this.subscription
      ? this.subscription.toJSON()
      : <any>undefined
    data['subscriptionID'] = this.subscriptionID
    data['status'] = this.status
    data['proDisplayNumber'] = this.proDisplayNumber
    return data
  }
}

export interface IProFormaInvoiceVm {
  id: string
  proFormaInvoiceNumber: number
  proFormaInvoice: boolean
  date: Date
  emailDate: Date
  referenceNumber: number
  subTotal: number
  discount: number
  vatTotal: number
  total: number
  billingType?: string
  isSubmitted: boolean
  invoiceLineItems?: InvoiceLineItem[]
  customer?: Customer
  customerId: string
  customerName?: string
  customerCode?: string
  subscription?: Subscription
  subscriptionID?: string
  status?: string
  proDisplayNumber?: string
}

export class ProFormaInvoice implements IProFormaInvoice {
  id: string
  proFormaInvoiceNumber: number
  isProformal: boolean
  date: Date
  referenceNumber: number
  subTotal: number
  vatTotal: number
  total: number
  proformaInvoiceLineItems?: ProformaInvoiceLineItem[]
  customer?: Customer
  customerId: string
  isSubmitted: boolean
  status?: string
  remarks?: string
  isEmailSend: boolean
  emailSendDate: Date
  invoiceId?: string
  proformaDisplyNumber?: string

  constructor(data?: IProFormaInvoice) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.id = data['id']
      this.proFormaInvoiceNumber = data['proFormaInvoiceNumber']
      this.isProformal = data['isProformal']
      this.date = data['date']
        ? new Date(data['date'].toString())
        : <any>undefined
      this.referenceNumber = data['referenceNumber']
      this.subTotal = data['subTotal']
      this.vatTotal = data['vatTotal']
      this.total = data['total']
      if (
        data['proformaInvoiceLineItems'] &&
        data['proformaInvoiceLineItems'].constructor === Array
      ) {
        this.proformaInvoiceLineItems = []
        for (let item of data['proformaInvoiceLineItems'])
          this.proformaInvoiceLineItems.push(
            ProformaInvoiceLineItem.fromJS(item),
          )
      }
      this.customer = data['customer']
        ? Customer.fromJS(data['customer'])
        : <any>undefined
      this.customerId = data['customerId']
      this.isSubmitted = data['isSubmitted']
      this.status = data['status']
      this.remarks = data['remarks']
      this.isEmailSend = data['isEmailSend']
      this.emailSendDate = data['emailSendDate']
        ? new Date(data['emailSendDate'].toString())
        : <any>undefined
      this.invoiceId = data['invoiceId']
      this.proformaDisplyNumber = data['proformaDisplyNumber']
    }
  }

  static fromJS(data: any): ProFormaInvoice {
    data = typeof data === 'object' ? data : {}
    let result = new ProFormaInvoice()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['id'] = this.id
    data['proFormaInvoiceNumber'] = this.proFormaInvoiceNumber
    data['isProformal'] = this.isProformal
    data['date'] = this.date ? this.date.toISOString() : <any>undefined
    data['referenceNumber'] = this.referenceNumber
    data['subTotal'] = this.subTotal
    data['vatTotal'] = this.vatTotal
    data['total'] = this.total
    if (
      this.proformaInvoiceLineItems &&
      this.proformaInvoiceLineItems.constructor === Array
    ) {
      data['proformaInvoiceLineItems'] = []
      for (let item of this.proformaInvoiceLineItems)
        data['proformaInvoiceLineItems'].push(item.toJSON())
    }
    data['customer'] = this.customer ? this.customer.toJSON() : <any>undefined
    data['customerId'] = this.customerId
    data['isSubmitted'] = this.isSubmitted
    data['status'] = this.status
    data['remarks'] = this.remarks
    data['isEmailSend'] = this.isEmailSend
    data['emailSendDate'] = this.emailSendDate
      ? this.emailSendDate.toISOString()
      : <any>undefined
    data['invoiceId'] = this.invoiceId
    data['proformaDisplyNumber'] = this.proformaDisplyNumber
    return data
  }
}

export interface IProFormaInvoice {
  id: string
  proFormaInvoiceNumber: number
  isProformal: boolean
  date: Date
  referenceNumber: number
  subTotal: number
  vatTotal: number
  total: number
  proformaInvoiceLineItems?: ProformaInvoiceLineItem[]
  customer?: Customer
  customerId: string
  isSubmitted: boolean
  status?: string
  remarks?: string
  isEmailSend: boolean
  emailSendDate: Date
  invoiceId?: string
  proformaDisplyNumber?: string
}

export class ProformaInvoiceLineItem implements IProformaInvoiceLineItem {
  id: string
  proFormaInvoice?: ProFormaInvoice
  proformaInvoiceId: string
  product?: Product
  productId: string
  unitPrice: number
  quantity: number
  amount: number

  constructor(data?: IProformaInvoiceLineItem) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.id = data['id']
      this.proFormaInvoice = data['proFormaInvoice']
        ? ProFormaInvoice.fromJS(data['proFormaInvoice'])
        : <any>undefined
      this.proformaInvoiceId = data['proformaInvoiceId']
      this.product = data['product']
        ? Product.fromJS(data['product'])
        : <any>undefined
      this.productId = data['productId']
      this.unitPrice = data['unitPrice']
      this.quantity = data['quantity']
      this.amount = data['amount']
    }
  }

  static fromJS(data: any): ProformaInvoiceLineItem {
    data = typeof data === 'object' ? data : {}
    let result = new ProformaInvoiceLineItem()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['id'] = this.id
    data['proFormaInvoice'] = this.proFormaInvoice
      ? this.proFormaInvoice.toJSON()
      : <any>undefined
    data['proformaInvoiceId'] = this.proformaInvoiceId
    data['product'] = this.product ? this.product.toJSON() : <any>undefined
    data['productId'] = this.productId
    data['unitPrice'] = this.unitPrice
    data['quantity'] = this.quantity
    data['amount'] = this.amount
    return data
  }
}

export interface IProformaInvoiceLineItem {
  id: string
  proFormaInvoice?: ProFormaInvoice
  proformaInvoiceId: string
  product?: Product
  productId: string
  unitPrice: number
  quantity: number
  amount: number
}

export class ProFormaInvoiceCrudResponses
  implements IProFormaInvoiceCrudResponses {
  message?: string
  id: string
  isSuccess: boolean

  constructor(data?: IProFormaInvoiceCrudResponses) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.message = data['message']
      this.id = data['id']
      this.isSuccess = data['isSuccess']
    }
  }

  static fromJS(data: any): ProFormaInvoiceCrudResponses {
    data = typeof data === 'object' ? data : {}
    let result = new ProFormaInvoiceCrudResponses()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['message'] = this.message
    data['id'] = this.id
    data['isSuccess'] = this.isSuccess
    return data
  }
}

export interface IProFormaInvoiceCrudResponses {
  message?: string
  id: string
  isSuccess: boolean
}

export class ProFormaReport implements IProFormaReport {
  clientName?: string
  refrenceNumber?: string
  address?: string
  date?: string
  code?: string
  vatNumber?: string
  telePhoneNumber?: string
  email?: string
  comments?: string
  bankName?: string
  accountNumber?: string
  branchCode?: string
  idasCompanyAddress?: string
  proFormaInvoice?: ProFormaInvoice
  productDetail?: string
  productName?: string

  constructor(data?: IProFormaReport) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.clientName = data['clientName']
      this.refrenceNumber = data['refrenceNumber']
      this.address = data['address']
      this.date = data['date']
      this.code = data['code']
      this.vatNumber = data['vatNumber']
      this.telePhoneNumber = data['telePhoneNumber']
      this.email = data['email']
      this.comments = data['comments']
      this.bankName = data['bankName']
      this.accountNumber = data['accountNumber']
      this.branchCode = data['branchCode']
      this.idasCompanyAddress = data['idasCompanyAddress']
      this.proFormaInvoice = data['proFormaInvoice']
        ? ProFormaInvoice.fromJS(data['proFormaInvoice'])
        : <any>undefined
      this.productDetail = data['productDetail']
      this.productName = data['productName']
    }
  }

  static fromJS(data: any): ProFormaReport {
    data = typeof data === 'object' ? data : {}
    let result = new ProFormaReport()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['clientName'] = this.clientName
    data['refrenceNumber'] = this.refrenceNumber
    data['address'] = this.address
    data['date'] = this.date
    data['code'] = this.code
    data['vatNumber'] = this.vatNumber
    data['telePhoneNumber'] = this.telePhoneNumber
    data['email'] = this.email
    data['comments'] = this.comments
    data['bankName'] = this.bankName
    data['accountNumber'] = this.accountNumber
    data['branchCode'] = this.branchCode
    data['idasCompanyAddress'] = this.idasCompanyAddress
    data['proFormaInvoice'] = this.proFormaInvoice
      ? this.proFormaInvoice.toJSON()
      : <any>undefined
    data['productDetail'] = this.productDetail
    data['productName'] = this.productName
    return data
  }
}

export interface IProFormaReport {
  clientName?: string
  refrenceNumber?: string
  address?: string
  date?: string
  code?: string
  vatNumber?: string
  telePhoneNumber?: string
  email?: string
  comments?: string
  bankName?: string
  accountNumber?: string
  branchCode?: string
  idasCompanyAddress?: string
  proFormaInvoice?: ProFormaInvoice
  productDetail?: string
  productName?: string
}

export class ProFormaInvoiceBulkEmail implements IProFormaInvoiceBulkEmail {
  clientName?: string
  refrenceNumber?: string
  proNumber: number
  address?: string
  date?: string
  code?: string
  vatNumber?: string
  telePhoneNumber?: string
  email?: string
  comments?: string
  bankName?: string
  accountNumber?: string
  branchCode?: string
  idasCompanyAddress?: string
  proformaInvoicevalue: number
  isSelected: boolean
  proFormaInvoice?: ProFormaInvoice

  constructor(data?: IProFormaInvoiceBulkEmail) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.clientName = data['clientName']
      this.refrenceNumber = data['refrenceNumber']
      this.proNumber = data['proNumber']
      this.address = data['address']
      this.date = data['date']
      this.code = data['code']
      this.vatNumber = data['vatNumber']
      this.telePhoneNumber = data['telePhoneNumber']
      this.email = data['email']
      this.comments = data['comments']
      this.bankName = data['bankName']
      this.accountNumber = data['accountNumber']
      this.branchCode = data['branchCode']
      this.idasCompanyAddress = data['idasCompanyAddress']
      this.proformaInvoicevalue = data['proformaInvoicevalue']
      this.isSelected = data['isSelected']
      this.proFormaInvoice = data['proFormaInvoice']
        ? ProFormaInvoice.fromJS(data['proFormaInvoice'])
        : <any>undefined
    }
  }

  static fromJS(data: any): ProFormaInvoiceBulkEmail {
    data = typeof data === 'object' ? data : {}
    let result = new ProFormaInvoiceBulkEmail()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['clientName'] = this.clientName
    data['refrenceNumber'] = this.refrenceNumber
    data['proNumber'] = this.proNumber
    data['address'] = this.address
    data['date'] = this.date
    data['code'] = this.code
    data['vatNumber'] = this.vatNumber
    data['telePhoneNumber'] = this.telePhoneNumber
    data['email'] = this.email
    data['comments'] = this.comments
    data['bankName'] = this.bankName
    data['accountNumber'] = this.accountNumber
    data['branchCode'] = this.branchCode
    data['idasCompanyAddress'] = this.idasCompanyAddress
    data['proformaInvoicevalue'] = this.proformaInvoicevalue
    data['isSelected'] = this.isSelected
    data['proFormaInvoice'] = this.proFormaInvoice
      ? this.proFormaInvoice.toJSON()
      : <any>undefined
    return data
  }
}

export interface IProFormaInvoiceBulkEmail {
  clientName?: string
  refrenceNumber?: string
  proNumber: number
  address?: string
  date?: string
  code?: string
  vatNumber?: string
  telePhoneNumber?: string
  email?: string
  comments?: string
  bankName?: string
  accountNumber?: string
  branchCode?: string
  idasCompanyAddress?: string
  proformaInvoicevalue: number
  isSelected: boolean
  proFormaInvoice?: ProFormaInvoice
}

export class ProductVmodel implements IProductVmodel {
  id: string
  name?: string
  packageRates?: ProductPackageRateVm[]
  service?: Service
  serviceId: string
  usageType?: string

  constructor(data?: IProductVmodel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.id = data['id']
      this.name = data['name']
      if (data['packageRates'] && data['packageRates'].constructor === Array) {
        this.packageRates = []
        for (let item of data['packageRates'])
          this.packageRates.push(ProductPackageRateVm.fromJS(item))
      }
      this.service = data['service']
        ? Service.fromJS(data['service'])
        : <any>undefined
      this.serviceId = data['serviceId']
      this.usageType = data['usageType']
    }
  }

  static fromJS(data: any): ProductVmodel {
    data = typeof data === 'object' ? data : {}
    let result = new ProductVmodel()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['id'] = this.id
    data['name'] = this.name
    if (this.packageRates && this.packageRates.constructor === Array) {
      data['packageRates'] = []
      for (let item of this.packageRates)
        data['packageRates'].push(item.toJSON())
    }
    data['service'] = this.service ? this.service.toJSON() : <any>undefined
    data['serviceId'] = this.serviceId
    data['usageType'] = this.usageType
    return data
  }
}

export interface IProductVmodel {
  id: string
  name?: string
  packageRates?: ProductPackageRateVm[]
  service?: Service
  serviceId: string
  usageType?: string
}

export class LoginRequest implements ILoginRequest {
  userName?: string
  password?: string

  constructor(data?: ILoginRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.userName = data['userName']
      this.password = data['password']
    }
  }

  static fromJS(data: any): LoginRequest {
    data = typeof data === 'object' ? data : {}
    let result = new LoginRequest()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['userName'] = this.userName
    data['password'] = this.password
    return data
  }
}

export interface ILoginRequest {
  userName?: string
  password?: string
}

export class LoginReponse implements ILoginReponse {
  fullName?: string
  userid: string
  isSucsess: boolean
  errorMessage?: string
  token?: string

  constructor(data?: ILoginReponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.fullName = data['fullName']
      this.userid = data['userid']
      this.isSucsess = data['isSucsess']
      this.errorMessage = data['errorMessage']
      this.token = data['token']
    }
  }

  static fromJS(data: any): LoginReponse {
    data = typeof data === 'object' ? data : {}
    let result = new LoginReponse()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['fullName'] = this.fullName
    data['userid'] = this.userid
    data['isSucsess'] = this.isSucsess
    data['errorMessage'] = this.errorMessage
    data['token'] = this.token
    return data
  }
}

export interface ILoginReponse {
  fullName?: string
  userid: string
  isSucsess: boolean
  errorMessage?: string
  token?: string
}

export class SearchCustomerRequest implements ISearchCustomerRequest {
  customerName?: string
  customerCode?: string
  registrationNumber?: string

  constructor(data?: ISearchCustomerRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.customerName = data['customerName']
      this.customerCode = data['customerCode']
      this.registrationNumber = data['registrationNumber']
    }
  }

  static fromJS(data: any): SearchCustomerRequest {
    data = typeof data === 'object' ? data : {}
    let result = new SearchCustomerRequest()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['customerName'] = this.customerName
    data['customerCode'] = this.customerCode
    data['registrationNumber'] = this.registrationNumber
    return data
  }
}

export interface ISearchCustomerRequest {
  customerName?: string
  customerCode?: string
  registrationNumber?: string
}

export class SearchCustomerResponse implements ISearchCustomerResponse {
  customerId: string
  customerName?: string
  customerCode?: string
  registerNumber?: string
  isChecked: boolean
  message?: string

  constructor(data?: ISearchCustomerResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.customerId = data['customerId']
      this.customerName = data['customerName']
      this.customerCode = data['customerCode']
      this.registerNumber = data['registerNumber']
      this.isChecked = data['isChecked']
      this.message = data['message']
    }
  }

  static fromJS(data: any): SearchCustomerResponse {
    data = typeof data === 'object' ? data : {}
    let result = new SearchCustomerResponse()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['customerId'] = this.customerId
    data['customerName'] = this.customerName
    data['customerCode'] = this.customerCode
    data['registerNumber'] = this.registerNumber
    data['isChecked'] = this.isChecked
    data['message'] = this.message
    return data
  }
}

export interface ISearchCustomerResponse {
  customerId: string
  customerName?: string
  customerCode?: string
  registerNumber?: string
  isChecked: boolean
  message?: string
}

export interface FileResponse {
  data: Blob
  status: number
  fileName?: string
  headers?: { [name: string]: any }
}

export class SwaggerException extends Error {
  message: string
  status: number
  response: string
  headers: { [key: string]: any }
  result: any

  constructor(
    message: string,
    status: number,
    response: string,
    headers: { [key: string]: any },
    result: any,
  ) {
    super()

    this.message = message
    this.status = status
    this.response = response
    this.headers = headers
    this.result = result
  }

  protected isSwaggerException = true

  static isSwaggerException(obj: any): obj is SwaggerException {
    return obj.isSwaggerException === true
  }
}

function throwException(
  message: string,
  status: number,
  response: string,
  headers: { [key: string]: any },
  result?: any,
): Observable<any> {
  if (result !== null && result !== undefined) return Observable.throw(result)
  else
    return Observable.throw(
      new SwaggerException(message, status, response, headers, null),
    )
}

function blobToText(blob: any): Observable<string> {
  return new Observable<string>((observer: any) => {
    if (!blob) {
      observer.next('')
      observer.complete()
    } else {
      let reader = new FileReader()
      reader.onload = function () {
        observer.next(this.result)
        observer.complete()
      }
      reader.readAsText(blob)
    }
  })
}
