{"remainingRequest":"D:\\Projects\\IDAS_TFS\\Inspirit.IDAS\\Inspirit.IDAS.Admin\\ClientApp\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js??ref--3-1!D:\\Projects\\IDAS_TFS\\Inspirit.IDAS\\Inspirit.IDAS.Admin\\ClientApp\\node_modules\\@syncfusion\\ej2-data\\src\\adaptors.js","dependencies":[{"path":"D:\\Projects\\IDAS_TFS\\Inspirit.IDAS\\Inspirit.IDAS.Admin\\ClientApp\\node_modules\\@syncfusion\\ej2-data\\src\\adaptors.js","mtime":499162500000},{"path":"D:\\Projects\\IDAS_TFS\\Inspirit.IDAS\\Inspirit.IDAS.Admin\\ClientApp\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1510929699000},{"path":"D:\\Projects\\IDAS_TFS\\Inspirit.IDAS\\Inspirit.IDAS.Admin\\ClientApp\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js","mtime":1518048966000}],"contextDependencies":[],"result":["import { __extends } from \"tslib\";\r\nimport { merge, extend, isNullOrUndefined, setValue } from '@syncfusion/ej2-base';\r\nimport { DataUtil } from './util';\r\nimport { Query, Predicate } from './query';\r\n/**\r\n * Adaptors are specific data source type aware interfaces that are used by DataManager to communicate with DataSource.\r\n * This is the base adaptor class that other adaptors can extend.\r\n * @hidden\r\n */\r\nvar Adaptor = /*@__PURE__*/ (function () {\r\n    /**\r\n     * Constructor for Adaptor class\r\n     * @param  {DataOptions} ds?\r\n     * @hidden\r\n     * @returns aggregates\r\n     */\r\n    function Adaptor(ds) {\r\n        // common options for all the adaptors \r\n        this.options = {\r\n            from: 'table',\r\n            requestType: 'json',\r\n            sortBy: 'sorted',\r\n            select: 'select',\r\n            skip: 'skip',\r\n            group: 'group',\r\n            take: 'take',\r\n            search: 'search',\r\n            count: 'requiresCounts',\r\n            where: 'where',\r\n            aggregates: 'aggregates'\r\n        };\r\n        /**\r\n         * Specifies the type of adaptor.\r\n         * @default Adaptor\r\n         */\r\n        this.type = Adaptor;\r\n        this.dataSource = ds;\r\n        this.pvt = {};\r\n    }\r\n    /**\r\n     * Returns the data from the query processing.\r\n     * @param  {Object} data\r\n     * @param  {DataOptions} ds?\r\n     * @param  {Query} query?\r\n     * @param  {XMLHttpRequest} xhr?\r\n     * @returns Object\r\n     */\r\n    Adaptor.prototype.processResponse = function (data, ds, query, xhr) {\r\n        return data;\r\n    };\r\n    return Adaptor;\r\n}());\r\nexport { Adaptor };\r\n/**\r\n * JsonAdaptor is used to process JSON data. It contains methods to process the given JSON data based on the queries.\r\n * @hidden\r\n */\r\nvar JsonAdaptor = /*@__PURE__*/ (function (_super) {\r\n    __extends(JsonAdaptor, _super);\r\n    function JsonAdaptor() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    /**\r\n     * Process the JSON data based on the provided queries.\r\n     * @param  {DataManager} dataManager\r\n     * @param  {Query} query\r\n     * @returns Object\r\n     */\r\n    JsonAdaptor.prototype.processQuery = function (dataManager, query) {\r\n        var result = dataManager.dataSource.json.slice(0);\r\n        var count = result.length;\r\n        var countFlg = true;\r\n        var ret;\r\n        var key;\r\n        var agg = {};\r\n        for (var i = 0; i < query.queries.length; i++) {\r\n            key = query.queries[i];\r\n            ret = this[key.fn].call(this, result, key.e, query);\r\n            if (key.fn === 'onAggregates') {\r\n                agg[key.e.field + ' - ' + key.e.type] = ret;\r\n            }\r\n            else {\r\n                result = ret !== undefined ? ret : result;\r\n            }\r\n            if (key.fn === 'onPage' || key.fn === 'onSkip' || key.fn === 'onTake' || key.fn === 'onRange') {\r\n                countFlg = false;\r\n            }\r\n            if (countFlg) {\r\n                count = result.length;\r\n            }\r\n        }\r\n        if (query.isCountRequired) {\r\n            result = {\r\n                result: result,\r\n                count: count,\r\n                aggregates: agg\r\n            };\r\n        }\r\n        return result;\r\n    };\r\n    /**\r\n     * Performs batch update in the JSON array which add, remove and update records.\r\n     * @param  {DataManager} dm\r\n     * @param  {CrudOptions} changes\r\n     * @param  {RemoteArgs} e\r\n     */\r\n    JsonAdaptor.prototype.batchRequest = function (dm, changes, e) {\r\n        var i;\r\n        var deletedRecordsLen = changes.deletedRecords.length;\r\n        for (i = 0; i < changes.addedRecords.length; i++) {\r\n            this.insert(dm, changes.addedRecords[i]);\r\n        }\r\n        for (i = 0; i < changes.changedRecords.length; i++) {\r\n            this.update(dm, e.key, changes.changedRecords[i]);\r\n        }\r\n        for (i = 0; i < deletedRecordsLen; i++) {\r\n            this.remove(dm, e.key, changes.deletedRecords[i]);\r\n        }\r\n        return changes;\r\n    };\r\n    /**\r\n     * Performs filter operation with the given data and where query.\r\n     * @param  {Object[]} ds\r\n     * @param  {{validate:Function}} e\r\n     */\r\n    JsonAdaptor.prototype.onWhere = function (ds, e) {\r\n        if (!ds || !ds.length) {\r\n            return ds;\r\n        }\r\n        return ds.filter(function (obj) {\r\n            if (e) {\r\n                return e.validate(obj);\r\n            }\r\n        });\r\n    };\r\n    /**\r\n     * Returns aggregate function based on the aggregate type.\r\n     * @param  {Object[]} ds\r\n     * @param  {{field:string} e\r\n     * @param  {string}} type\r\n     */\r\n    JsonAdaptor.prototype.onAggregates = function (ds, e) {\r\n        var fn = DataUtil.aggregates[e.type];\r\n        if (!ds || !fn || ds.length === 0) {\r\n            return null;\r\n        }\r\n        return fn(ds, e.field);\r\n    };\r\n    /**\r\n     * Performs search operation based on the given query.\r\n     * @param  {Object[]} ds\r\n     * @param  {QueryOptions} e\r\n     */\r\n    JsonAdaptor.prototype.onSearch = function (ds, e) {\r\n        if (!ds || !ds.length) {\r\n            return ds;\r\n        }\r\n        if (e.fieldNames.length === 0) {\r\n            DataUtil.getFieldList(ds[0], e.fieldNames);\r\n        }\r\n        return ds.filter(function (obj) {\r\n            for (var j = 0; j < e.fieldNames.length; j++) {\r\n                if (e.comparer.call(obj, DataUtil.getObject(e.fieldNames[j], obj), e.searchKey, e.ignoreCase, e.ignoreAccent)) {\r\n                    return true;\r\n                }\r\n            }\r\n            return false;\r\n        });\r\n    };\r\n    /**\r\n     * Sort the data with given direction and field.\r\n     * @param  {Object[]} ds\r\n     * @param  {{comparer:(a:Object} e\r\n     * @param  {Object} b\r\n     */\r\n    JsonAdaptor.prototype.onSortBy = function (ds, e, query) {\r\n        if (!ds || !ds.length) {\r\n            return ds;\r\n        }\r\n        var fnCompare;\r\n        var field = DataUtil.getValue(e.fieldName, query);\r\n        if (!field) {\r\n            return ds.sort(e.comparer);\r\n        }\r\n        if (field instanceof Array) {\r\n            field = field.slice(0);\r\n            for (var i = field.length - 1; i >= 0; i--) {\r\n                if (!field[i]) {\r\n                    continue;\r\n                }\r\n                fnCompare = e.comparer;\r\n                if (DataUtil.endsWith(field[i], ' desc')) {\r\n                    fnCompare = DataUtil.fnSort('descending');\r\n                    field[i] = field[i].replace(' desc', '');\r\n                }\r\n                ds = DataUtil.sort(ds, field[i], fnCompare);\r\n            }\r\n            return ds;\r\n        }\r\n        return DataUtil.sort(ds, field, e.comparer);\r\n    };\r\n    /**\r\n     * Group the data based on the given query.\r\n     * @param  {Object[]} ds\r\n     * @param  {QueryOptions} e\r\n     * @param  {Query} query\r\n     */\r\n    JsonAdaptor.prototype.onGroup = function (ds, e, query) {\r\n        if (!ds || !ds.length) {\r\n            return ds;\r\n        }\r\n        var aggQuery = Query.filterQueries(query.queries, 'onAggregates');\r\n        var agg = [];\r\n        if (aggQuery.length) {\r\n            var tmp = void 0;\r\n            for (var i = 0; i < aggQuery.length; i++) {\r\n                tmp = aggQuery[i].e;\r\n                agg.push({ type: tmp.type, field: DataUtil.getValue(tmp.field, query) });\r\n            }\r\n        }\r\n        return DataUtil.group(ds, DataUtil.getValue(e.fieldName, query), agg, null, null, e.comparer);\r\n    };\r\n    /**\r\n     * Retrieves records based on the given page index and size.\r\n     * @param  {Object[]} ds\r\n     * @param  {{pageSize:number} e\r\n     * @param  {number}} pageIndex\r\n     * @param  {Query} query\r\n     */\r\n    JsonAdaptor.prototype.onPage = function (ds, e, query) {\r\n        var size = DataUtil.getValue(e.pageSize, query);\r\n        var start = (DataUtil.getValue(e.pageIndex, query) - 1) * size;\r\n        var end = start + size;\r\n        if (!ds || !ds.length) {\r\n            return ds;\r\n        }\r\n        return ds.slice(start, end);\r\n    };\r\n    /**\r\n     * Retrieves records based on the given start and end index from query.\r\n     * @param  {Object[]} ds\r\n     * @param  {{start:number} e\r\n     * @param  {number}} end\r\n     */\r\n    JsonAdaptor.prototype.onRange = function (ds, e) {\r\n        if (!ds || !ds.length) {\r\n            return ds;\r\n        }\r\n        return ds.slice(DataUtil.getValue(e.start), DataUtil.getValue(e.end));\r\n    };\r\n    /**\r\n     * Picks the given count of records from the top of the datasource.\r\n     * @param  {Object[]} ds\r\n     * @param  {{nos:number}} e\r\n     */\r\n    JsonAdaptor.prototype.onTake = function (ds, e) {\r\n        if (!ds || !ds.length) {\r\n            return ds;\r\n        }\r\n        return ds.slice(0, DataUtil.getValue(e.nos));\r\n    };\r\n    /**\r\n     * Skips the given count of records from the data source.\r\n     * @param  {Object[]} ds\r\n     * @param  {{nos:number}} e\r\n     */\r\n    JsonAdaptor.prototype.onSkip = function (ds, e) {\r\n        if (!ds || !ds.length) {\r\n            return ds;\r\n        }\r\n        return ds.slice(DataUtil.getValue(e.nos));\r\n    };\r\n    /**\r\n     * Selects specified columns from the data source.\r\n     * @param  {Object[]} ds\r\n     * @param  {{fieldNames:string}} e\r\n     */\r\n    JsonAdaptor.prototype.onSelect = function (ds, e) {\r\n        if (!ds || !ds.length) {\r\n            return ds;\r\n        }\r\n        return DataUtil.select(ds, DataUtil.getValue(e.fieldNames));\r\n    };\r\n    /**\r\n     * Inserts new record in the table.\r\n     * @param  {DataManager} dm\r\n     * @param  {Object} data\r\n     * @param  {number} position\r\n     */\r\n    JsonAdaptor.prototype.insert = function (dm, data, tableName, query, position) {\r\n        if (isNullOrUndefined(position)) {\r\n            return dm.dataSource.json.push(data);\r\n        }\r\n        else {\r\n            return dm.dataSource.json.splice(position, 0, data);\r\n        }\r\n    };\r\n    /**\r\n     * Remove the data from the dataSource based on the key field value.\r\n     * @param  {DataManager} dm\r\n     * @param  {string} keyField\r\n     * @param  {Object} value\r\n     * @param  {string} tableName?\r\n     * @returns null\r\n     */\r\n    JsonAdaptor.prototype.remove = function (dm, keyField, value, tableName) {\r\n        var ds = dm.dataSource.json;\r\n        var i;\r\n        if (typeof value === 'object') {\r\n            value = value[keyField];\r\n        }\r\n        for (i = 0; i < ds.length; i++) {\r\n            if (ds[i][keyField] === value) {\r\n                break;\r\n            }\r\n        }\r\n        return i !== ds.length ? ds.splice(i, 1) : null;\r\n    };\r\n    /**\r\n     * Updates existing record and saves the changes to the table.\r\n     * @param  {DataManager} dm\r\n     * @param  {string} keyField\r\n     * @param  {Object} value\r\n     * @param  {string} tableName?\r\n     * @returns null\r\n     */\r\n    JsonAdaptor.prototype.update = function (dm, keyField, value, tableName) {\r\n        var ds = dm.dataSource.json;\r\n        var i;\r\n        var key = value[keyField];\r\n        for (i = 0; i < ds.length; i++) {\r\n            if (ds[i][keyField] === key) {\r\n                break;\r\n            }\r\n        }\r\n        return i < ds.length ? merge(ds[i], value) : null;\r\n    };\r\n    return JsonAdaptor;\r\n}(Adaptor));\r\nexport { JsonAdaptor };\r\n/**\r\n * URL Adaptor of DataManager can be used when you are required to use remote service to retrieve data.\r\n * It interacts with server-side for all DataManager Queries and CRUD operations.\r\n * @hidden\r\n */\r\nvar UrlAdaptor = /*@__PURE__*/ (function (_super) {\r\n    __extends(UrlAdaptor, _super);\r\n    function UrlAdaptor() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    /**\r\n     * Process the query to generate request body.\r\n     * @param  {DataManager} dm\r\n     * @param  {Query} query\r\n     * @param  {Object[]} hierarchyFilters?\r\n     * @returns p\r\n     */\r\n    UrlAdaptor.prototype.processQuery = function (dm, query, hierarchyFilters) {\r\n        var queries = this.getQueryRequest(query);\r\n        var singles = Query.filterQueryLists(query.queries, ['onSelect', 'onPage', 'onSkip', 'onTake', 'onRange']);\r\n        var params = query.params;\r\n        var url = dm.dataSource.url;\r\n        var temp;\r\n        var skip;\r\n        var take = null;\r\n        var options = this.options;\r\n        var request = { sorts: [], groups: [], filters: [], searches: [], aggregates: [] };\r\n        // calc Paging & Range\r\n        if ('onPage' in singles) {\r\n            temp = singles.onPage;\r\n            skip = DataUtil.getValue(temp.pageIndex, query);\r\n            take = DataUtil.getValue(temp.pageSize, query);\r\n            skip = (skip - 1) * take;\r\n        }\r\n        else if ('onRange' in singles) {\r\n            temp = singles.onRange;\r\n            skip = temp.start;\r\n            take = temp.end - temp.start;\r\n        }\r\n        // Sorting\r\n        for (var i = 0; i < queries.sorts.length; i++) {\r\n            temp = DataUtil.getValue(queries.sorts[i].e.fieldName, query);\r\n            request.sorts.push(DataUtil.callAdaptorFunction(this, 'onEachSort', { name: temp, direction: queries.sorts[i].e.direction }, query));\r\n        }\r\n        // hierarchy\r\n        if (hierarchyFilters) {\r\n            temp = this.getFiltersFrom(hierarchyFilters, query);\r\n            if (temp) {\r\n                request.filters.push(DataUtil.callAdaptorFunction(this, 'onEachWhere', temp.toJson(), query));\r\n            }\r\n        }\r\n        // Filters\r\n        for (var i = 0; i < queries.filters.length; i++) {\r\n            request.filters.push(DataUtil.callAdaptorFunction(this, 'onEachWhere', queries.filters[i].e.toJson(), query));\r\n            var keys_3 = typeof request.filters[i] === 'object' ? Object.keys(request.filters[i]) : [];\r\n            for (var _i = 0, keys_1 = keys_3; _i < keys_1.length; _i++) {\r\n                var prop = keys_1[_i];\r\n                if (DataUtil.isNull((request)[prop])) {\r\n                    delete request[prop];\r\n                }\r\n            }\r\n        }\r\n        // Searches\r\n        for (var i = 0; i < queries.searches.length; i++) {\r\n            temp = queries.searches[i].e;\r\n            request.searches.push(DataUtil.callAdaptorFunction(this, 'onEachSearch', {\r\n                fields: temp.fieldNames,\r\n                operator: temp.operator,\r\n                key: temp.searchKey,\r\n                ignoreCase: temp.ignoreCase\r\n            }, query));\r\n        }\r\n        // Grouping\r\n        for (var i = 0; i < queries.groups.length; i++) {\r\n            request.groups.push(DataUtil.getValue(queries.groups[i].e.fieldName, query));\r\n        }\r\n        // aggregates\r\n        for (var i = 0; i < queries.aggregates.length; i++) {\r\n            temp = queries.aggregates[i].e;\r\n            request.aggregates.push({ type: temp.type, field: DataUtil.getValue(temp.field, query) });\r\n        }\r\n        var req = {};\r\n        this.getRequestQuery(options, query, singles, request, req);\r\n        // Params\r\n        DataUtil.callAdaptorFunction(this, 'addParams', { dm: dm, query: query, params: params, reqParams: req });\r\n        // cleanup\r\n        var keys = Object.keys(req);\r\n        for (var _a = 0, keys_2 = keys; _a < keys_2.length; _a++) {\r\n            var prop = keys_2[_a];\r\n            if (DataUtil.isNull(req[prop]) || req[prop] === '' || req[prop].length === 0) {\r\n                delete req[prop];\r\n            }\r\n        }\r\n        if (!(options.skip in req && options.take in req) && take !== null) {\r\n            req[options.skip] = DataUtil.callAdaptorFunction(this, 'onSkip', skip, query);\r\n            req[options.take] = DataUtil.callAdaptorFunction(this, 'onTake', take, query);\r\n        }\r\n        var p = this.pvt;\r\n        this.pvt = {};\r\n        if (this.options.requestType === 'json') {\r\n            return {\r\n                data: JSON.stringify(req),\r\n                url: url,\r\n                pvtData: p,\r\n                type: 'POST',\r\n                contentType: 'application/json; charset=utf-8'\r\n            };\r\n        }\r\n        temp = this.convertToQueryString(req, query, dm);\r\n        temp = (dm.dataSource.url.indexOf('?') !== -1 ? '&' : '/') + temp;\r\n        return {\r\n            type: 'GET', url: temp.length ? url.replace(/\\/*$/, temp) : url, pvtData: p\r\n        };\r\n    };\r\n    UrlAdaptor.prototype.getRequestQuery = function (options, query, singles, request, request1) {\r\n        var param = 'param';\r\n        var req = request1;\r\n        req[options.from] = query.fromTable;\r\n        if (options.apply && query.distincts.length) {\r\n            req[options.apply] = 'onDistinct' in this ? DataUtil.callAdaptorFunction(this, 'onDistinct', query.distincts) : '';\r\n        }\r\n        if (!query.distincts.length && options.expand) {\r\n            req[options.expand] = 'onExpand' in this && 'onSelect' in singles ?\r\n                DataUtil.callAdaptorFunction(this, 'onExpand', { selects: DataUtil.getValue(singles.onSelect.fieldNames, query), expands: query.expands }, query) : query.expands;\r\n        }\r\n        req[options.select] = 'onSelect' in singles && !query.distincts.length ?\r\n            DataUtil.callAdaptorFunction(this, 'onSelect', DataUtil.getValue(singles.onSelect.fieldNames, query), query) : '';\r\n        req[options.count] = query.isCountRequired ? DataUtil.callAdaptorFunction(this, 'onCount', query.isCountRequired, query) : '';\r\n        req[options.search] = request.searches.length ? DataUtil.callAdaptorFunction(this, 'onSearch', request.searches, query) : '';\r\n        req[options.skip] = 'onSkip' in singles ?\r\n            DataUtil.callAdaptorFunction(this, 'onSkip', DataUtil.getValue(singles.onSkip.nos, query), query) : '';\r\n        req[options.take] = 'onTake' in singles ?\r\n            DataUtil.callAdaptorFunction(this, 'onTake', DataUtil.getValue(singles.onTake.nos, query), query) : '';\r\n        req[options.where] = request.filters.length || request.searches.length ?\r\n            DataUtil.callAdaptorFunction(this, 'onWhere', request.filters, query) : '';\r\n        req[options.sortBy] = request.sorts.length ? DataUtil.callAdaptorFunction(this, 'onSortBy', request.sorts, query) : '';\r\n        req[options.group] = request.groups.length ? DataUtil.callAdaptorFunction(this, 'onGroup', request.groups, query) : '';\r\n        req[options.aggregates] = request.aggregates.length ?\r\n            DataUtil.callAdaptorFunction(this, 'onAggregates', request.aggregates, query) : '';\r\n        req[param] = [];\r\n    };\r\n    /**\r\n     * Convert the object from processQuery to string which can be added query string.\r\n     * @param  {Object} req\r\n     * @param  {Query} query\r\n     * @param  {DataManager} dm\r\n     */\r\n    UrlAdaptor.prototype.convertToQueryString = function (request, query, dm) {\r\n        return '';\r\n        // this needs to be overridden\r\n    };\r\n    /**\r\n     * Return the data from the data manager processing.\r\n     * @param  {DataResult} data\r\n     * @param  {DataOptions} ds?\r\n     * @param  {Query} query?\r\n     * @param  {XMLHttpRequest} xhr?\r\n     * @param  {Object} request?\r\n     * @param  {CrudOptions} changes?\r\n     */\r\n    UrlAdaptor.prototype.processResponse = function (data, ds, query, xhr, request, changes) {\r\n        if (xhr && xhr.getResponseHeader('Content-Type') &&\r\n            xhr.getResponseHeader('Content-Type').indexOf('application/json') !== -1) {\r\n            data = DataUtil.parse.parseJson(data);\r\n        }\r\n        var requests = request;\r\n        var pvt = requests.pvtData || {};\r\n        var groupDs = data ? data.groupDs : [];\r\n        if (xhr && xhr.getResponseHeader('Content-Type') &&\r\n            xhr.getResponseHeader('Content-Type').indexOf('xml') !== -1) {\r\n            return (query.isCountRequired ? { result: [], count: 0 } : []);\r\n        }\r\n        var d = JSON.parse(requests.data);\r\n        if (d && d.action === 'batch' && data && data.addedRecords) {\r\n            changes.addedRecords = data.addedRecords;\r\n            return changes;\r\n        }\r\n        if (data && data.d) {\r\n            data = data.d;\r\n        }\r\n        var args = {};\r\n        if (data && 'count' in data) {\r\n            args.count = data.count;\r\n        }\r\n        args.result = data && data.result ? data.result : data;\r\n        this.getAggregateResult(pvt, data, args, groupDs, query);\r\n        return DataUtil.isNull(args.count) ? args.result : { result: args.result, count: args.count, aggregates: args.aggregates };\r\n    };\r\n    /**\r\n     * Add the group query to the adaptor`s option.\r\n     * @param  {Object[]} e\r\n     * @returns void\r\n     */\r\n    UrlAdaptor.prototype.onGroup = function (e) {\r\n        this.pvt.groups = e;\r\n        return e;\r\n    };\r\n    /**\r\n     * Add the aggregate query to the adaptor`s option.\r\n     * @param  {Aggregates[]} e\r\n     * @returns void\r\n     */\r\n    UrlAdaptor.prototype.onAggregates = function (e) {\r\n        this.pvt.aggregates = e;\r\n    };\r\n    /**\r\n     * Prepare the request body based on the newly added, removed and updated records.\r\n     * The result is used by the batch request.\r\n     * @param  {DataManager} dm\r\n     * @param  {CrudOptions} changes\r\n     * @param  {Object} e\r\n     */\r\n    UrlAdaptor.prototype.batchRequest = function (dm, changes, e, query, original) {\r\n        var url;\r\n        var key;\r\n        return {\r\n            type: 'POST',\r\n            url: dm.dataSource.batchUrl || dm.dataSource.crudUrl || dm.dataSource.removeUrl || dm.dataSource.url,\r\n            contentType: 'application/json; charset=utf-8',\r\n            dataType: 'json',\r\n            data: JSON.stringify(extend({}, {\r\n                changed: changes.changedRecords,\r\n                added: changes.addedRecords,\r\n                deleted: changes.deletedRecords,\r\n                action: 'batch',\r\n                table: e[url],\r\n                key: e[key]\r\n            }, DataUtil.getAddParams(this, dm, query)))\r\n        };\r\n    };\r\n    /**\r\n     * Method will trigger before send the request to server side.\r\n     * Used to set the custom header or modify the request options.\r\n     * @param  {DataManager} dm\r\n     * @param  {XMLHttpRequest} request\r\n     * @returns void\r\n     */\r\n    UrlAdaptor.prototype.beforeSend = function (dm, request) {\r\n        // need to extend this method\r\n    };\r\n    /**\r\n     * Prepare and returns request body which is used to insert a new record in the table.\r\n     * @param  {DataManager} dm\r\n     * @param  {Object} data\r\n     * @param  {string} tableName\r\n     */\r\n    UrlAdaptor.prototype.insert = function (dm, data, tableName, query) {\r\n        return {\r\n            url: dm.dataSource.insertUrl || dm.dataSource.crudUrl || dm.dataSource.url,\r\n            data: JSON.stringify(extend({}, {\r\n                value: data,\r\n                table: tableName,\r\n                action: 'insert'\r\n            }, DataUtil.getAddParams(this, dm, query)))\r\n        };\r\n    };\r\n    /**\r\n     * Prepare and return request body which is used to remove record from the table.\r\n     * @param  {DataManager} dm\r\n     * @param  {string} keyField\r\n     * @param  {number|string} value\r\n     * @param  {string} tableName\r\n     */\r\n    UrlAdaptor.prototype.remove = function (dm, keyField, value, tableName, query) {\r\n        return {\r\n            type: 'POST',\r\n            url: dm.dataSource.removeUrl || dm.dataSource.crudUrl || dm.dataSource.url,\r\n            data: JSON.stringify(extend({}, {\r\n                key: value,\r\n                keyColumn: keyField,\r\n                table: tableName,\r\n                action: 'remove'\r\n            }, DataUtil.getAddParams(this, dm, query)))\r\n        };\r\n    };\r\n    /**\r\n     * Prepare and return request body which is used to update record.\r\n     * @param  {DataManager} dm\r\n     * @param  {string} keyField\r\n     * @param  {Object} value\r\n     * @param  {string} tableName\r\n     */\r\n    UrlAdaptor.prototype.update = function (dm, keyField, value, tableName, query) {\r\n        return {\r\n            type: 'POST',\r\n            url: dm.dataSource.updateUrl || dm.dataSource.crudUrl || dm.dataSource.url,\r\n            data: JSON.stringify(extend({}, {\r\n                value: value,\r\n                action: 'update',\r\n                keyColumn: keyField,\r\n                key: value[keyField],\r\n                table: tableName\r\n            }, DataUtil.getAddParams(this, dm, query)))\r\n        };\r\n    };\r\n    /**\r\n     * To generate the predicate based on the filtered query.\r\n     * @param  {Object[]|string[]|number[]} data\r\n     * @param  {Query} query\r\n     * @hidden\r\n     */\r\n    UrlAdaptor.prototype.getFiltersFrom = function (data, query) {\r\n        var key = query.fKey;\r\n        var value;\r\n        var prop = key;\r\n        var pKey = query.key;\r\n        var predicats = [];\r\n        if (typeof data[0] !== 'object') {\r\n            prop = null;\r\n        }\r\n        for (var i = 0; i < data.length; i++) {\r\n            if (typeof data[0] === 'object') {\r\n                value = DataUtil.getObject(pKey || prop, data[i]);\r\n            }\r\n            else {\r\n                value = data[i];\r\n            }\r\n            predicats.push(new Predicate(key, 'equal', value));\r\n        }\r\n        return Predicate.or(predicats);\r\n    };\r\n    UrlAdaptor.prototype.getAggregateResult = function (pvt, data, args, groupDs, query) {\r\n        var pData = data;\r\n        if (data && data.result) {\r\n            pData = data.result;\r\n        }\r\n        if (pvt && pvt.aggregates && pvt.aggregates.length) {\r\n            var agg = pvt.aggregates;\r\n            var fn = void 0;\r\n            var aggregateData = pData;\r\n            var res = {};\r\n            if (data.aggregate) {\r\n                aggregateData = data.aggregate;\r\n            }\r\n            for (var i = 0; i < agg.length; i++) {\r\n                fn = DataUtil.aggregates[agg[i].type];\r\n                if (fn) {\r\n                    res[agg[i].field + ' - ' + agg[i].type] = fn(aggregateData, agg[i].field);\r\n                }\r\n            }\r\n            args.aggregates = res;\r\n        }\r\n        if (pvt && pvt.groups && pvt.groups.length) {\r\n            var groups = pvt.groups;\r\n            for (var i = 0; i < groups.length; i++) {\r\n                var level = null;\r\n                if (!isNullOrUndefined(groupDs)) {\r\n                    groupDs = DataUtil.group(groupDs, groups[i]);\r\n                }\r\n                var groupQuery = Query.filterQueries(query.queries, 'onGroup')[i].e;\r\n                pData = DataUtil.group(pData, groups[i], pvt.aggregates, level, groupDs, groupQuery.comparer);\r\n            }\r\n            args.result = pData;\r\n        }\r\n        return args;\r\n    };\r\n    UrlAdaptor.prototype.getQueryRequest = function (query) {\r\n        var req = { sorts: [], groups: [], filters: [], searches: [], aggregates: [] };\r\n        req.sorts = Query.filterQueries(query.queries, 'onSortBy');\r\n        req.groups = Query.filterQueries(query.queries, 'onGroup');\r\n        req.filters = Query.filterQueries(query.queries, 'onWhere');\r\n        req.searches = Query.filterQueries(query.queries, 'onSearch');\r\n        req.aggregates = Query.filterQueries(query.queries, 'onAggregates');\r\n        return req;\r\n    };\r\n    UrlAdaptor.prototype.addParams = function (options) {\r\n        var req = options.reqParams;\r\n        if (options.params.length) {\r\n            req.params = {};\r\n        }\r\n        for (var _i = 0, _a = options.params; _i < _a.length; _i++) {\r\n            var tmp = _a[_i];\r\n            if (req[tmp.key]) {\r\n                throw new Error('Query() - addParams: Custom Param is conflicting other request arguments');\r\n            }\r\n            req[tmp.key] = tmp.value;\r\n            if (tmp.fn) {\r\n                req[tmp.key] = tmp.fn.call(options.query, tmp.key, options.query, options.dm);\r\n            }\r\n            req.params[tmp.key] = req[tmp.key];\r\n        }\r\n    };\r\n    return UrlAdaptor;\r\n}(Adaptor));\r\nexport { UrlAdaptor };\r\n/**\r\n * OData Adaptor that is extended from URL Adaptor, is used for consuming data through OData Service.\r\n * @hidden\r\n */\r\nvar ODataAdaptor = /*@__PURE__*/ (function (_super) {\r\n    __extends(ODataAdaptor, _super);\r\n    function ODataAdaptor(props) {\r\n        var _this = _super.call(this) || this;\r\n        // options replaced the default adaptor options\r\n        _this.options = extend({}, _this.options, {\r\n            requestType: 'get',\r\n            accept: 'application/json;odata=light;q=1,application/json;odata=verbose;q=0.5',\r\n            multipartAccept: 'multipart/mixed',\r\n            sortBy: '$orderby',\r\n            select: '$select',\r\n            skip: '$skip',\r\n            take: '$top',\r\n            count: '$inlinecount',\r\n            where: '$filter',\r\n            expand: '$expand',\r\n            batch: '$batch',\r\n            changeSet: '--changeset_',\r\n            batchPre: 'batch_',\r\n            contentId: 'Content-Id: ',\r\n            batchContent: 'Content-Type: multipart/mixed; boundary=',\r\n            changeSetContent: 'Content-Type: application/http\\nContent-Transfer-Encoding: binary ',\r\n            batchChangeSetContentType: 'Content-Type: application/json; charset=utf-8 ',\r\n            updateType: 'PUT'\r\n        });\r\n        extend(_this.options, props || {});\r\n        return _this;\r\n    }\r\n    ODataAdaptor.prototype.getModuleName = function () {\r\n        return 'ODataAdaptor';\r\n    };\r\n    /**\r\n     * Generate request string based on the filter criteria from query.\r\n     * @param  {Predicate} pred\r\n     * @param  {boolean} requiresCast?\r\n     */\r\n    ODataAdaptor.prototype.onPredicate = function (predicate, query, requiresCast) {\r\n        var returnValue = '';\r\n        var operator;\r\n        var guid;\r\n        var val = predicate.value;\r\n        var type = typeof val;\r\n        var field = predicate.field ? ODataAdaptor.getField(predicate.field) : null;\r\n        if (val instanceof Date) {\r\n            val = 'datetime\\'' + DataUtil.parse.replacer(val) + '\\'';\r\n        }\r\n        if (type === 'string') {\r\n            val = encodeURIComponent(val);\r\n            val = '\\'' + val + '\\'';\r\n            if (requiresCast) {\r\n                field = 'cast(' + field + ', \\'Edm.String\\')';\r\n            }\r\n            if (DataUtil.parse.isGuid(val)) {\r\n                guid = 'guid';\r\n            }\r\n            if (predicate.ignoreCase) {\r\n                if (!guid) {\r\n                    field = 'tolower(' + field + ')';\r\n                }\r\n                val = val.toLowerCase();\r\n            }\r\n        }\r\n        operator = DataUtil.odBiOperator[predicate.operator];\r\n        if (operator) {\r\n            returnValue += field;\r\n            returnValue += operator;\r\n            if (guid) {\r\n                returnValue += guid;\r\n            }\r\n            return returnValue + val;\r\n        }\r\n        if (!isNullOrUndefined(this.getModuleName) && this.getModuleName() === 'ODataV4Adaptor') {\r\n            operator = DataUtil.odv4UniOperator[predicate.operator];\r\n        }\r\n        else {\r\n            operator = DataUtil.odUniOperator[predicate.operator];\r\n        }\r\n        if (operator === 'substringof') {\r\n            var temp = val;\r\n            val = field;\r\n            field = temp;\r\n        }\r\n        returnValue += operator + '(';\r\n        returnValue += field + ',';\r\n        if (guid) {\r\n            returnValue += guid;\r\n        }\r\n        returnValue += val + ')';\r\n        return returnValue;\r\n    };\r\n    ODataAdaptor.prototype.addParams = function (options) {\r\n        _super.prototype.addParams.call(this, options);\r\n        delete options.reqParams.params;\r\n    };\r\n    /**\r\n     * Generate request string based on the multiple filter criteria from query.\r\n     * @param  {Predicate} pred\r\n     * @param  {boolean} requiresCast?\r\n     */\r\n    ODataAdaptor.prototype.onComplexPredicate = function (predicate, query, requiresCast) {\r\n        var res = [];\r\n        for (var i = 0; i < predicate.predicates.length; i++) {\r\n            res.push('(' + this.onEachWhere(predicate.predicates[i], query, requiresCast) + ')');\r\n        }\r\n        return res.join(' ' + predicate.condition + ' ');\r\n    };\r\n    /**\r\n     * Generate query string based on the multiple filter criteria from query.\r\n     * @param  {Predicate} filter\r\n     * @param  {boolean} requiresCast?\r\n     */\r\n    ODataAdaptor.prototype.onEachWhere = function (filter, query, requiresCast) {\r\n        return filter.isComplex ? this.onComplexPredicate(filter, query, requiresCast) : this.onPredicate(filter, query, requiresCast);\r\n    };\r\n    /**\r\n     * Generate query string based on the multiple filter criteria from query.\r\n     * @param  {string[]} filters\r\n     */\r\n    ODataAdaptor.prototype.onWhere = function (filters) {\r\n        if (this.pvt.search) {\r\n            filters.push(this.onEachWhere(this.pvt.search, null, true));\r\n        }\r\n        return filters.join(' and ');\r\n    };\r\n    /**\r\n     * Generate query string based on the multiple search criteria from query.\r\n     * @param  {{fields:string[]} e\r\n     * @param  {string} operator\r\n     * @param  {string} key\r\n     * @param  {boolean}} ignoreCase\r\n     */\r\n    ODataAdaptor.prototype.onEachSearch = function (e) {\r\n        if (e.fields && e.fields.length === 0) {\r\n            DataUtil.throwError('Query() - Search : oData search requires list of field names to search');\r\n        }\r\n        var filter = this.pvt.search || [];\r\n        for (var i = 0; i < e.fields.length; i++) {\r\n            filter.push(new Predicate(e.fields[i], e.operator, e.key, e.ignoreCase));\r\n        }\r\n        this.pvt.search = filter;\r\n    };\r\n    /**\r\n     * Generate query string based on the search criteria from query.\r\n     * @param  {Object} e\r\n     */\r\n    ODataAdaptor.prototype.onSearch = function (e) {\r\n        this.pvt.search = Predicate.or(this.pvt.search);\r\n        return '';\r\n    };\r\n    /**\r\n     * Generate query string based on multiple sort criteria from query.\r\n     * @param  {QueryOptions} e\r\n     */\r\n    ODataAdaptor.prototype.onEachSort = function (e) {\r\n        var res = [];\r\n        if (e.name instanceof Array) {\r\n            for (var i = 0; i < e.name.length; i++) {\r\n                res.push(ODataAdaptor.getField(e.name[i]) + (e.direction === 'descending' ? ' desc' : ''));\r\n            }\r\n        }\r\n        else {\r\n            res.push(ODataAdaptor.getField(e.name) + (e.direction === 'descending' ? ' desc' : ''));\r\n        }\r\n        return res.join(',');\r\n    };\r\n    /**\r\n     * Returns sort query string.\r\n     * @param  {string[]} e\r\n     */\r\n    ODataAdaptor.prototype.onSortBy = function (e) {\r\n        return e.reverse().join(',');\r\n    };\r\n    /**\r\n     * Adds the group query to the adaptor option.\r\n     * @param  {Object[]} e\r\n     * @returns string\r\n     */\r\n    ODataAdaptor.prototype.onGroup = function (e) {\r\n        this.pvt.groups = e;\r\n        return [];\r\n    };\r\n    /**\r\n     * Returns the select query string.\r\n     * @param  {string[]} e\r\n     */\r\n    ODataAdaptor.prototype.onSelect = function (e) {\r\n        for (var i = 0; i < e.length; i++) {\r\n            e[i] = ODataAdaptor.getField(e[i]);\r\n        }\r\n        return e.join(',');\r\n    };\r\n    /**\r\n     * Add the aggregate query to the adaptor option.\r\n     * @param  {Object[]} e\r\n     * @returns string\r\n     */\r\n    ODataAdaptor.prototype.onAggregates = function (e) {\r\n        this.pvt.aggregates = e;\r\n        return '';\r\n    };\r\n    /**\r\n     * Returns the query string which requests total count from the data source.\r\n     * @param  {boolean} e\r\n     * @returns string\r\n     */\r\n    ODataAdaptor.prototype.onCount = function (e) {\r\n        return e === true ? 'allpages' : '';\r\n    };\r\n    /**\r\n     * Method will trigger before send the request to server side.\r\n     * Used to set the custom header or modify the request options.\r\n     * @param  {DataManager} dm\r\n     * @param  {XMLHttpRequest} request\r\n     * @param  {Ajax} settings?\r\n     */\r\n    ODataAdaptor.prototype.beforeSend = function (dm, request, settings) {\r\n        if (DataUtil.endsWith(settings.url, this.options.batch) && settings.type.toLowerCase() === 'post') {\r\n            request.setRequestHeader('Accept', this.options.multipartAccept);\r\n            request.setRequestHeader('DataServiceVersion', '2.0');\r\n            request.overrideMimeType('text/plain; charset=x-user-defined');\r\n        }\r\n        else {\r\n            request.setRequestHeader('Accept', this.options.accept);\r\n        }\r\n        request.setRequestHeader('DataServiceVersion', '2.0');\r\n        request.setRequestHeader('MaxDataServiceVersion', '2.0');\r\n    };\r\n    /**\r\n     * Returns the data from the query processing.\r\n     * @param  {DataResult} data\r\n     * @param  {DataOptions} ds?\r\n     * @param  {Query} query?\r\n     * @param  {XMLHttpRequest} xhr?\r\n     * @param  {Ajax} request?\r\n     * @param  {CrudOptions} changes?\r\n     * @returns aggregateResult\r\n     */\r\n    ODataAdaptor.prototype.processResponse = function (data, ds, query, xhr, request, changes) {\r\n        var pvtData = 'pvtData';\r\n        if (!isNullOrUndefined(data.d)) {\r\n            var dataCopy = ((query && query.isCountRequired) ? data.d.results : data.d);\r\n            var metaData = '__metadata';\r\n            if (!isNullOrUndefined(dataCopy)) {\r\n                for (var i = 0; i < dataCopy.length; i++) {\r\n                    if (!isNullOrUndefined(dataCopy[i][metaData])) {\r\n                        delete dataCopy[i][metaData];\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        var pvt = request && request[pvtData];\r\n        var emptyAndBatch = this.processBatchResponse(data, query, xhr, request, changes);\r\n        if (emptyAndBatch) {\r\n            return emptyAndBatch;\r\n        }\r\n        var versionCheck = xhr && request.getResponseHeader('DataServiceVersion');\r\n        var count = null;\r\n        var version = (versionCheck && parseInt(versionCheck, 10)) || 2;\r\n        if (query && query.isCountRequired) {\r\n            var oDataCount = '__count';\r\n            if (data[oDataCount] || data['odata.count']) {\r\n                count = data[oDataCount] || data['odata.count'];\r\n            }\r\n            if (data.d) {\r\n                data = data.d;\r\n            }\r\n            if (data[oDataCount] || data['odata.count']) {\r\n                count = data[oDataCount] || data['odata.count'];\r\n            }\r\n        }\r\n        if (version === 3 && data.value) {\r\n            data = data.value;\r\n        }\r\n        if (data.d) {\r\n            data = data.d;\r\n        }\r\n        if (version < 3 && data.results) {\r\n            data = data.results;\r\n        }\r\n        var args = {};\r\n        args.count = count;\r\n        args.result = data;\r\n        this.getAggregateResult(pvt, data, args, null, query);\r\n        return DataUtil.isNull(count) ? args.result : { result: args.result, count: args.count, aggregates: args.aggregates };\r\n    };\r\n    /**\r\n     * Converts the request object to query string.\r\n     * @param  {Object} req\r\n     * @param  {Query} query\r\n     * @param  {DataManager} dm\r\n     * @returns tableName\r\n     */\r\n    ODataAdaptor.prototype.convertToQueryString = function (request, query, dm) {\r\n        var res = [];\r\n        var table = 'table';\r\n        var tableName = request[table] || '';\r\n        var format = '$format';\r\n        delete request[table];\r\n        if (dm.dataSource.requiresFormat) {\r\n            request[format] = 'json';\r\n        }\r\n        var keys = Object.keys(request);\r\n        for (var _i = 0, keys_4 = keys; _i < keys_4.length; _i++) {\r\n            var prop = keys_4[_i];\r\n            res.push(prop + '=' + request[prop]);\r\n        }\r\n        res = res.join('&');\r\n        if (dm.dataSource.url && dm.dataSource.url.indexOf('?') !== -1 && !tableName) {\r\n            return res;\r\n        }\r\n        return res.length ? tableName + '?' + res : tableName || '';\r\n    };\r\n    ODataAdaptor.prototype.localTimeReplacer = function (key, convertObj) {\r\n        for (var _i = 0, _a = !isNullOrUndefined(convertObj) ? Object.keys(convertObj) : []; _i < _a.length; _i++) {\r\n            var prop = _a[_i];\r\n            if ((convertObj[prop] instanceof Date)) {\r\n                convertObj[prop] = DataUtil.dateParse.toLocalTime(convertObj[prop]);\r\n            }\r\n        }\r\n        return convertObj;\r\n    };\r\n    /**\r\n     * Prepare and returns request body which is used to insert a new record in the table.\r\n     * @param  {DataManager} dm\r\n     * @param  {Object} data\r\n     * @param  {string} tableName?\r\n     */\r\n    ODataAdaptor.prototype.insert = function (dm, data, tableName) {\r\n        return {\r\n            url: (dm.dataSource.insertUrl || dm.dataSource.url).replace(/\\/*$/, tableName ? '/' + tableName : ''),\r\n            data: JSON.stringify(data, this.options.localTime ? this.localTimeReplacer : null)\r\n        };\r\n    };\r\n    /**\r\n     * Prepare and return request body which is used to remove record from the table.\r\n     * @param  {DataManager} dm\r\n     * @param  {string} keyField\r\n     * @param  {number} value\r\n     * @param  {string} tableName?\r\n     */\r\n    ODataAdaptor.prototype.remove = function (dm, keyField, value, tableName) {\r\n        var url;\r\n        if (typeof value === 'string' && !DataUtil.parse.isGuid(value)) {\r\n            url = \"('\" + value + \"')\";\r\n        }\r\n        else {\r\n            url = \"(\" + value + \")\";\r\n        }\r\n        return {\r\n            type: 'DELETE',\r\n            url: (dm.dataSource.removeUrl || dm.dataSource.url).replace(/\\/*$/, tableName ? '/' + tableName : '') + url\r\n        };\r\n    };\r\n    /**\r\n     * Updates existing record and saves the changes to the table.\r\n     * @param  {DataManager} dm\r\n     * @param  {string} keyField\r\n     * @param  {Object} value\r\n     * @param  {string} tableName?\r\n     * @returns this\r\n     */\r\n    ODataAdaptor.prototype.update = function (dm, keyField, value, tableName, query, original) {\r\n        if (this.options.updateType === 'PATCH' && !isNullOrUndefined(original)) {\r\n            value = this.compareAndRemove(value, original, keyField);\r\n        }\r\n        var url;\r\n        if (typeof value[keyField] === 'string' && !DataUtil.parse.isGuid(value[keyField])) {\r\n            url = \"('\" + value[keyField] + \"')\";\r\n        }\r\n        else {\r\n            url = \"(\" + value[keyField] + \")\";\r\n        }\r\n        return {\r\n            type: this.options.updateType,\r\n            url: (dm.dataSource.updateUrl || dm.dataSource.url).replace(/\\/*$/, tableName ? '/' + tableName : '') + url,\r\n            data: JSON.stringify(value, this.options.localTime ? this.localTimeReplacer : null),\r\n            accept: this.options.accept\r\n        };\r\n    };\r\n    /**\r\n     * Prepare the request body based on the newly added, removed and updated records.\r\n     * The result is used by the batch request.\r\n     * @param  {DataManager} dm\r\n     * @param  {CrudOptions} changes\r\n     * @param  {RemoteArgs} e\r\n     * @returns {Object}\r\n     */\r\n    ODataAdaptor.prototype.batchRequest = function (dm, changes, e, query, original) {\r\n        var initialGuid = e.guid = DataUtil.getGuid(this.options.batchPre);\r\n        var url = dm.dataSource.url.replace(/\\/*$/, '/' + this.options.batch);\r\n        var args = {\r\n            url: e.url,\r\n            key: e.key,\r\n            cid: 1,\r\n            cSet: DataUtil.getGuid(this.options.changeSet)\r\n        };\r\n        var req = '--' + initialGuid + '\\n';\r\n        req += 'Content-Type: multipart/mixed; boundary=' + args.cSet.replace('--', '') + '\\n';\r\n        this.pvt.changeSet = 0;\r\n        req += this.generateInsertRequest(changes.addedRecords, args, dm);\r\n        req += this.generateUpdateRequest(changes.changedRecords, args, dm, original ? original.changedRecords : []);\r\n        req += this.generateDeleteRequest(changes.deletedRecords, args, dm);\r\n        req += args.cSet + '--\\n';\r\n        req += '--' + initialGuid + '--';\r\n        return {\r\n            type: 'POST',\r\n            url: url,\r\n            dataType: 'json',\r\n            contentType: 'multipart/mixed; charset=UTF-8;boundary=' + initialGuid,\r\n            data: req\r\n        };\r\n    };\r\n    /**\r\n     * Generate the string content from the removed records.\r\n     * The result will be send during batch update.\r\n     * @param  {Object[]} arr\r\n     * @param  {RemoteArgs} e\r\n     * @returns this\r\n     */\r\n    ODataAdaptor.prototype.generateDeleteRequest = function (arr, e, dm) {\r\n        if (!arr) {\r\n            return '';\r\n        }\r\n        var req = '';\r\n        var stat = {\r\n            'method': 'DELETE ',\r\n            'url': function (data, i, key) { return '(' + data[i][key] + ')'; },\r\n            'data': function (data, i) { return ''; }\r\n        };\r\n        req = this.generateBodyContent(arr, e, stat, dm);\r\n        return req + '\\n';\r\n    };\r\n    /**\r\n     * Generate the string content from the inserted records.\r\n     * The result will be send during batch update.\r\n     * @param  {Object[]} arr\r\n     * @param  {RemoteArgs} e\r\n     */\r\n    ODataAdaptor.prototype.generateInsertRequest = function (arr, e, dm) {\r\n        if (!arr) {\r\n            return '';\r\n        }\r\n        var req = '';\r\n        var stat = {\r\n            'method': 'POST ',\r\n            'url': function (data, i, key) { return ''; },\r\n            'data': function (data, i) { return JSON.stringify(data[i]) + '\\n\\n'; }\r\n        };\r\n        req = this.generateBodyContent(arr, e, stat, dm);\r\n        return req;\r\n    };\r\n    /**\r\n     * Generate the string content from the updated records.\r\n     * The result will be send during batch update.\r\n     * @param  {Object[]} arr\r\n     * @param  {RemoteArgs} e\r\n     */\r\n    ODataAdaptor.prototype.generateUpdateRequest = function (arr, e, dm, org) {\r\n        var _this = this;\r\n        if (!arr) {\r\n            return '';\r\n        }\r\n        var req = '';\r\n        arr.forEach(function (change) { return change = _this.compareAndRemove(change, org.filter(function (o) { return DataUtil.getObject(e.key, o) === DataUtil.getObject(e.key, change); })[0], e.key); });\r\n        var stat = {\r\n            'method': this.options.updateType + ' ',\r\n            'url': function (data, i, key) { return '(' + data[i][key] + ')'; },\r\n            'data': function (data, i) { return JSON.stringify(data[i]) + '\\n\\n'; }\r\n        };\r\n        req = this.generateBodyContent(arr, e, stat, dm);\r\n        return req;\r\n    };\r\n    ODataAdaptor.getField = function (prop) {\r\n        return prop.replace(/\\./g, '/');\r\n    };\r\n    ODataAdaptor.prototype.generateBodyContent = function (arr, e, stat, dm) {\r\n        var req = '';\r\n        for (var i = 0; i < arr.length; i++) {\r\n            req += '\\n' + e.cSet + '\\n';\r\n            req += this.options.changeSetContent + '\\n\\n';\r\n            req += stat.method;\r\n            if (stat.method === 'POST ') {\r\n                req += (dm.dataSource.insertUrl || dm.dataSource.crudUrl || e.url) + stat.url(arr, i, e.key) + ' HTTP/1.1\\n';\r\n            }\r\n            else if (stat.method === 'PUT ' || stat.method === 'PATCH ') {\r\n                req += (dm.dataSource.updateUrl || dm.dataSource.crudUrl || e.url) + stat.url(arr, i, e.key) + ' HTTP/1.1\\n';\r\n            }\r\n            else if (stat.method === 'DELETE ') {\r\n                req += (dm.dataSource.removeUrl || dm.dataSource.crudUrl || e.url) + stat.url(arr, i, e.key) + ' HTTP/1.1\\n';\r\n            }\r\n            req += 'Accept: ' + this.options.accept + '\\n';\r\n            req += 'Content-Id: ' + this.pvt.changeSet++ + '\\n';\r\n            req += this.options.batchChangeSetContentType + '\\n';\r\n            if (!isNullOrUndefined(arr[i]['@odata.etag'])) {\r\n                req += 'If-Match: ' + arr[i]['@odata.etag'] + '\\n\\n';\r\n                delete arr[i]['@odata.etag'];\r\n            }\r\n            else {\r\n                req += '\\n';\r\n            }\r\n            req += stat.data(arr, i);\r\n        }\r\n        return req;\r\n    };\r\n    ODataAdaptor.prototype.processBatchResponse = function (data, query, xhr, request, changes) {\r\n        if (xhr && xhr.getResponseHeader('Content-Type') && xhr.getResponseHeader('Content-Type').indexOf('xml') !== -1) {\r\n            return (query.isCountRequired ? { result: [], count: 0 } : []);\r\n        }\r\n        if (request && this.options.batch && DataUtil.endsWith(request.url, this.options.batch) && request.type.toLowerCase() === 'post') {\r\n            var guid = xhr.getResponseHeader('Content-Type');\r\n            var cIdx = void 0;\r\n            var jsonObj = void 0;\r\n            var d = data + '';\r\n            guid = guid.substring(guid.indexOf('=batchresponse') + 1);\r\n            d = d.split(guid);\r\n            if (d.length < 2) {\r\n                return {};\r\n            }\r\n            d = d[1];\r\n            var exVal = /(?:\\bContent-Type.+boundary=)(changesetresponse.+)/i.exec(d);\r\n            if (exVal) {\r\n                d.replace(exVal[0], '');\r\n            }\r\n            var changeGuid = exVal ? exVal[1] : '';\r\n            d = d.split(changeGuid);\r\n            for (var i = d.length; i > -1; i--) {\r\n                if (!/\\bContent-ID:/i.test(d[i]) || !/\\bHTTP.+201/.test(d[i])) {\r\n                    continue;\r\n                }\r\n                cIdx = parseInt(/\\bContent-ID: (\\d+)/i.exec(d[i])[1], 10);\r\n                if (changes.addedRecords[cIdx]) {\r\n                    jsonObj = DataUtil.parse.parseJson(/^\\{.+\\}/m.exec(d[i])[0]);\r\n                    extend({}, changes.addedRecords[cIdx], this.processResponse(jsonObj));\r\n                }\r\n            }\r\n            return changes;\r\n        }\r\n        return null;\r\n    };\r\n    ODataAdaptor.prototype.compareAndRemove = function (data, original, key) {\r\n        var _this = this;\r\n        if (isNullOrUndefined(original)) {\r\n            return data;\r\n        }\r\n        Object.keys(data).forEach(function (prop) {\r\n            if (prop !== key && prop !== '@odata.etag') {\r\n                if (DataUtil.isPlainObject(data[prop])) {\r\n                    _this.compareAndRemove(data[prop], original[prop]);\r\n                    var final = Object.keys(data[prop]).filter(function (data) { return data !== '@odata.etag'; });\r\n                    if (final.length === 0) {\r\n                        delete data[prop];\r\n                    }\r\n                }\r\n                else if (data[prop] === original[prop]) {\r\n                    delete data[prop];\r\n                }\r\n                else if (data[prop] && original[prop] && data[prop].valueOf() === original[prop].valueOf()) {\r\n                    delete data[prop];\r\n                }\r\n            }\r\n        });\r\n        return data;\r\n    };\r\n    return ODataAdaptor;\r\n}(UrlAdaptor));\r\nexport { ODataAdaptor };\r\n/**\r\n * The OData v4 is an improved version of OData protocols.\r\n * The DataManager uses the ODataV4Adaptor to consume OData v4 services.\r\n * @hidden\r\n */\r\nvar ODataV4Adaptor = /*@__PURE__*/ (function (_super) {\r\n    __extends(ODataV4Adaptor, _super);\r\n    function ODataV4Adaptor(props) {\r\n        var _this = _super.call(this, props) || this;\r\n        // options replaced the default adaptor options\r\n        _this.options = extend({}, _this.options, {\r\n            requestType: 'get',\r\n            accept: 'application/json, text/javascript, */*; q=0.01',\r\n            multipartAccept: 'multipart/mixed',\r\n            sortBy: '$orderby',\r\n            select: '$select',\r\n            skip: '$skip',\r\n            take: '$top',\r\n            count: '$count',\r\n            search: '$search',\r\n            where: '$filter',\r\n            expand: '$expand',\r\n            batch: '$batch',\r\n            changeSet: '--changeset_',\r\n            batchPre: 'batch_',\r\n            contentId: 'Content-Id: ',\r\n            batchContent: 'Content-Type: multipart/mixed; boundary=',\r\n            changeSetContent: 'Content-Type: application/http\\nContent-Transfer-Encoding: binary ',\r\n            batchChangeSetContentType: 'Content-Type: application/json; charset=utf-8 ',\r\n            updateType: 'PATCH',\r\n            localTime: false,\r\n            apply: '$apply'\r\n        });\r\n        extend(_this.options, props || {});\r\n        return _this;\r\n    }\r\n    /**\r\n     * @hidden\r\n     */\r\n    ODataV4Adaptor.prototype.getModuleName = function () {\r\n        return 'ODataV4Adaptor';\r\n    };\r\n    /**\r\n     * Returns the query string which requests total count from the data source.\r\n     * @param  {boolean} e\r\n     * @returns string\r\n     */\r\n    ODataV4Adaptor.prototype.onCount = function (e) {\r\n        return e === true ? 'true' : '';\r\n    };\r\n    /**\r\n     * Generate request string based on the filter criteria from query.\r\n     * @param  {Predicate} pred\r\n     * @param  {boolean} requiresCast?\r\n     */\r\n    ODataV4Adaptor.prototype.onPredicate = function (predicate, query, requiresCast) {\r\n        var returnValue = '';\r\n        var val = predicate.value;\r\n        var isDate = val instanceof Date;\r\n        returnValue = _super.prototype.onPredicate.call(this, predicate, query, requiresCast);\r\n        if (isDate) {\r\n            returnValue = returnValue.replace(/datetime'(.*)'$/, '$1');\r\n        }\r\n        return returnValue;\r\n    };\r\n    /**\r\n     *  Generate query string based on the multiple search criteria from query.\r\n     * @param  {{fields:string[]} e\r\n     * @param  {string} operator\r\n     * @param  {string} key\r\n     * @param  {boolean}} ignoreCase\r\n     */\r\n    ODataV4Adaptor.prototype.onEachSearch = function (e) {\r\n        var search = this.pvt.searches || [];\r\n        search.push(e.key);\r\n        this.pvt.searches = search;\r\n    };\r\n    /**\r\n     *  Generate query string based on the search criteria from query.\r\n     * @param  {Object} e\r\n     */\r\n    ODataV4Adaptor.prototype.onSearch = function (e) {\r\n        return this.pvt.searches.join(' OR ');\r\n    };\r\n    /**\r\n     * Returns the expand query string.\r\n     * @param  {string} e\r\n     */\r\n    ODataV4Adaptor.prototype.onExpand = function (e) {\r\n        var _this = this;\r\n        var selected = {};\r\n        var expanded = {};\r\n        var expands = e.expands.slice();\r\n        var exArr = [];\r\n        var selects = e.selects.filter(function (item) { return item.indexOf('.') > -1; });\r\n        selects.forEach(function (select) {\r\n            var splits = select.split('.');\r\n            if (!(splits[0] in selected)) {\r\n                selected[splits[0]] = [];\r\n            }\r\n            selected[splits[0]].push(splits[1]);\r\n        });\r\n        //Auto expand from select query\r\n        Object.keys(selected).forEach(function (expand) {\r\n            if ((expands.indexOf(expand) === -1)) {\r\n                expands.push(expand);\r\n            }\r\n        });\r\n        expands.forEach(function (expand) {\r\n            expanded[expand] = expand in selected ? expand + \"(\" + _this.options.select + \"=\" + selected[expand].join(',') + \")\" : expand;\r\n        });\r\n        Object.keys(expanded).forEach(function (ex) { return exArr.push(expanded[ex]); });\r\n        return exArr.join(',');\r\n    };\r\n    /**\r\n     * Returns the groupby query string.\r\n     * @param  {string} e\r\n     */\r\n    ODataV4Adaptor.prototype.onDistinct = function (distinctFields) {\r\n        var fields = distinctFields.map(function (field) { return ODataAdaptor.getField(field); }).join(',');\r\n        return \"groupby((\" + fields + \"))\";\r\n    };\r\n    /**\r\n     * Returns the select query string.\r\n     * @param  {string[]} e\r\n     */\r\n    ODataV4Adaptor.prototype.onSelect = function (e) {\r\n        return _super.prototype.onSelect.call(this, e.filter(function (item) { return item.indexOf('.') === -1; }));\r\n    };\r\n    /**\r\n     * Method will trigger before send the request to server side.\r\n     * Used to set the custom header or modify the request options.\r\n     * @param  {DataManager} dm\r\n     * @param  {XMLHttpRequest} request\r\n     * @param  {Ajax} settings\r\n     * @returns void\r\n     */\r\n    ODataV4Adaptor.prototype.beforeSend = function (dm, request, settings) {\r\n        if (settings.type === 'POST' || settings.type === 'PUT' || settings.type === 'PATCH') {\r\n            request.setRequestHeader('Prefer', 'return=representation');\r\n        }\r\n        request.setRequestHeader('Accept', this.options.accept);\r\n    };\r\n    /**\r\n     * Returns the data from the query processing.\r\n     * @param  {DataResult} data\r\n     * @param  {DataOptions} ds?\r\n     * @param  {Query} query?\r\n     * @param  {XMLHttpRequest} xhr?\r\n     * @param  {Ajax} request?\r\n     * @param  {CrudOptions} changes?\r\n     * @returns aggregateResult\r\n     */\r\n    ODataV4Adaptor.prototype.processResponse = function (data, ds, query, xhr, request, changes) {\r\n        var pvtData = 'pvtData';\r\n        var pvt = request && request[pvtData];\r\n        var emptyAndBatch = _super.prototype.processBatchResponse.call(this, data, query, xhr, request, changes);\r\n        if (emptyAndBatch) {\r\n            return emptyAndBatch;\r\n        }\r\n        var count = null;\r\n        var dataCount = '@odata.count';\r\n        if (query && query.isCountRequired) {\r\n            if (dataCount in data) {\r\n                count = data[dataCount];\r\n            }\r\n        }\r\n        data = !isNullOrUndefined(data.value) ? data.value : data;\r\n        var args = {};\r\n        args.count = count;\r\n        args.result = data;\r\n        this.getAggregateResult(pvt, data, args, null, query);\r\n        return DataUtil.isNull(count) ? args.result : { result: args.result, count: count, aggregates: args.aggregates };\r\n    };\r\n    return ODataV4Adaptor;\r\n}(ODataAdaptor));\r\nexport { ODataV4Adaptor };\r\n/**\r\n * The Web API is a programmatic interface to define the request and response messages system that is mostly exposed in JSON or XML.\r\n * The DataManager uses the WebApiAdaptor to consume Web API.\r\n * Since this adaptor is targeted to interact with Web API created using OData endpoint, it is extended from ODataAdaptor\r\n * @hidden\r\n */\r\nvar WebApiAdaptor = /*@__PURE__*/ (function (_super) {\r\n    __extends(WebApiAdaptor, _super);\r\n    function WebApiAdaptor() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    WebApiAdaptor.prototype.getModuleName = function () {\r\n        return 'WebApiAdaptor';\r\n    };\r\n    /**\r\n     * Prepare and returns request body which is used to insert a new record in the table.\r\n     * @param  {DataManager} dm\r\n     * @param  {Object} data\r\n     * @param  {string} tableName?\r\n     */\r\n    WebApiAdaptor.prototype.insert = function (dm, data, tableName) {\r\n        return {\r\n            type: 'POST',\r\n            url: dm.dataSource.url,\r\n            data: JSON.stringify(data)\r\n        };\r\n    };\r\n    /**\r\n     * Prepare and return request body which is used to remove record from the table.\r\n     * @param  {DataManager} dm\r\n     * @param  {string} keyField\r\n     * @param  {number} value\r\n     * @param  {string} tableName?\r\n     */\r\n    WebApiAdaptor.prototype.remove = function (dm, keyField, value, tableName) {\r\n        return {\r\n            type: 'DELETE',\r\n            url: dm.dataSource.url + '/' + value,\r\n            data: JSON.stringify(value)\r\n        };\r\n    };\r\n    /**\r\n     * Prepare and return request body which is used to update record.\r\n     * @param  {DataManager} dm\r\n     * @param  {string} keyField\r\n     * @param  {Object} value\r\n     * @param  {string} tableName?\r\n     */\r\n    WebApiAdaptor.prototype.update = function (dm, keyField, value, tableName) {\r\n        return {\r\n            type: 'PUT',\r\n            url: dm.dataSource.url,\r\n            data: JSON.stringify(value)\r\n        };\r\n    };\r\n    /**\r\n     * Method will trigger before send the request to server side.\r\n     * Used to set the custom header or modify the request options.\r\n     * @param  {DataManager} dm\r\n     * @param  {XMLHttpRequest} request\r\n     * @param  {Ajax} settings\r\n     * @returns void\r\n     */\r\n    WebApiAdaptor.prototype.beforeSend = function (dm, request, settings) {\r\n        request.setRequestHeader('Accept', 'application/json, text/javascript, */*; q=0.01');\r\n    };\r\n    /**\r\n     * Returns the data from the query processing.\r\n     * @param  {DataResult} data\r\n     * @param  {DataOptions} ds?\r\n     * @param  {Query} query?\r\n     * @param  {XMLHttpRequest} xhr?\r\n     * @param  {Ajax} request?\r\n     * @param  {CrudOptions} changes?\r\n     * @returns aggregateResult\r\n     */\r\n    WebApiAdaptor.prototype.processResponse = function (data, ds, query, xhr, request, changes) {\r\n        var pvtData = 'pvtData';\r\n        var pvt = request && request[pvtData];\r\n        var count = null;\r\n        var args = {};\r\n        if (request && request.type.toLowerCase() !== 'post') {\r\n            var versionCheck = xhr && request.getResponseHeader('DataServiceVersion');\r\n            var version = (versionCheck && parseInt(versionCheck, 10)) || 2;\r\n            if (query && query.isCountRequired) {\r\n                if (!DataUtil.isNull(data.Count)) {\r\n                    count = data.Count;\r\n                }\r\n            }\r\n            if (version < 3 && data.Items) {\r\n                data = data.Items;\r\n            }\r\n            args.count = count;\r\n            args.result = data;\r\n            this.getAggregateResult(pvt, data, args, null, query);\r\n        }\r\n        args.result = args.result || data;\r\n        return DataUtil.isNull(count) ? args.result : { result: args.result, count: args.count, aggregates: args.aggregates };\r\n    };\r\n    return WebApiAdaptor;\r\n}(ODataAdaptor));\r\nexport { WebApiAdaptor };\r\n/**\r\n * WebMethodAdaptor can be used by DataManager to interact with web method.\r\n * @hidden\r\n */\r\nvar WebMethodAdaptor = /*@__PURE__*/ (function (_super) {\r\n    __extends(WebMethodAdaptor, _super);\r\n    function WebMethodAdaptor() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    /**\r\n     * Prepare the request body based on the query.\r\n     * The query information can be accessed at the WebMethod using variable named `value`.\r\n     * @param  {DataManager} dm\r\n     * @param  {Query} query\r\n     * @param  {Object[]} hierarchyFilters?\r\n     * @returns application\r\n     */\r\n    WebMethodAdaptor.prototype.processQuery = function (dm, query, hierarchyFilters) {\r\n        var obj = new UrlAdaptor().processQuery(dm, query, hierarchyFilters);\r\n        var getData = 'data';\r\n        var data = DataUtil.parse.parseJson(obj[getData]);\r\n        var result = {};\r\n        var value = 'value';\r\n        if (data.param) {\r\n            for (var i = 0; i < data.param.length; i++) {\r\n                var param = data.param[i];\r\n                var key = Object.keys(param)[0];\r\n                result[key] = param[key];\r\n            }\r\n        }\r\n        result[value] = data;\r\n        var pvtData = 'pvtData';\r\n        var url = 'url';\r\n        return {\r\n            data: JSON.stringify(result),\r\n            url: obj[url],\r\n            pvtData: obj[pvtData],\r\n            type: 'POST',\r\n            contentType: 'application/json; charset=utf-8'\r\n        };\r\n    };\r\n    return WebMethodAdaptor;\r\n}(UrlAdaptor));\r\nexport { WebMethodAdaptor };\r\n/**\r\n * RemoteSaveAdaptor, extended from JsonAdaptor and it is used for binding local data and performs all DataManager queries in client-side.\r\n * It interacts with server-side only for CRUD operations.\r\n * @hidden\r\n */\r\nvar RemoteSaveAdaptor = /*@__PURE__*/ (function (_super) {\r\n    __extends(RemoteSaveAdaptor, _super);\r\n    /**\r\n     * @hidden\r\n     */\r\n    function RemoteSaveAdaptor() {\r\n        var _this = _super.call(this) || this;\r\n        setValue('beforeSend', UrlAdaptor.prototype.beforeSend, _this);\r\n        return _this;\r\n    }\r\n    RemoteSaveAdaptor.prototype.insert = function (dm, data, tableName, query) {\r\n        this.updateType = 'add';\r\n        return {\r\n            url: dm.dataSource.insertUrl || dm.dataSource.crudUrl || dm.dataSource.url,\r\n            data: JSON.stringify(extend({}, {\r\n                value: data,\r\n                table: tableName,\r\n                action: 'insert'\r\n            }, DataUtil.getAddParams(this, dm, query)))\r\n        };\r\n    };\r\n    RemoteSaveAdaptor.prototype.remove = function (dm, keyField, val, tableName, query) {\r\n        _super.prototype.remove.call(this, dm, keyField, val);\r\n        return {\r\n            type: 'POST',\r\n            url: dm.dataSource.removeUrl || dm.dataSource.crudUrl || dm.dataSource.url,\r\n            data: JSON.stringify(extend({}, {\r\n                key: val,\r\n                keyColumn: keyField,\r\n                table: tableName,\r\n                action: 'remove'\r\n            }, DataUtil.getAddParams(this, dm, query)))\r\n        };\r\n    };\r\n    RemoteSaveAdaptor.prototype.update = function (dm, keyField, val, tableName, query) {\r\n        this.updateType = 'update';\r\n        this.updateKey = keyField;\r\n        return {\r\n            type: 'POST',\r\n            url: dm.dataSource.updateUrl || dm.dataSource.crudUrl || dm.dataSource.url,\r\n            data: JSON.stringify(extend({}, {\r\n                value: val,\r\n                action: 'update',\r\n                keyColumn: keyField,\r\n                key: val[keyField],\r\n                table: tableName\r\n            }, DataUtil.getAddParams(this, dm, query)))\r\n        };\r\n    };\r\n    RemoteSaveAdaptor.prototype.processResponse = function (data, ds, query, xhr, request, changes, e) {\r\n        var i;\r\n        if (this.updateType === 'add') {\r\n            _super.prototype.insert.call(this, ds, data);\r\n        }\r\n        if (this.updateType === 'update') {\r\n            _super.prototype.update.call(this, ds, this.updateKey, data);\r\n        }\r\n        this.updateType = undefined;\r\n        if (data.added) {\r\n            for (i = 0; i < data.added.length; i++) {\r\n                _super.prototype.insert.call(this, ds, data.added[i]);\r\n            }\r\n        }\r\n        if (data.changed) {\r\n            for (i = 0; i < data.changed.length; i++) {\r\n                _super.prototype.update.call(this, ds, e.key, data.changed[i]);\r\n            }\r\n        }\r\n        if (data.deleted) {\r\n            for (i = 0; i < data.deleted.length; i++) {\r\n                _super.prototype.remove.call(this, ds, e.key, data.deleted[i]);\r\n            }\r\n        }\r\n        return data;\r\n    };\r\n    /**\r\n     * Prepare the request body based on the newly added, removed and updated records.\r\n     * Also perform the changes in the locally cached data to sync with the remote data.\r\n     * The result is used by the batch request.\r\n     * @param  {DataManager} dm\r\n     * @param  {CrudOptions} changes\r\n     * @param  {RemoteArgs} e\r\n     */\r\n    RemoteSaveAdaptor.prototype.batchRequest = function (dm, changes, e) {\r\n        return {\r\n            type: 'POST',\r\n            url: dm.dataSource.batchUrl || dm.dataSource.crudUrl || dm.dataSource.url,\r\n            contentType: 'application/json; charset=utf-8',\r\n            dataType: 'json',\r\n            data: JSON.stringify({\r\n                changed: changes.changedRecords,\r\n                added: changes.addedRecords,\r\n                deleted: changes.deletedRecords,\r\n                action: 'batch',\r\n                table: e.url,\r\n                key: e.key\r\n            })\r\n        };\r\n    };\r\n    RemoteSaveAdaptor.prototype.addParams = function (options) {\r\n        var urlParams = new UrlAdaptor();\r\n        urlParams.addParams(options);\r\n    };\r\n    return RemoteSaveAdaptor;\r\n}(JsonAdaptor));\r\nexport { RemoteSaveAdaptor };\r\n/**\r\n * Cache Adaptor is used to cache the data of the visited pages. It prevents new requests for the previously visited pages.\r\n * You can configure cache page size and duration of caching by using cachingPageSize and timeTillExpiration properties of the DataManager\r\n * @hidden\r\n */\r\nvar CacheAdaptor = /*@__PURE__*/ (function (_super) {\r\n    __extends(CacheAdaptor, _super);\r\n    /**\r\n     * Constructor for CacheAdaptor class.\r\n     * @param  {CacheAdaptor} adaptor?\r\n     * @param  {number} timeStamp?\r\n     * @param  {number} pageSize?\r\n     * @hidden\r\n     */\r\n    function CacheAdaptor(adaptor, timeStamp, pageSize) {\r\n        var _this = _super.call(this) || this;\r\n        _this.isCrudAction = false;\r\n        _this.isInsertAction = false;\r\n        if (!isNullOrUndefined(adaptor)) {\r\n            _this.cacheAdaptor = adaptor;\r\n        }\r\n        _this.pageSize = pageSize;\r\n        _this.guidId = DataUtil.getGuid('cacheAdaptor');\r\n        var obj = { keys: [], results: [] };\r\n        window.localStorage.setItem(_this.guidId, JSON.stringify(obj));\r\n        var guid = _this.guidId;\r\n        if (!isNullOrUndefined(timeStamp)) {\r\n            setInterval(function () {\r\n                var data;\r\n                data = DataUtil.parse.parseJson(window.localStorage.getItem(guid));\r\n                var forDel = [];\r\n                for (var i = 0; i < data.results.length; i++) {\r\n                    var currentTime = +new Date();\r\n                    var requestTime = +new Date(data.results[i].timeStamp);\r\n                    data.results[i].timeStamp = currentTime - requestTime;\r\n                    if (currentTime - requestTime > timeStamp) {\r\n                        forDel.push(i);\r\n                    }\r\n                }\r\n                for (var i = 0; i < forDel.length; i++) {\r\n                    data.results.splice(forDel[i], 1);\r\n                    data.keys.splice(forDel[i], 1);\r\n                }\r\n                window.localStorage.removeItem(guid);\r\n                window.localStorage.setItem(guid, JSON.stringify(data));\r\n            }, timeStamp);\r\n        }\r\n        return _this;\r\n    }\r\n    /**\r\n     * It will generate the key based on the URL when we send a request to server.\r\n     * @param  {string} url\r\n     * @param  {Query} query?\r\n     * @hidden\r\n     */\r\n    CacheAdaptor.prototype.generateKey = function (url, query) {\r\n        var queries = this.getQueryRequest(query);\r\n        var singles = Query.filterQueryLists(query.queries, ['onSelect', 'onPage', 'onSkip', 'onTake', 'onRange']);\r\n        var key = url;\r\n        var page = 'onPage';\r\n        if (page in singles) {\r\n            key += singles[page].pageIndex;\r\n        }\r\n        queries.sorts.forEach(function (obj) {\r\n            key += obj.e.direction + obj.e.fieldName;\r\n        });\r\n        queries.groups.forEach(function (obj) {\r\n            key += obj.e.fieldName;\r\n        });\r\n        queries.searches.forEach(function (obj) {\r\n            key += obj.e.searchKey;\r\n        });\r\n        for (var filter = 0; filter < queries.filters.length; filter++) {\r\n            var currentFilter = queries.filters[filter];\r\n            if (currentFilter.e.isComplex) {\r\n                var newQuery = query.clone();\r\n                newQuery.queries = [];\r\n                for (var i = 0; i < currentFilter.e.predicates.length; i++) {\r\n                    newQuery.queries.push({ fn: 'onWhere', e: currentFilter.e.predicates[i], filter: query.queries.filter });\r\n                }\r\n                key += currentFilter.e.condition + this.generateKey(url, newQuery);\r\n            }\r\n            else {\r\n                key += currentFilter.e.field + currentFilter.e.operator + currentFilter.e.value;\r\n            }\r\n        }\r\n        return key;\r\n    };\r\n    /**\r\n     * Process the query to generate request body.\r\n     * If the data is already cached, it will return the cached data.\r\n     * @param  {DataManager} dm\r\n     * @param  {Query} query?\r\n     * @param  {Object[]} hierarchyFilters?\r\n     */\r\n    CacheAdaptor.prototype.processQuery = function (dm, query, hierarchyFilters) {\r\n        var key = this.generateKey(dm.dataSource.url, query);\r\n        var cachedItems;\r\n        cachedItems = DataUtil.parse.parseJson(window.localStorage.getItem(this.guidId));\r\n        var data = cachedItems ? cachedItems.results[cachedItems.keys.indexOf(key)] : null;\r\n        if (data != null && !this.isCrudAction && !this.isInsertAction) {\r\n            return data;\r\n        }\r\n        this.isCrudAction = null;\r\n        this.isInsertAction = null;\r\n        return this.cacheAdaptor.processQuery.apply(this.cacheAdaptor, [].slice.call(arguments, 0));\r\n    };\r\n    /**\r\n     * Returns the data from the query processing.\r\n     * It will also cache the data for later usage.\r\n     * @param  {DataResult} data\r\n     * @param  {DataManager} ds?\r\n     * @param  {Query} query?\r\n     * @param  {XMLHttpRequest} xhr?\r\n     * @param  {Ajax} request?\r\n     * @param  {CrudOptions} changes?\r\n     */\r\n    CacheAdaptor.prototype.processResponse = function (data, ds, query, xhr, request, changes) {\r\n        if (this.isInsertAction || (request && this.cacheAdaptor.options.batch &&\r\n            DataUtil.endsWith(request.url, this.cacheAdaptor.options.batch) && request.type.toLowerCase() === 'post')) {\r\n            return this.cacheAdaptor.processResponse(data, ds, query, xhr, request, changes);\r\n        }\r\n        data = this.cacheAdaptor.processResponse.apply(this.cacheAdaptor, [].slice.call(arguments, 0));\r\n        var key = query ? this.generateKey(ds.dataSource.url, query) : ds.dataSource.url;\r\n        var obj = {};\r\n        obj = DataUtil.parse.parseJson(window.localStorage.getItem(this.guidId));\r\n        var index = obj.keys.indexOf(key);\r\n        if (index !== -1) {\r\n            obj.results.splice(index, 1);\r\n            obj.keys.splice(index, 1);\r\n        }\r\n        obj.results[obj.keys.push(key) - 1] = { keys: key, result: data.result, timeStamp: new Date(), count: data.count };\r\n        while (obj.results.length > this.pageSize) {\r\n            obj.results.splice(0, 1);\r\n            obj.keys.splice(0, 1);\r\n        }\r\n        window.localStorage.setItem(this.guidId, JSON.stringify(obj));\r\n        return data;\r\n    };\r\n    /**\r\n     * Method will trigger before send the request to server side. Used to set the custom header or modify the request options.\r\n     * @param  {DataManager} dm\r\n     * @param  {XMLHttpRequest} request\r\n     * @param  {Ajax} settings?\r\n     */\r\n    CacheAdaptor.prototype.beforeSend = function (dm, request, settings) {\r\n        if (DataUtil.endsWith(settings.url, this.cacheAdaptor.options.batch) && settings.type.toLowerCase() === 'post') {\r\n            request.setRequestHeader('Accept', this.cacheAdaptor.options.multipartAccept);\r\n        }\r\n        if (!dm.dataSource.crossDomain) {\r\n            request.setRequestHeader('Accept', this.cacheAdaptor.options.accept);\r\n        }\r\n    };\r\n    /**\r\n     * Updates existing record and saves the changes to the table.\r\n     * @param  {DataManager} dm\r\n     * @param  {string} keyField\r\n     * @param  {Object} value\r\n     * @param  {string} tableName\r\n     */\r\n    CacheAdaptor.prototype.update = function (dm, keyField, value, tableName) {\r\n        this.isCrudAction = true;\r\n        return this.cacheAdaptor.update(dm, keyField, value, tableName);\r\n    };\r\n    /**\r\n     * Prepare and returns request body which is used to insert a new record in the table.\r\n     * @param  {DataManager} dm\r\n     * @param  {Object} data\r\n     * @param  {string} tableName?\r\n     */\r\n    CacheAdaptor.prototype.insert = function (dm, data, tableName) {\r\n        this.isInsertAction = true;\r\n        return this.cacheAdaptor.insert(dm, data, tableName);\r\n    };\r\n    /**\r\n     * Prepare and return request body which is used to remove record from the table.\r\n     * @param  {DataManager} dm\r\n     * @param  {string} keyField\r\n     * @param  {Object} value\r\n     * @param  {string} tableName?\r\n     */\r\n    CacheAdaptor.prototype.remove = function (dm, keyField, value, tableName) {\r\n        this.isCrudAction = true;\r\n        return this.cacheAdaptor.remove(dm, keyField, value, tableName);\r\n    };\r\n    /**\r\n     * Prepare the request body based on the newly added, removed and updated records.\r\n     * The result is used by the batch request.\r\n     * @param  {DataManager} dm\r\n     * @param  {CrudOptions} changes\r\n     * @param  {RemoteArgs} e\r\n     */\r\n    CacheAdaptor.prototype.batchRequest = function (dm, changes, e) {\r\n        return this.cacheAdaptor.batchRequest(dm, changes, e);\r\n    };\r\n    return CacheAdaptor;\r\n}(UrlAdaptor));\r\nexport { CacheAdaptor };\r\n",null]}