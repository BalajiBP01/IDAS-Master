{"remainingRequest":"D:\\Projects\\IDAS_TFS\\Inspirit.IDAS\\Inspirit.IDAS.Admin\\ClientApp\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js??ref--3-1!D:\\Projects\\IDAS_TFS\\Inspirit.IDAS\\Inspirit.IDAS.Admin\\ClientApp\\node_modules\\@syncfusion\\ej2-richtexteditor\\src\\markdown-parser\\plugin\\lists.js","dependencies":[{"path":"D:\\Projects\\IDAS_TFS\\Inspirit.IDAS\\Inspirit.IDAS.Admin\\ClientApp\\node_modules\\@syncfusion\\ej2-richtexteditor\\src\\markdown-parser\\plugin\\lists.js","mtime":499162500000},{"path":"D:\\Projects\\IDAS_TFS\\Inspirit.IDAS\\Inspirit.IDAS.Admin\\ClientApp\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1510929699000},{"path":"D:\\Projects\\IDAS_TFS\\Inspirit.IDAS\\Inspirit.IDAS.Admin\\ClientApp\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js","mtime":1518048966000}],"contextDependencies":[],"result":["import * as CONSTANT from './../base/constant';\r\nimport { extend } from '@syncfusion/ej2-base';\r\nimport * as EVENTS from './../../common/constant';\r\n/**\r\n * Lists internal component\r\n * @hidden\r\n */\r\nvar MDLists = /*@__PURE__*/ (function () {\r\n    /**\r\n     * Constructor for creating the Lists plugin\r\n     * @hidden\r\n     */\r\n    function MDLists(options) {\r\n        extend(this, this, options, true);\r\n        this.selection = this.parent.markdownSelection;\r\n        this.addEventListener();\r\n    }\r\n    MDLists.prototype.addEventListener = function () {\r\n        this.parent.observer.on(CONSTANT.LISTS_COMMAND, this.applyListsHandler, this);\r\n        this.parent.observer.on(EVENTS.KEY_DOWN_HANDLER, this.keyDownHandler, this);\r\n        this.parent.observer.on(EVENTS.KEY_UP_HANDLER, this.keyUpHandler, this);\r\n    };\r\n    MDLists.prototype.keyDownHandler = function (event) {\r\n        switch (event.event.which) {\r\n            case 9:\r\n                this.tabKey(event);\r\n                break;\r\n        }\r\n        switch (event.event.action) {\r\n            case 'ordered-list':\r\n                this.applyListsHandler({ subCommand: 'OL', callBack: event.callBack });\r\n                event.event.preventDefault();\r\n                break;\r\n            case 'unordered-list':\r\n                this.applyListsHandler({ subCommand: 'UL', callBack: event.callBack });\r\n                event.event.preventDefault();\r\n                break;\r\n        }\r\n    };\r\n    MDLists.prototype.keyUpHandler = function (event) {\r\n        switch (event.event.which) {\r\n            case 13:\r\n                this.enterKey(event);\r\n                break;\r\n        }\r\n    };\r\n    MDLists.prototype.tabKey = function (event) {\r\n        var textArea = this.parent.element;\r\n        this.selection.save(textArea.selectionStart, textArea.selectionEnd);\r\n        var start = textArea.selectionStart;\r\n        var end = textArea.selectionEnd;\r\n        var parents = this.selection.getSelectedParentPoints(textArea);\r\n        var addedLength = 0;\r\n        var isNotFirst = this.isNotFirstLine(textArea, parents[0]);\r\n        if (!isNotFirst && !event.event.shiftKey) {\r\n            this.restore(textArea, start, end + addedLength, event);\r\n            return;\r\n        }\r\n        var regex = this.getListRegex();\r\n        this.currentAction = this.getAction(parents[0].text);\r\n        for (var i = 0; i < parents.length; i++) {\r\n            var prevIndex = event.event.shiftKey ? parents[i].line : parents[i].line - 1;\r\n            var prevLine = this.selection.getLine(textArea, prevIndex);\r\n            if (prevLine && (!event.event.shiftKey && isNotFirst || (event.event.shiftKey && /^(\\t)/.test(prevLine)))) {\r\n                prevLine = prevLine.trim();\r\n                if (regex.test(prevLine)) {\r\n                    event.event.preventDefault();\r\n                    var tabSpace = '\\t';\r\n                    var tabSpaceLength = event.event.shiftKey ? -tabSpace.length : tabSpace.length;\r\n                    var splitTab = parents[i].text.split('\\t');\r\n                    parents[i].text = event.event.shiftKey ? splitTab.splice(1, splitTab.length).join('\\t') : tabSpace + parents[i].text;\r\n                    textArea.value = textArea.value.substr(0, parents[i].start) + parents[i].text + '\\n' +\r\n                        textArea.value.substr(parents[i].end, textArea.value.length);\r\n                    start = i === 0 ? start + tabSpaceLength : start;\r\n                    addedLength += tabSpaceLength;\r\n                    if (parents.length !== 1) {\r\n                        for (var j = i; j < parents.length; j++) {\r\n                            parents[j].start = j !== 0 ? parents[j].start + tabSpaceLength : parents[j].start;\r\n                            parents[j].end = parents[j].end + tabSpaceLength;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        this.restore(textArea, start, end + addedLength, event);\r\n    };\r\n    MDLists.prototype.getTabSpace = function (line) {\r\n        var split = line.split('\\t');\r\n        var tabs = '';\r\n        for (var i = 0; i < split.length; i++) {\r\n            if (split[i] === '') {\r\n                tabs += '\\t';\r\n            }\r\n            else {\r\n                break;\r\n            }\r\n        }\r\n        return tabs;\r\n    };\r\n    MDLists.prototype.isNotFirstLine = function (textArea, points) {\r\n        var currentLine = points.text;\r\n        var prevIndex = points.line - 1;\r\n        var prevLine = this.selection.getLine(textArea, prevIndex);\r\n        var regex = this.getListRegex();\r\n        var isNotFirst = false;\r\n        if (prevLine && regex.test(prevLine.trim())) {\r\n            var curTabSpace = this.getTabSpace(currentLine);\r\n            var prevTabSpace = this.getTabSpace(prevLine);\r\n            isNotFirst = curTabSpace === prevTabSpace ? true : isNotFirst;\r\n            for (; prevTabSpace.length > curTabSpace.length; null) {\r\n                prevIndex = prevIndex - 1;\r\n                prevLine = this.selection.getLine(textArea, prevIndex);\r\n                if (regex.test(prevLine.trim())) {\r\n                    prevTabSpace = this.getTabSpace(prevLine);\r\n                    if (prevTabSpace.length <= curTabSpace.length) {\r\n                        isNotFirst = true;\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return isNotFirst;\r\n    };\r\n    MDLists.prototype.getAction = function (line) {\r\n        var ol = line.trim().split(new RegExp('^(' + this.selection.replaceSpecialChar(this.syntax.OL) + ')'))[1];\r\n        var ul = line.trim().split(new RegExp('^(' + this.selection.replaceSpecialChar(this.syntax.UL) + ')'))[1];\r\n        return (ol ? 'OL' : 'UL');\r\n    };\r\n    MDLists.prototype.enterKey = function (event) {\r\n        var textArea = this.parent.element;\r\n        this.selection.save(textArea.selectionStart, textArea.selectionEnd);\r\n        var start = textArea.selectionStart;\r\n        var end = textArea.selectionEnd;\r\n        var parents = this.selection.getSelectedParentPoints(textArea);\r\n        var prevLine = this.selection.getLine(textArea, parents[0].line - 1);\r\n        var regex = this.getListRegex();\r\n        if (regex.test(prevLine.trim()) && prevLine.trim().replace(regex, '') !== '') {\r\n            var addedLength = 0;\r\n            var tabSpace = this.getTabSpace(prevLine);\r\n            this.currentAction = this.getAction(prevLine);\r\n            var prefix = this.syntax[this.currentAction];\r\n            parents[0].text = tabSpace + prefix + parents[0].text;\r\n            textArea.value = textArea.value.substr(0, parents[0].start) + parents[0].text +\r\n                textArea.value.substr(parents[0].end, textArea.value.length);\r\n            start = start + prefix.length + tabSpace.length;\r\n            addedLength += prefix.length + tabSpace.length;\r\n            this.restore(textArea, start, end + addedLength, event);\r\n        }\r\n    };\r\n    MDLists.prototype.applyListsHandler = function (e) {\r\n        var textArea = this.parent.element;\r\n        this.selection.save(textArea.selectionStart, textArea.selectionEnd);\r\n        this.currentAction = e.subCommand;\r\n        var start = textArea.selectionStart;\r\n        var end = textArea.selectionEnd;\r\n        var addedLength = 0;\r\n        var startLength = 0;\r\n        var endLength = 0;\r\n        var parents = this.selection.getSelectedParentPoints(textArea);\r\n        var prefix = '';\r\n        var regex = this.syntax[this.currentAction];\r\n        for (var i = 0; i < parents.length; i++) {\r\n            if (!this.selection.isStartWith(parents[i].text, regex)) {\r\n                if (parents[i].text === '' && i === 0) {\r\n                    this.selection.save(start, end);\r\n                    if (parents.length !== 1) {\r\n                        for (var j = i; j < parents.length; j++) {\r\n                            parents[j].start = j !== 0 ? 1 + parents[j].start : parents[j].start;\r\n                            parents[j].end = 1 + parents[j].end;\r\n                        }\r\n                    }\r\n                }\r\n                var replace = this.appliedLine(parents[i].text);\r\n                prefix = replace.line ? prefix : this.syntax[this.currentAction];\r\n                parents[i].text = replace.line ? replace.line : prefix + parents[i].text;\r\n                replace.space = replace.space ? replace.space : 0;\r\n                textArea.value = textArea.value.substr(0, parents[i].start + endLength) + parents[i].text + '\\n' +\r\n                    textArea.value.substr(parents[i].end, textArea.value.length);\r\n                start = i === 0 ? (start + prefix.length + replace.space) > 0 ?\r\n                    start + prefix.length + replace.space : 0 : start;\r\n                addedLength += prefix.length + replace.space;\r\n                if (parents.length !== 1) {\r\n                    for (var j = i; j < parents.length; j++) {\r\n                        parents[j].start = j !== 0 ? prefix.length +\r\n                            parents[j].start + replace.space : parents[j].start;\r\n                        parents[j].end = prefix.length + parents[j].end + replace.space;\r\n                    }\r\n                }\r\n                this.restore(textArea, start, end + addedLength, e);\r\n            }\r\n            else {\r\n                parents[i].text = parents[i].text.replace(regex, '');\r\n                textArea.value = textArea.value.substr(0, parents[i].start + endLength) + parents[i].text + '\\n' +\r\n                    textArea.value.substr(parents[i].end + endLength, textArea.value.length);\r\n                endLength -= this.syntax[this.currentAction].length;\r\n                startLength = this.syntax[this.currentAction].length;\r\n                this.restore(textArea, start - startLength, end + endLength, e);\r\n            }\r\n        }\r\n    };\r\n    MDLists.prototype.appliedLine = function (line) {\r\n        var points = {};\r\n        var regex = this.getListRegex();\r\n        var isExist = regex.test(line.trim()) || line.trim() === this.syntax.OL.trim()\r\n            || line.trim() === this.syntax.UL.trim();\r\n        if (isExist) {\r\n            var replace = void 0;\r\n            var pattern = void 0;\r\n            var space = 0;\r\n            if (this.selection.getRegex(this.syntax.OL).test(line.trim())) {\r\n                pattern = this.selection.getRegex(this.syntax.OL);\r\n                replace = this.syntax.UL;\r\n                points.space = this.syntax.UL.length - this.syntax.OL.length;\r\n            }\r\n            else {\r\n                pattern = this.selection.getRegex(this.syntax.UL);\r\n                replace = this.syntax.OL;\r\n                points.space = this.syntax.OL.length - this.syntax.UL.length;\r\n            }\r\n            points.line = this.getTabSpace(line) + line.trim().replace(pattern, replace);\r\n        }\r\n        return points;\r\n    };\r\n    MDLists.prototype.restore = function (textArea, start, end, event) {\r\n        this.selection.save(start, end);\r\n        this.selection.restore(textArea);\r\n        if (event && event.callBack) {\r\n            event.callBack({\r\n                requestType: this.currentAction,\r\n                selectedText: this.selection.getSelectedText(textArea),\r\n                editorMode: 'Markdown',\r\n                event: event.event\r\n            });\r\n        }\r\n    };\r\n    MDLists.prototype.getListRegex = function () {\r\n        var regex = '';\r\n        var configKey = Object.keys(this.syntax);\r\n        for (var j = 0; j < configKey.length; j++) {\r\n            var syntax = this.selection.replaceSpecialChar(this.syntax[configKey[j]]);\r\n            regex += regex === '' ? '^(' + syntax + ')|^(' + syntax.trim() + ')' :\r\n                '|^(' + syntax + ')|^(' + syntax.trim() + ')';\r\n        }\r\n        return new RegExp(regex);\r\n    };\r\n    return MDLists;\r\n}());\r\nexport { MDLists };\r\n",null]}