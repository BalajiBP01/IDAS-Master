{"remainingRequest":"H:\\IDAS Admin\\SW Code Backup\\Inspirit.IDAS_new_v3_23-10-2019\\Inspirit.IDAS\\Inspirit.IDAS.Admin\\ClientApp\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js??ref--3-1!H:\\IDAS Admin\\SW Code Backup\\Inspirit.IDAS_new_v3_23-10-2019\\Inspirit.IDAS\\Inspirit.IDAS.Admin\\ClientApp\\node_modules\\@syncfusion\\ej2-data\\src\\query.js","dependencies":[{"path":"H:\\IDAS Admin\\SW Code Backup\\Inspirit.IDAS_new_v3_23-10-2019\\Inspirit.IDAS\\Inspirit.IDAS.Admin\\ClientApp\\node_modules\\@syncfusion\\ej2-data\\src\\query.js","mtime":499175100000},{"path":"H:\\IDAS Admin\\SW Code Backup\\Inspirit.IDAS_new_v3_23-10-2019\\Inspirit.IDAS\\Inspirit.IDAS.Admin\\ClientApp\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1510942300000},{"path":"H:\\IDAS Admin\\SW Code Backup\\Inspirit.IDAS_new_v3_23-10-2019\\Inspirit.IDAS\\Inspirit.IDAS.Admin\\ClientApp\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js","mtime":1518061566000}],"contextDependencies":[],"result":["import { DataUtil } from './util';\r\n/**\r\n * Query class is used to build query which is used by the DataManager to communicate with datasource.\r\n */\r\nvar Query = /*@__PURE__*/ (function () {\r\n    /**\r\n     * Constructor for Query class.\r\n     * @param  {string|string[]} from?\r\n     * @hidden\r\n     */\r\n    function Query(from) {\r\n        /** @hidden */\r\n        this.subQuery = null;\r\n        /** @hidden */\r\n        this.isChild = false;\r\n        /** @hidden */\r\n        this.distincts = [];\r\n        this.queries = [];\r\n        this.key = '';\r\n        this.fKey = '';\r\n        if (typeof from === 'string') {\r\n            this.fromTable = from;\r\n        }\r\n        else if (from && from instanceof Array) {\r\n            this.lookups = from;\r\n        }\r\n        this.expands = [];\r\n        this.sortedColumns = [];\r\n        this.groupedColumns = [];\r\n        this.subQuery = null;\r\n        this.isChild = false;\r\n        this.params = [];\r\n        return this;\r\n    }\r\n    /**\r\n     * Sets the primary key.\r\n     * @param  {string} field - Defines the column field.\r\n     */\r\n    Query.prototype.setKey = function (field) {\r\n        this.key = field;\r\n        return this;\r\n    };\r\n    /**\r\n     * Sets default DataManager to execute query.\r\n     * @param  {DataManager} dataManager - Defines the DataManager.\r\n     */\r\n    Query.prototype.using = function (dataManager) {\r\n        this.dataManager = dataManager;\r\n        return this;\r\n    };\r\n    /**\r\n     * Executes query with the given DataManager.\r\n     * @param  {DataManager} dataManager - Defines the DataManager.\r\n     * @param  {Function} done - Defines the success callback.\r\n     * @param  {Function} fail - Defines the failure callback.\r\n     * @param  {Function} always - Defines the callback which will be invoked on either success or failure.\r\n     *\r\n     * <pre>\r\n     * let dataManager: DataManager = new DataManager([{ ID: '10' }, { ID: '2' }, { ID: '1' }, { ID: '20' }]);\r\n     * let query: Query = new Query();\r\n     * query.sortBy('ID', (x: string, y: string): number => { return parseInt(x, 10) - parseInt(y, 10) });\r\n     * let promise: Promise< Object > = query.execute(dataManager);\r\n     * promise.then((e: { result: Object }) => { });\r\n     * </pre>\r\n     */\r\n    Query.prototype.execute = function (dataManager, done, fail, always) {\r\n        dataManager = dataManager || this.dataManager;\r\n        if (dataManager) {\r\n            return dataManager.executeQuery(this, done, fail, always);\r\n        }\r\n        return DataUtil.throwError('Query - execute() : dataManager needs to be is set using \"using\" function or should be passed as argument');\r\n    };\r\n    /**\r\n     * Executes query with the local datasource.\r\n     * @param  {DataManager} dataManager - Defines the DataManager.\r\n     */\r\n    Query.prototype.executeLocal = function (dataManager) {\r\n        dataManager = dataManager || this.dataManager;\r\n        if (dataManager) {\r\n            return dataManager.executeLocal(this);\r\n        }\r\n        return DataUtil.throwError('Query - executeLocal() : dataManager needs to be is set using \"using\" function or should be passed as argument');\r\n    };\r\n    /**\r\n     * Creates deep copy of the Query object.\r\n     */\r\n    Query.prototype.clone = function () {\r\n        var cloned = new Query();\r\n        cloned.queries = this.queries.slice(0);\r\n        cloned.key = this.key;\r\n        cloned.isChild = this.isChild;\r\n        cloned.dataManager = this.dataManager;\r\n        cloned.fromTable = this.fromTable;\r\n        cloned.params = this.params.slice(0);\r\n        cloned.expands = this.expands.slice(0);\r\n        cloned.sortedColumns = this.sortedColumns.slice(0);\r\n        cloned.groupedColumns = this.groupedColumns.slice(0);\r\n        cloned.subQuerySelector = this.subQuerySelector;\r\n        cloned.subQuery = this.subQuery;\r\n        cloned.fKey = this.fKey;\r\n        cloned.isCountRequired = this.isCountRequired;\r\n        cloned.distincts = this.distincts.slice(0);\r\n        return cloned;\r\n    };\r\n    /**\r\n     * Specifies the name of table to retrieve data in query execution.\r\n     * @param  {string} tableName - Defines the table name.\r\n     */\r\n    Query.prototype.from = function (tableName) {\r\n        this.fromTable = tableName;\r\n        return this;\r\n    };\r\n    /**\r\n     * Adds additional parameter which will be sent along with the request which will be generated while DataManager execute.\r\n     * @param  {string} key - Defines the key of additional parameter.\r\n     * @param  {Function|string} value - Defines the value for the key.\r\n     */\r\n    Query.prototype.addParams = function (key, value) {\r\n        if (typeof value === 'function') {\r\n            this.params.push({ key: key, fn: value });\r\n        }\r\n        else {\r\n            this.params.push({ key: key, value: value });\r\n        }\r\n        return this;\r\n    };\r\n    /**\r\n     * @hidden\r\n     */\r\n    Query.prototype.distinct = function (fields) {\r\n        if (typeof fields === 'string') {\r\n            this.distincts = [].slice.call([fields], 0);\r\n        }\r\n        else {\r\n            this.distincts = fields.slice(0);\r\n        }\r\n        return this;\r\n    };\r\n    /**\r\n     * Expands the related table.\r\n     * @param  {string|Object[]} tables\r\n     */\r\n    Query.prototype.expand = function (tables) {\r\n        if (typeof tables === 'string') {\r\n            this.expands = [].slice.call([tables], 0);\r\n        }\r\n        else {\r\n            this.expands = tables.slice(0);\r\n        }\r\n        return this;\r\n    };\r\n    /**\r\n     * Filter data with given filter criteria.\r\n     * @param  {string|Predicate} fieldName - Defines the column field or Predicate.\r\n     * @param  {string} operator - Defines the operator how to filter data.\r\n     * @param  {string|number|boolean} value - Defines the values to match with data.\r\n     * @param  {boolean} ignoreCase - If ignore case set to false, then filter data with exact match or else\r\n     * filter data with case insensitive.\r\n     */\r\n    Query.prototype.where = function (fieldName, operator, value, ignoreCase, ignoreAccent) {\r\n        operator = operator ? (operator).toLowerCase() : null;\r\n        var predicate = null;\r\n        if (typeof fieldName === 'string') {\r\n            predicate = new Predicate(fieldName, operator, value, ignoreCase, ignoreAccent);\r\n        }\r\n        else if (fieldName instanceof Predicate) {\r\n            predicate = fieldName;\r\n        }\r\n        this.queries.push({\r\n            fn: 'onWhere',\r\n            e: predicate\r\n        });\r\n        return this;\r\n    };\r\n    /**\r\n     * Search data with given search criteria.\r\n     * @param  {string|number|boolean} searchKey - Defines the search key.\r\n     * @param  {string|string[]} fieldNames - Defines the collection of column fields.\r\n     * @param  {string} operator - Defines the operator how to search data.\r\n     * @param  {boolean} ignoreCase - If ignore case set to false, then filter data with exact match or else\r\n     * filter data with case insensitive.\r\n     */\r\n    Query.prototype.search = function (searchKey, fieldNames, operator, ignoreCase, ignoreAccent) {\r\n        if (typeof fieldNames === 'string') {\r\n            fieldNames = [fieldNames];\r\n        }\r\n        operator = operator || 'contains';\r\n        var comparer = DataUtil.fnOperators[operator];\r\n        this.queries.push({\r\n            fn: 'onSearch',\r\n            e: {\r\n                fieldNames: fieldNames,\r\n                operator: operator,\r\n                searchKey: searchKey,\r\n                ignoreCase: ignoreCase,\r\n                ignoreAccent: ignoreAccent,\r\n                comparer: comparer\r\n            }\r\n        });\r\n        return this;\r\n    };\r\n    /**\r\n     * Sort the data with given sort criteria.\r\n     * By default, sort direction is ascending.\r\n     * @param  {string|string[]} fieldName - Defines the single or collection of column fields.\r\n     * @param  {string|Function} comparer - Defines the sort direction or custom sort comparer function.\r\n     */\r\n    Query.prototype.sortBy = function (fieldName, comparer, isFromGroup) {\r\n        var order = 'ascending';\r\n        var sorts;\r\n        var temp;\r\n        if (typeof fieldName === 'string' && DataUtil.endsWith(fieldName.toLowerCase(), ' desc')) {\r\n            fieldName = fieldName.replace(/ desc$/i, '');\r\n            comparer = 'descending';\r\n        }\r\n        if (!comparer || typeof comparer === 'string') {\r\n            order = comparer ? comparer.toLowerCase() : 'ascending';\r\n            comparer = DataUtil.fnSort(comparer);\r\n        }\r\n        if (isFromGroup) {\r\n            sorts = Query.filterQueries(this.queries, 'onSortBy');\r\n            for (var i = 0; i < sorts.length; i++) {\r\n                temp = sorts[i].e.fieldName;\r\n                if (typeof temp === 'string') {\r\n                    if (temp === fieldName) {\r\n                        return this;\r\n                    }\r\n                }\r\n                else if (temp instanceof Array) {\r\n                    for (var j = 0; j < temp.length; j++) {\r\n                        if (temp[j] === fieldName || fieldName.toLowerCase() === temp[j] + ' desc') {\r\n                            return this;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        this.queries.push({\r\n            fn: 'onSortBy',\r\n            e: {\r\n                fieldName: fieldName,\r\n                comparer: comparer,\r\n                direction: order\r\n            }\r\n        });\r\n        return this;\r\n    };\r\n    /**\r\n     * Sorts data in descending order.\r\n     * @param  {string} fieldName - Defines the column field.\r\n     */\r\n    Query.prototype.sortByDesc = function (fieldName) {\r\n        return this.sortBy(fieldName, 'descending');\r\n    };\r\n    /**\r\n     * Groups data with the given field name.\r\n     * @param  {string} fieldName - Defines the column field.\r\n     */\r\n    Query.prototype.group = function (fieldName, fn, format) {\r\n        this.sortBy(fieldName, null, true);\r\n        this.queries.push({\r\n            fn: 'onGroup',\r\n            e: {\r\n                fieldName: fieldName,\r\n                comparer: fn ? fn : null,\r\n                format: format ? format : null\r\n            }\r\n        });\r\n        return this;\r\n    };\r\n    /**\r\n     * Gets data based on the given page index and size.\r\n     * @param  {number} pageIndex - Defines the current page index.\r\n     * @param  {number} pageSize - Defines the no of records per page.\r\n     */\r\n    Query.prototype.page = function (pageIndex, pageSize) {\r\n        this.queries.push({\r\n            fn: 'onPage',\r\n            e: {\r\n                pageIndex: pageIndex,\r\n                pageSize: pageSize\r\n            }\r\n        });\r\n        return this;\r\n    };\r\n    /**\r\n     * Gets data based on the given start and end index.\r\n     * @param  {number} start - Defines the start index of the datasource.\r\n     * @param  {number} end - Defines the end index of the datasource.\r\n     */\r\n    Query.prototype.range = function (start, end) {\r\n        this.queries.push({\r\n            fn: 'onRange',\r\n            e: {\r\n                start: start,\r\n                end: end\r\n            }\r\n        });\r\n        return this;\r\n    };\r\n    /**\r\n     * Gets data from the top of the data source based on given number of records count.\r\n     * @param  {number} nos - Defines the no of records to retrieve from datasource.\r\n     */\r\n    Query.prototype.take = function (nos) {\r\n        this.queries.push({\r\n            fn: 'onTake',\r\n            e: {\r\n                nos: nos\r\n            }\r\n        });\r\n        return this;\r\n    };\r\n    /**\r\n     * Skips data with given number of records count from the top of the data source.\r\n     * @param  {number} nos - Defines the no of records skip in the datasource.\r\n     */\r\n    Query.prototype.skip = function (nos) {\r\n        this.queries.push({\r\n            fn: 'onSkip',\r\n            e: { nos: nos }\r\n        });\r\n        return this;\r\n    };\r\n    /**\r\n     * Selects specified columns from the data source.\r\n     * @param  {string|string[]} fieldNames - Defines the collection of column fields.\r\n     */\r\n    Query.prototype.select = function (fieldNames) {\r\n        if (typeof fieldNames === 'string') {\r\n            fieldNames = [].slice.call([fieldNames], 0);\r\n        }\r\n        this.queries.push({\r\n            fn: 'onSelect',\r\n            e: { fieldNames: fieldNames }\r\n        });\r\n        return this;\r\n    };\r\n    /**\r\n     * Gets the records in hierarchical relationship from two tables. It requires the foreign key to relate two tables.\r\n     * @param  {Query} query - Defines the query to relate two tables.\r\n     * @param  {Function} selectorFn - Defines the custom function to select records.\r\n     */\r\n    Query.prototype.hierarchy = function (query, selectorFn) {\r\n        this.subQuerySelector = selectorFn;\r\n        this.subQuery = query;\r\n        return this;\r\n    };\r\n    /**\r\n     * Sets the foreign key which is used to get data from the related table.\r\n     * @param  {string} key - Defines the foreign key.\r\n     */\r\n    Query.prototype.foreignKey = function (key) {\r\n        this.fKey = key;\r\n        return this;\r\n    };\r\n    /**\r\n     * It is used to get total number of records in the DataManager execution result.\r\n     */\r\n    Query.prototype.requiresCount = function () {\r\n        this.isCountRequired = true;\r\n        return this;\r\n    };\r\n    //type - sum, avg, min, max\r\n    /**\r\n     * Aggregate the data with given type and field name.\r\n     * @param  {string} type - Defines the aggregate type.\r\n     * @param  {string} field - Defines the column field to aggregate.\r\n     */\r\n    Query.prototype.aggregate = function (type, field) {\r\n        this.queries.push({\r\n            fn: 'onAggregates',\r\n            e: { field: field, type: type }\r\n        });\r\n        return this;\r\n    };\r\n    /**\r\n     * Pass array of filterColumn query for performing filter operation.\r\n     * @param  {QueryOptions[]} queries\r\n     * @param  {string} name\r\n     * @hidden\r\n     */\r\n    Query.filterQueries = function (queries, name) {\r\n        return queries.filter(function (q) {\r\n            return q.fn === name;\r\n        });\r\n    };\r\n    /**\r\n     * To get the list of queries which is already filtered in current data source.\r\n     * @param  {Object[]} queries\r\n     * @param  {string[]} singles\r\n     * @hidden\r\n     */\r\n    Query.filterQueryLists = function (queries, singles) {\r\n        var filtered = queries.filter(function (q) {\r\n            return singles.indexOf(q.fn) !== -1;\r\n        });\r\n        var res = {};\r\n        for (var i = 0; i < filtered.length; i++) {\r\n            if (!res[filtered[i].fn]) {\r\n                res[filtered[i].fn] = filtered[i].e;\r\n            }\r\n        }\r\n        return res;\r\n    };\r\n    return Query;\r\n}());\r\nexport { Query };\r\n/**\r\n * Predicate class is used to generate complex filter criteria.\r\n * This will be used by DataManager to perform multiple filtering operation.\r\n */\r\nvar Predicate = /*@__PURE__*/ (function () {\r\n    /**\r\n     * Constructor for Predicate class.\r\n     * @param  {string|Predicate} field\r\n     * @param  {string} operator\r\n     * @param  {string|number|boolean|Predicate|Predicate[]} value\r\n     * @param  {boolean=false} ignoreCase\r\n     * @hidden\r\n     */\r\n    function Predicate(field, operator, value, ignoreCase, ignoreAccent) {\r\n        if (ignoreCase === void 0) {\r\n            ignoreCase = false;\r\n        }\r\n        /** @hidden */\r\n        this.ignoreAccent = false;\r\n        /** @hidden */\r\n        this.isComplex = false;\r\n        if (typeof field === 'string') {\r\n            this.field = field;\r\n            this.operator = operator.toLowerCase();\r\n            this.value = value;\r\n            this.ignoreCase = ignoreCase;\r\n            this.ignoreAccent = ignoreAccent;\r\n            this.isComplex = false;\r\n            this.comparer = DataUtil.fnOperators.processOperator(this.operator);\r\n        }\r\n        else if (field instanceof Predicate && value instanceof Predicate || value instanceof Array) {\r\n            this.isComplex = true;\r\n            this.condition = operator.toLowerCase();\r\n            this.predicates = [field];\r\n            if (value instanceof Array) {\r\n                [].push.apply(this.predicates, value);\r\n            }\r\n            else {\r\n                this.predicates.push(value);\r\n            }\r\n        }\r\n        return this;\r\n    }\r\n    /**\r\n     * Adds n-number of new predicates on existing predicate with “and” condition.\r\n     * @param  {Object[]} args - Defines the collection of predicates.\r\n     */\r\n    Predicate.and = function () {\r\n        var args = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            args[_i] = arguments[_i];\r\n        }\r\n        return Predicate.combinePredicates([].slice.call(args, 0), 'and');\r\n    };\r\n    /**\r\n     * Adds new predicate on existing predicate with “and” condition.\r\n     * @param  {string} field - Defines the column field.\r\n     * @param  {string} operator - Defines the operator how to filter data.\r\n     * @param  {string} value - Defines the values to match with data.\r\n     * @param  {boolean} ignoreCase? - If ignore case set to false, then filter data with exact match or else\r\n     * filter data with case insensitive.\r\n     */\r\n    Predicate.prototype.and = function (field, operator, value, ignoreCase, ignoreAccent) {\r\n        return Predicate.combine(this, field, operator, value, 'and', ignoreCase, ignoreAccent);\r\n    };\r\n    /**\r\n     * Adds n-number of new predicates on existing predicate with “or” condition.\r\n     * @param  {Object[]} args - Defines the collection of predicates.\r\n     */\r\n    Predicate.or = function () {\r\n        var args = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            args[_i] = arguments[_i];\r\n        }\r\n        return Predicate.combinePredicates([].slice.call(args, 0), 'or');\r\n    };\r\n    /**\r\n     * Adds new predicate on existing predicate with “or” condition.\r\n     * @param  {string} field - Defines the column field.\r\n     * @param  {string} operator - Defines the operator how to filter data.\r\n     * @param  {string} value - Defines the values to match with data.\r\n     * @param  {boolean} ignoreCase? - If ignore case set to false, then filter data with exact match or else\r\n     * filter data with case insensitive.\r\n     */\r\n    Predicate.prototype.or = function (field, operator, value, ignoreCase, ignoreAccent) {\r\n        return Predicate.combine(this, field, operator, value, 'or', ignoreCase, ignoreAccent);\r\n    };\r\n    /**\r\n     * Converts plain JavaScript object to Predicate object.\r\n     * @param  {Predicate[]|Predicate} json - Defines single or collection of Predicate.\r\n     */\r\n    Predicate.fromJson = function (json) {\r\n        if (json instanceof Array) {\r\n            var res = [];\r\n            for (var i = 0, len = json.length; i < len; i++) {\r\n                res.push(this.fromJSONData(json[i]));\r\n            }\r\n            return res;\r\n        }\r\n        var pred = json;\r\n        return this.fromJSONData(pred);\r\n    };\r\n    /**\r\n     * Validate the record based on the predicates.\r\n     * @param  {Object} record - Defines the datasource record.\r\n     */\r\n    Predicate.prototype.validate = function (record) {\r\n        var predicate = this.predicates ? this.predicates : [];\r\n        var isAnd;\r\n        var ret;\r\n        if (!this.isComplex && this.comparer) {\r\n            return this.comparer.call(this, DataUtil.getObject(this.field, record), this.value, this.ignoreCase, this.ignoreAccent);\r\n        }\r\n        isAnd = this.condition === 'and';\r\n        for (var i = 0; i < predicate.length; i++) {\r\n            ret = predicate[i].validate(record);\r\n            if (isAnd) {\r\n                if (!ret) {\r\n                    return false;\r\n                }\r\n            }\r\n            else {\r\n                if (ret) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n        return isAnd;\r\n    };\r\n    /**\r\n     * Converts predicates to plain JavaScript.\r\n     * This method is uses Json stringify when serializing Predicate object.\r\n     */\r\n    Predicate.prototype.toJson = function () {\r\n        var predicates;\r\n        var p;\r\n        if (this.isComplex) {\r\n            predicates = [];\r\n            p = this.predicates;\r\n            for (var i = 0; i < p.length; i++) {\r\n                predicates.push(p[i].toJson());\r\n            }\r\n        }\r\n        return {\r\n            isComplex: this.isComplex,\r\n            field: this.field,\r\n            operator: this.operator,\r\n            value: this.value,\r\n            ignoreCase: this.ignoreCase,\r\n            ignoreAccent: this.ignoreAccent,\r\n            condition: this.condition,\r\n            predicates: predicates\r\n        };\r\n    };\r\n    Predicate.combinePredicates = function (predicates, operator) {\r\n        if (predicates.length === 1) {\r\n            if (!(predicates[0] instanceof Array)) {\r\n                return predicates[0];\r\n            }\r\n            predicates = predicates[0];\r\n        }\r\n        return new Predicate(predicates[0], operator, predicates.slice(1));\r\n    };\r\n    Predicate.combine = function (pred, field, operator, value, condition, ignoreCase, ignoreAccent) {\r\n        if (field instanceof Predicate) {\r\n            return Predicate[condition](pred, field);\r\n        }\r\n        if (typeof field === 'string') {\r\n            return Predicate[condition](pred, new Predicate(field, operator, value, ignoreCase, ignoreAccent));\r\n        }\r\n        return DataUtil.throwError('Predicate - ' + condition + ' : invalid arguments');\r\n    };\r\n    Predicate.fromJSONData = function (json) {\r\n        var preds = json.predicates || [];\r\n        var len = preds.length;\r\n        var predicates = [];\r\n        var result;\r\n        for (var i = 0; i < len; i++) {\r\n            predicates.push(this.fromJSONData(preds[i]));\r\n        }\r\n        if (!json.isComplex) {\r\n            result = new Predicate(json.field, json.operator, json.value, json.ignoreCase, json.ignoreAccent);\r\n        }\r\n        else {\r\n            result = new Predicate(predicates[0], json.condition, predicates.slice(1));\r\n        }\r\n        return result;\r\n    };\r\n    return Predicate;\r\n}());\r\nexport { Predicate };\r\n",null]}