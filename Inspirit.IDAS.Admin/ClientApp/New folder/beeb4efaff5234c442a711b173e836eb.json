{"remainingRequest":"D:\\Projects\\IDAS_TFS\\Inspirit.IDAS\\Inspirit.IDAS.Admin\\ClientApp\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js??ref--3-1!D:\\Projects\\IDAS_TFS\\Inspirit.IDAS\\Inspirit.IDAS.Admin\\ClientApp\\node_modules\\@syncfusion\\ej2-data\\src\\util.js","dependencies":[{"path":"D:\\Projects\\IDAS_TFS\\Inspirit.IDAS\\Inspirit.IDAS.Admin\\ClientApp\\node_modules\\@syncfusion\\ej2-data\\src\\util.js","mtime":499162500000},{"path":"D:\\Projects\\IDAS_TFS\\Inspirit.IDAS\\Inspirit.IDAS.Admin\\ClientApp\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1510929699000},{"path":"D:\\Projects\\IDAS_TFS\\Inspirit.IDAS\\Inspirit.IDAS.Admin\\ClientApp\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js","mtime":1518048966000}],"contextDependencies":[],"result":["import { isNullOrUndefined } from '@syncfusion/ej2-base';\r\nimport { DataManager } from './manager';\r\nimport { Query } from './query';\r\nvar consts = { GroupGuid: '{271bbba0-1ee7}' };\r\n/**\r\n * Data manager common utility methods.\r\n * @hidden\r\n */\r\nvar DataUtil = /*@__PURE__*/ (function () {\r\n    function DataUtil() {\r\n    }\r\n    /**\r\n     * Returns the value by invoking the provided parameter function.\r\n     * If the paramater is not of type function then it will be returned as it is.\r\n     * @param  {Function|string|string[]|number} value\r\n     * @param  {Object} inst?\r\n     * @hidden\r\n     */\r\n    DataUtil.getValue = function (value, inst) {\r\n        if (typeof value === 'function') {\r\n            return value.call(inst || {});\r\n        }\r\n        return value;\r\n    };\r\n    /**\r\n     * Returns true if the input string ends with given string.\r\n     * @param  {string} input\r\n     * @param  {string} substr\r\n     */\r\n    DataUtil.endsWith = function (input, substr) {\r\n        return input.slice(-substr.length) === substr;\r\n    };\r\n    /**\r\n     * Returns true if the input string starts with given string.\r\n     * @param  {string} str\r\n     * @param  {string} startstr\r\n     */\r\n    DataUtil.startsWith = function (input, start) {\r\n        return input.slice(0, start.length) === start;\r\n    };\r\n    /**\r\n     * To return the sorting function based on the string.\r\n     * @param  {string} order\r\n     * @hidden\r\n     */\r\n    DataUtil.fnSort = function (order) {\r\n        order = order ? DataUtil.toLowerCase(order) : 'ascending';\r\n        if (order === 'ascending') {\r\n            return this.fnAscending;\r\n        }\r\n        return this.fnDescending;\r\n    };\r\n    /**\r\n     * Comparer function which is used to sort the data in ascending order.\r\n     * @param  {string|number} x\r\n     * @param  {string|number} y\r\n     * @returns number\r\n     */\r\n    DataUtil.fnAscending = function (x, y) {\r\n        if (y === null || y === undefined) {\r\n            return -1;\r\n        }\r\n        if (typeof x === 'string') {\r\n            return x.localeCompare(y);\r\n        }\r\n        if (x === null || x === undefined) {\r\n            return 1;\r\n        }\r\n        return x - y;\r\n    };\r\n    /**\r\n     * Comparer function which is used to sort the data in descending order.\r\n     * @param  {string|number} x\r\n     * @param  {string|number} y\r\n     * @returns number\r\n     */\r\n    DataUtil.fnDescending = function (x, y) {\r\n        if (y === null || y === undefined) {\r\n            return 1;\r\n        }\r\n        if (typeof x === 'string') {\r\n            return x.localeCompare(y) * -1;\r\n        }\r\n        if (x === null || x === undefined) {\r\n            return -1;\r\n        }\r\n        return y - x;\r\n    };\r\n    DataUtil.extractFields = function (obj, fields) {\r\n        var newObj = {};\r\n        for (var i = 0; i < fields.length; i++) {\r\n            newObj = this.setValue(fields[i], this.getObject(fields[i], obj), newObj);\r\n        }\r\n        return newObj;\r\n    };\r\n    /**\r\n     * Select objects by given fields from jsonArray.\r\n     * @param  {Object[]} jsonArray\r\n     * @param  {string[]} fields\r\n     */\r\n    DataUtil.select = function (jsonArray, fields) {\r\n        var newData = [];\r\n        for (var i = 0; i < jsonArray.length; i++) {\r\n            newData.push(this.extractFields(jsonArray[i], fields));\r\n        }\r\n        return newData;\r\n    };\r\n    /**\r\n     * Group the input data based on the field name.\r\n     * It also performs aggregation of the grouped records based on the aggregates paramater.\r\n     * @param  {Object[]} jsonArray\r\n     * @param  {string} field?\r\n     * @param  {Object[]} agg?\r\n     * @param  {number} level?\r\n     * @param  {Object[]} groupDs?\r\n     */\r\n    DataUtil.group = function (jsonArray, field, aggregates, level, groupDs, format) {\r\n        level = level || 1;\r\n        var jsonData = jsonArray;\r\n        var guid = 'GroupGuid';\r\n        if (jsonData.GroupGuid === consts[guid]) {\r\n            var _loop_1 = function (j) {\r\n                if (!isNullOrUndefined(groupDs)) {\r\n                    var indx = -1;\r\n                    var temp = groupDs.filter(function (e) { return e.key === jsonData[j].key; });\r\n                    indx = groupDs.indexOf(temp[0]);\r\n                    jsonData[j].items = this_1.group(jsonData[j].items, field, aggregates, jsonData.level + 1, groupDs[indx].items, format);\r\n                    jsonData[j].count = groupDs[indx].count;\r\n                }\r\n                else {\r\n                    jsonData[j].items = this_1.group(jsonData[j].items, field, aggregates, jsonData.level + 1, null, format);\r\n                    jsonData[j].count = jsonData[j].items.length;\r\n                }\r\n            };\r\n            var this_1 = this;\r\n            for (var j = 0; j < jsonData.length; j++) {\r\n                _loop_1(j);\r\n            }\r\n            jsonData.childLevels += 1;\r\n            return jsonData;\r\n        }\r\n        var grouped = {};\r\n        var groupedArray = [];\r\n        groupedArray.GroupGuid = consts[guid];\r\n        groupedArray.level = level;\r\n        groupedArray.childLevels = 0;\r\n        groupedArray.records = jsonData;\r\n        var _loop_2 = function (i) {\r\n            var val = this_2.getVal(jsonData, i, field);\r\n            if (!isNullOrUndefined(format)) {\r\n                val = format(val, field);\r\n            }\r\n            if (!grouped[val]) {\r\n                grouped[val] = {\r\n                    key: val,\r\n                    count: 0,\r\n                    items: [],\r\n                    aggregates: {},\r\n                    field: field\r\n                };\r\n                groupedArray.push(grouped[val]);\r\n                if (!isNullOrUndefined(groupDs)) {\r\n                    var tempObj = groupDs.filter(function (e) { return e.key === grouped[val].key; });\r\n                    grouped[val].count = tempObj[0].count;\r\n                }\r\n            }\r\n            grouped[val].count = !isNullOrUndefined(groupDs) ? grouped[val].count : grouped[val].count += 1;\r\n            grouped[val].items.push(jsonData[i]);\r\n        };\r\n        var this_2 = this;\r\n        for (var i = 0; i < jsonData.length; i++) {\r\n            _loop_2(i);\r\n        }\r\n        if (aggregates && aggregates.length) {\r\n            var _loop_3 = function (i) {\r\n                var res = {};\r\n                var fn = void 0;\r\n                var aggs = aggregates;\r\n                for (var j = 0; j < aggregates.length; j++) {\r\n                    fn = DataUtil.aggregates[aggregates[j].type];\r\n                    if (!isNullOrUndefined(groupDs)) {\r\n                        var temp = groupDs.filter(function (e) { return e.key === groupedArray[i].key; });\r\n                        if (fn) {\r\n                            res[aggs[j].field + ' - ' + aggs[j].type] = fn(temp[0].items, aggs[j].field);\r\n                        }\r\n                    }\r\n                    else {\r\n                        if (fn) {\r\n                            res[aggs[j].field + ' - ' + aggs[j].type] = fn(groupedArray[i].items, aggs[j].field);\r\n                        }\r\n                    }\r\n                }\r\n                groupedArray[i].aggregates = res;\r\n            };\r\n            for (var i = 0; i < groupedArray.length; i++) {\r\n                _loop_3(i);\r\n            }\r\n        }\r\n        return jsonData.length && groupedArray || jsonData;\r\n    };\r\n    /**\r\n     * It is used to categorize the multiple items based on a specific field in jsonArray.\r\n     * The hierarchical queries are commonly required when you use foreign key binding.\r\n     * @param  {string} fKey\r\n     * @param  {string} from\r\n     * @param  {Object[]} source\r\n     * @param  {Group} lookup?\r\n     * @param  {string} pKey?\r\n     * @hidden\r\n     */\r\n    DataUtil.buildHierarchy = function (fKey, from, source, lookup, pKey) {\r\n        var i;\r\n        var grp = {};\r\n        var temp;\r\n        if (lookup.result) {\r\n            lookup = lookup.result;\r\n        }\r\n        if (lookup.GroupGuid) {\r\n            this.throwError('DataManager: Do not have support Grouping in hierarchy');\r\n        }\r\n        for (i = 0; i < lookup.length; i++) {\r\n            var fKeyData = this.getObject(fKey, lookup[i]);\r\n            temp = grp[fKeyData] || (grp[fKeyData] = []);\r\n            temp.push(lookup[i]);\r\n        }\r\n        for (i = 0; i < source.length; i++) {\r\n            var fKeyData = this.getObject(pKey || fKey, source[i]);\r\n            source[i][from] = grp[fKeyData];\r\n        }\r\n    };\r\n    /**\r\n     * The method used to get the field names which started with specified characters.\r\n     * @param  {Object} obj\r\n     * @param  {string[]} fields?\r\n     * @param  {string} prefix?\r\n     * @hidden\r\n     */\r\n    DataUtil.getFieldList = function (obj, fields, prefix) {\r\n        if (prefix === undefined) {\r\n            prefix = '';\r\n        }\r\n        if (fields === undefined || fields === null) {\r\n            return this.getFieldList(obj, [], prefix);\r\n        }\r\n        var copyObj = obj;\r\n        var keys = Object.keys(obj);\r\n        for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {\r\n            var prop = keys_1[_i];\r\n            if (typeof copyObj[prop] === 'object' && !(copyObj[prop] instanceof Array)) {\r\n                this.getFieldList(copyObj[prop], fields, prefix + prop + '.');\r\n            }\r\n            else {\r\n                fields.push(prefix + prop);\r\n            }\r\n        }\r\n        return fields;\r\n    };\r\n    /**\r\n     * Gets the value of the property in the given object.\r\n     * The complex object can be accessed by providing the field names concatenated with dot(.).\r\n     * @param  {string} nameSpace - The name of the property to be accessed.\r\n     * @param  {Object} from - Defines the source object.\r\n     */\r\n    DataUtil.getObject = function (nameSpace, from) {\r\n        if (!nameSpace) {\r\n            return from;\r\n        }\r\n        if (!from) {\r\n            return undefined;\r\n        }\r\n        if (nameSpace.indexOf('.') === -1) {\r\n            return from[nameSpace];\r\n        }\r\n        var value = from;\r\n        var splits = nameSpace.split('.');\r\n        for (var i = 0; i < splits.length; i++) {\r\n            if (value == null) {\r\n                break;\r\n            }\r\n            value = value[splits[i]];\r\n        }\r\n        return value;\r\n    };\r\n    /**\r\n     * To set value for the nameSpace in desired object.\r\n     * @param {string} nameSpace - String value to the get the inner object.\r\n     * @param {Object} value - Value that you need to set.\r\n     * @param {Object} obj - Object to get the inner object value.\r\n     * @return { [key: string]: Object; } | Object\r\n     * @hidden\r\n     */\r\n    DataUtil.setValue = function (nameSpace, value, obj) {\r\n        var keys = nameSpace.toString().split('.');\r\n        var start = obj || {};\r\n        var fromObj = start;\r\n        var i;\r\n        var length = keys.length;\r\n        var key;\r\n        for (i = 0; i < length; i++) {\r\n            key = keys[i];\r\n            if (i + 1 === length) {\r\n                fromObj[key] = value === undefined ? undefined : value;\r\n            }\r\n            else if (isNullOrUndefined(fromObj[key])) {\r\n                fromObj[key] = {};\r\n            }\r\n            fromObj = fromObj[key];\r\n        }\r\n        return start;\r\n    };\r\n    /**\r\n     * Sort the given data based on the field and comparer.\r\n     * @param  {Object[]} ds - Defines the input data.\r\n     * @param  {string} field - Defines the field to be sorted.\r\n     * @param  {Function} comparer - Defines the comparer function used to sort the records.\r\n     */\r\n    DataUtil.sort = function (ds, field, comparer) {\r\n        if (ds.length <= 1) {\r\n            return ds;\r\n        }\r\n        var middle = parseInt((ds.length / 2).toString(), 10);\r\n        var left = ds.slice(0, middle);\r\n        var right = ds.slice(middle);\r\n        left = this.sort(left, field, comparer);\r\n        right = this.sort(right, field, comparer);\r\n        return this.merge(left, right, field, comparer);\r\n    };\r\n    DataUtil.ignoreDiacritics = function (value) {\r\n        if (typeof value !== 'string') {\r\n            return value;\r\n        }\r\n        var result = value.split('');\r\n        var newValue = result.map(function (temp) { return temp in DataUtil.diacritics ? DataUtil.diacritics[temp] : temp; });\r\n        return newValue.join('');\r\n    };\r\n    DataUtil.merge = function (left, right, fieldName, comparer) {\r\n        var result = [];\r\n        var current;\r\n        while (left.length > 0 || right.length > 0) {\r\n            if (left.length > 0 && right.length > 0) {\r\n                if (comparer) {\r\n                    current = comparer(this.getVal(left, 0, fieldName), this.getVal(right, 0, fieldName)) <= 0 ? left : right;\r\n                }\r\n                else {\r\n                    current = left[0][fieldName] < left[0][fieldName] ? left : right;\r\n                }\r\n            }\r\n            else {\r\n                current = left.length > 0 ? left : right;\r\n            }\r\n            result.push(current.shift());\r\n        }\r\n        return result;\r\n    };\r\n    DataUtil.getVal = function (array, index, field) {\r\n        return field ? this.getObject(field, array[index]) : array[index];\r\n    };\r\n    DataUtil.toLowerCase = function (val) {\r\n        return val ? typeof val === 'string' ? val.toLowerCase() : val.toString() : (val === 0 || val === false) ? val.toString() : '';\r\n    };\r\n    /**\r\n     * To perform the filter operation with specified adaptor and returns the result.\r\n     * @param  {Object} adaptor\r\n     * @param  {string} fnName\r\n     * @param  {Object} param1?\r\n     * @param  {Object} param2?\r\n     * @hidden\r\n     */\r\n    DataUtil.callAdaptorFunction = function (adaptor, fnName, param1, param2) {\r\n        if (fnName in adaptor) {\r\n            var res = adaptor[fnName](param1, param2);\r\n            if (!isNullOrUndefined(res)) {\r\n                param1 = res;\r\n            }\r\n        }\r\n        return param1;\r\n    };\r\n    DataUtil.getAddParams = function (adp, dm, query) {\r\n        var req = {};\r\n        DataUtil.callAdaptorFunction(adp, 'addParams', {\r\n            dm: dm,\r\n            query: query,\r\n            params: query.params,\r\n            reqParams: req\r\n        });\r\n        return req;\r\n    };\r\n    /**\r\n     * Checks wheather the given input is a plain object or not.\r\n     * @param  {Object|Object[]} obj\r\n     */\r\n    DataUtil.isPlainObject = function (obj) {\r\n        return (!!obj) && (obj.constructor === Object);\r\n    };\r\n    /**\r\n     * Returns true when the browser cross origin request.\r\n     */\r\n    DataUtil.isCors = function () {\r\n        var xhr = null;\r\n        var request = 'XMLHttpRequest';\r\n        try {\r\n            xhr = new window[request]();\r\n        }\r\n        catch (e) {\r\n            // No exception handling\r\n        }\r\n        return !!xhr && ('withCredentials' in xhr);\r\n    };\r\n    /**\r\n     * Generate random GUID value which will be prefixed with the given value.\r\n     * @param  {string} prefix\r\n     */\r\n    DataUtil.getGuid = function (prefix) {\r\n        var hexs = '0123456789abcdef';\r\n        var rand;\r\n        return (prefix || '') + '00000000-0000-4000-0000-000000000000'.replace(/0/g, function (val, i) {\r\n            if ('crypto' in window && 'getRandomValues' in crypto) {\r\n                var arr = new Uint8Array(1);\r\n                window.crypto.getRandomValues(arr);\r\n                rand = arr[0] % 16 | 0;\r\n            }\r\n            else {\r\n                rand = Math.random() * 16 | 0;\r\n            }\r\n            return hexs[i === 19 ? rand & 0x3 | 0x8 : rand];\r\n        });\r\n    };\r\n    /**\r\n     * Checks wheather the given value is null or not.\r\n     * @param  {string|Object} val\r\n     * @returns boolean\r\n     */\r\n    DataUtil.isNull = function (val) {\r\n        return val === undefined || val === null;\r\n    };\r\n    /**\r\n     * To get the required items from collection of objects.\r\n     * @param  {Object[]} array\r\n     * @param  {string} field\r\n     * @param  {Function} comparer\r\n     * @returns Object\r\n     * @hidden\r\n     */\r\n    DataUtil.getItemFromComparer = function (array, field, comparer) {\r\n        var keyVal;\r\n        var current;\r\n        var key;\r\n        var i = 0;\r\n        var castRequired = typeof DataUtil.getVal(array, 0, field) === 'string';\r\n        if (array.length) {\r\n            while (isNullOrUndefined(keyVal) && i < array.length) {\r\n                keyVal = DataUtil.getVal(array, i, field);\r\n                key = array[i++];\r\n            }\r\n        }\r\n        for (; i < array.length; i++) {\r\n            current = DataUtil.getVal(array, i, field);\r\n            if (isNullOrUndefined(current)) {\r\n                continue;\r\n            }\r\n            if (castRequired) {\r\n                keyVal = +keyVal;\r\n                current = +current;\r\n            }\r\n            if (comparer(keyVal, current) > 0) {\r\n                keyVal = current;\r\n                key = array[i];\r\n            }\r\n        }\r\n        return key;\r\n    };\r\n    /**\r\n     * To get distinct values of Array or Array of Objects.\r\n     * @param  {Object[]} json\r\n     * @param  {string} field\r\n     * @param  {boolean} requiresCompleteRecord\r\n     * @returns Object[]\r\n     * * distinct array of objects is return when requiresCompleteRecord set as true.\r\n     * @hidden\r\n     */\r\n    DataUtil.distinct = function (json, fieldName, requiresCompleteRecord) {\r\n        requiresCompleteRecord = isNullOrUndefined(requiresCompleteRecord) ? false : requiresCompleteRecord;\r\n        var result = [];\r\n        var val;\r\n        var tmp = {};\r\n        json.forEach(function (data, index) {\r\n            val = DataUtil.getVal(json, index, fieldName);\r\n            if (!(val in tmp)) {\r\n                result.push(!requiresCompleteRecord ? val : json[index]);\r\n                tmp[val] = 1;\r\n            }\r\n        });\r\n        return result;\r\n    };\r\n    /**\r\n     * Specifies the value which will be used to adjust the date value to server timezone.\r\n     * @default null\r\n     */\r\n    DataUtil.serverTimezoneOffset = null;\r\n    /**\r\n     * Throw error with the given string as message.\r\n     * @param  {string} er\r\n     */\r\n    DataUtil.throwError = function (error) {\r\n        try {\r\n            throw new Error(error);\r\n        }\r\n        catch (e) {\r\n            throw e.message + '\\n' + e.stack;\r\n        }\r\n    };\r\n    DataUtil.aggregates = {\r\n        /**\r\n         * Calculate sum of the given field in the data.\r\n         * @param  {Object[]} ds\r\n         * @param  {string} field\r\n         */\r\n        sum: function (ds, field) {\r\n            var result = 0;\r\n            var val;\r\n            var castRequired = typeof DataUtil.getVal(ds, 0, field) !== 'number';\r\n            for (var i = 0; i < ds.length; i++) {\r\n                val = DataUtil.getVal(ds, i, field);\r\n                if (!isNaN(val) && val !== null) {\r\n                    if (castRequired) {\r\n                        val = +val;\r\n                    }\r\n                    result += val;\r\n                }\r\n            }\r\n            return result;\r\n        },\r\n        /**\r\n         * Calculate average value of the given field in the data.\r\n         * @param  {Object[]} ds\r\n         * @param  {string} field\r\n         */\r\n        average: function (ds, field) {\r\n            return DataUtil.aggregates.sum(ds, field) / ds.length;\r\n        },\r\n        /**\r\n         * Returns the min value of the data based on the field.\r\n         * @param  {Object[]} ds\r\n         * @param  {string|Function} field\r\n         */\r\n        min: function (ds, field) {\r\n            var comparer;\r\n            if (typeof field === 'function') {\r\n                comparer = field;\r\n                field = null;\r\n            }\r\n            return DataUtil.getObject(field, DataUtil.getItemFromComparer(ds, field, comparer || DataUtil.fnAscending));\r\n        },\r\n        /**\r\n         * Returns the max value of the data based on the field.\r\n         * @param  {Object[]} ds\r\n         * @param  {string} field\r\n         * @returns number\r\n         */\r\n        max: function (ds, field) {\r\n            var comparer;\r\n            if (typeof field === 'function') {\r\n                comparer = field;\r\n                field = null;\r\n            }\r\n            return DataUtil.getObject(field, DataUtil.getItemFromComparer(ds, field, comparer || DataUtil.fnDescending));\r\n        },\r\n        /**\r\n         * Returns the total number of true value present in the data based on the given boolean field name.\r\n         * @param  {Object[]} ds\r\n         * @param  {string} field\r\n         */\r\n        truecount: function (ds, field) {\r\n            return new DataManager(ds).executeLocal(new Query().where(field, 'equal', true, true)).length;\r\n        },\r\n        /**\r\n         * Returns the total number of false value present in the data based on the given boolean field name.\r\n         * @param  {Object[]} ds\r\n         * @param  {string} field\r\n         */\r\n        falsecount: function (ds, field) {\r\n            return new DataManager(ds).executeLocal(new Query().where(field, 'equal', false, true)).length;\r\n        },\r\n        /**\r\n         * Returns the length of the given data.\r\n         * @param  {Object[]} ds\r\n         * @param  {string} field?\r\n         * @returns number\r\n         */\r\n        count: function (ds, field) {\r\n            return ds.length;\r\n        }\r\n    };\r\n    /**\r\n     * Specifies the Object with filter operators.\r\n     */\r\n    DataUtil.operatorSymbols = {\r\n        '<': 'lessthan',\r\n        '>': 'greaterthan',\r\n        '<=': 'lessthanorequal',\r\n        '>=': 'greaterthanorequal',\r\n        '==': 'equal',\r\n        '!=': 'notequal',\r\n        '*=': 'contains',\r\n        '$=': 'endswith',\r\n        '^=': 'startswith'\r\n    };\r\n    /**\r\n     * Specifies the Object with filter operators which will be used for OData filter query generation.\r\n     * * It will be used for date/number type filter query.\r\n     */\r\n    DataUtil.odBiOperator = {\r\n        '<': ' lt ',\r\n        '>': ' gt ',\r\n        '<=': ' le ',\r\n        '>=': ' ge ',\r\n        '==': ' eq ',\r\n        '!=': ' ne ',\r\n        'lessthan': ' lt ',\r\n        'lessthanorequal': ' le ',\r\n        'greaterthan': ' gt ',\r\n        'greaterthanorequal': ' ge ',\r\n        'equal': ' eq ',\r\n        'notequal': ' ne '\r\n    };\r\n    /**\r\n     * Specifies the Object with filter operators which will be used for OData filter query generation.\r\n     * It will be used for string type filter query.\r\n     */\r\n    DataUtil.odUniOperator = {\r\n        '$=': 'endswith',\r\n        '^=': 'startswith',\r\n        '*=': 'substringof',\r\n        'endswith': 'endswith',\r\n        'startswith': 'startswith',\r\n        'contains': 'substringof'\r\n    };\r\n    /**\r\n     * Specifies the Object with filter operators which will be used for ODataV4 filter query generation.\r\n     * It will be used for string type filter query.\r\n     */\r\n    DataUtil.odv4UniOperator = {\r\n        '$=': 'endswith',\r\n        '^=': 'startswith',\r\n        '*=': 'contains',\r\n        'endswith': 'endswith',\r\n        'startswith': 'startswith',\r\n        'contains': 'contains'\r\n    };\r\n    DataUtil.diacritics = {\r\n        '\\u24B6': 'A',\r\n        '\\uFF21': 'A',\r\n        '\\u00C0': 'A',\r\n        '\\u00C1': 'A',\r\n        '\\u00C2': 'A',\r\n        '\\u1EA6': 'A',\r\n        '\\u1EA4': 'A',\r\n        '\\u1EAA': 'A',\r\n        '\\u1EA8': 'A',\r\n        '\\u00C3': 'A',\r\n        '\\u0100': 'A',\r\n        '\\u0102': 'A',\r\n        '\\u1EB0': 'A',\r\n        '\\u1EAE': 'A',\r\n        '\\u1EB4': 'A',\r\n        '\\u1EB2': 'A',\r\n        '\\u0226': 'A',\r\n        '\\u01E0': 'A',\r\n        '\\u00C4': 'A',\r\n        '\\u01DE': 'A',\r\n        '\\u1EA2': 'A',\r\n        '\\u00C5': 'A',\r\n        '\\u01FA': 'A',\r\n        '\\u01CD': 'A',\r\n        '\\u0200': 'A',\r\n        '\\u0202': 'A',\r\n        '\\u1EA0': 'A',\r\n        '\\u1EAC': 'A',\r\n        '\\u1EB6': 'A',\r\n        '\\u1E00': 'A',\r\n        '\\u0104': 'A',\r\n        '\\u023A': 'A',\r\n        '\\u2C6F': 'A',\r\n        '\\uA732': 'AA',\r\n        '\\u00C6': 'AE',\r\n        '\\u01FC': 'AE',\r\n        '\\u01E2': 'AE',\r\n        '\\uA734': 'AO',\r\n        '\\uA736': 'AU',\r\n        '\\uA738': 'AV',\r\n        '\\uA73A': 'AV',\r\n        '\\uA73C': 'AY',\r\n        '\\u24B7': 'B',\r\n        '\\uFF22': 'B',\r\n        '\\u1E02': 'B',\r\n        '\\u1E04': 'B',\r\n        '\\u1E06': 'B',\r\n        '\\u0243': 'B',\r\n        '\\u0182': 'B',\r\n        '\\u0181': 'B',\r\n        '\\u24B8': 'C',\r\n        '\\uFF23': 'C',\r\n        '\\u0106': 'C',\r\n        '\\u0108': 'C',\r\n        '\\u010A': 'C',\r\n        '\\u010C': 'C',\r\n        '\\u00C7': 'C',\r\n        '\\u1E08': 'C',\r\n        '\\u0187': 'C',\r\n        '\\u023B': 'C',\r\n        '\\uA73E': 'C',\r\n        '\\u24B9': 'D',\r\n        '\\uFF24': 'D',\r\n        '\\u1E0A': 'D',\r\n        '\\u010E': 'D',\r\n        '\\u1E0C': 'D',\r\n        '\\u1E10': 'D',\r\n        '\\u1E12': 'D',\r\n        '\\u1E0E': 'D',\r\n        '\\u0110': 'D',\r\n        '\\u018B': 'D',\r\n        '\\u018A': 'D',\r\n        '\\u0189': 'D',\r\n        '\\uA779': 'D',\r\n        '\\u01F1': 'DZ',\r\n        '\\u01C4': 'DZ',\r\n        '\\u01F2': 'Dz',\r\n        '\\u01C5': 'Dz',\r\n        '\\u24BA': 'E',\r\n        '\\uFF25': 'E',\r\n        '\\u00C8': 'E',\r\n        '\\u00C9': 'E',\r\n        '\\u00CA': 'E',\r\n        '\\u1EC0': 'E',\r\n        '\\u1EBE': 'E',\r\n        '\\u1EC4': 'E',\r\n        '\\u1EC2': 'E',\r\n        '\\u1EBC': 'E',\r\n        '\\u0112': 'E',\r\n        '\\u1E14': 'E',\r\n        '\\u1E16': 'E',\r\n        '\\u0114': 'E',\r\n        '\\u0116': 'E',\r\n        '\\u00CB': 'E',\r\n        '\\u1EBA': 'E',\r\n        '\\u011A': 'E',\r\n        '\\u0204': 'E',\r\n        '\\u0206': 'E',\r\n        '\\u1EB8': 'E',\r\n        '\\u1EC6': 'E',\r\n        '\\u0228': 'E',\r\n        '\\u1E1C': 'E',\r\n        '\\u0118': 'E',\r\n        '\\u1E18': 'E',\r\n        '\\u1E1A': 'E',\r\n        '\\u0190': 'E',\r\n        '\\u018E': 'E',\r\n        '\\u24BB': 'F',\r\n        '\\uFF26': 'F',\r\n        '\\u1E1E': 'F',\r\n        '\\u0191': 'F',\r\n        '\\uA77B': 'F',\r\n        '\\u24BC': 'G',\r\n        '\\uFF27': 'G',\r\n        '\\u01F4': 'G',\r\n        '\\u011C': 'G',\r\n        '\\u1E20': 'G',\r\n        '\\u011E': 'G',\r\n        '\\u0120': 'G',\r\n        '\\u01E6': 'G',\r\n        '\\u0122': 'G',\r\n        '\\u01E4': 'G',\r\n        '\\u0193': 'G',\r\n        '\\uA7A0': 'G',\r\n        '\\uA77D': 'G',\r\n        '\\uA77E': 'G',\r\n        '\\u24BD': 'H',\r\n        '\\uFF28': 'H',\r\n        '\\u0124': 'H',\r\n        '\\u1E22': 'H',\r\n        '\\u1E26': 'H',\r\n        '\\u021E': 'H',\r\n        '\\u1E24': 'H',\r\n        '\\u1E28': 'H',\r\n        '\\u1E2A': 'H',\r\n        '\\u0126': 'H',\r\n        '\\u2C67': 'H',\r\n        '\\u2C75': 'H',\r\n        '\\uA78D': 'H',\r\n        '\\u24BE': 'I',\r\n        '\\uFF29': 'I',\r\n        '\\u00CC': 'I',\r\n        '\\u00CD': 'I',\r\n        '\\u00CE': 'I',\r\n        '\\u0128': 'I',\r\n        '\\u012A': 'I',\r\n        '\\u012C': 'I',\r\n        '\\u0130': 'I',\r\n        '\\u00CF': 'I',\r\n        '\\u1E2E': 'I',\r\n        '\\u1EC8': 'I',\r\n        '\\u01CF': 'I',\r\n        '\\u0208': 'I',\r\n        '\\u020A': 'I',\r\n        '\\u1ECA': 'I',\r\n        '\\u012E': 'I',\r\n        '\\u1E2C': 'I',\r\n        '\\u0197': 'I',\r\n        '\\u24BF': 'J',\r\n        '\\uFF2A': 'J',\r\n        '\\u0134': 'J',\r\n        '\\u0248': 'J',\r\n        '\\u24C0': 'K',\r\n        '\\uFF2B': 'K',\r\n        '\\u1E30': 'K',\r\n        '\\u01E8': 'K',\r\n        '\\u1E32': 'K',\r\n        '\\u0136': 'K',\r\n        '\\u1E34': 'K',\r\n        '\\u0198': 'K',\r\n        '\\u2C69': 'K',\r\n        '\\uA740': 'K',\r\n        '\\uA742': 'K',\r\n        '\\uA744': 'K',\r\n        '\\uA7A2': 'K',\r\n        '\\u24C1': 'L',\r\n        '\\uFF2C': 'L',\r\n        '\\u013F': 'L',\r\n        '\\u0139': 'L',\r\n        '\\u013D': 'L',\r\n        '\\u1E36': 'L',\r\n        '\\u1E38': 'L',\r\n        '\\u013B': 'L',\r\n        '\\u1E3C': 'L',\r\n        '\\u1E3A': 'L',\r\n        '\\u0141': 'L',\r\n        '\\u023D': 'L',\r\n        '\\u2C62': 'L',\r\n        '\\u2C60': 'L',\r\n        '\\uA748': 'L',\r\n        '\\uA746': 'L',\r\n        '\\uA780': 'L',\r\n        '\\u01C7': 'LJ',\r\n        '\\u01C8': 'Lj',\r\n        '\\u24C2': 'M',\r\n        '\\uFF2D': 'M',\r\n        '\\u1E3E': 'M',\r\n        '\\u1E40': 'M',\r\n        '\\u1E42': 'M',\r\n        '\\u2C6E': 'M',\r\n        '\\u019C': 'M',\r\n        '\\u24C3': 'N',\r\n        '\\uFF2E': 'N',\r\n        '\\u01F8': 'N',\r\n        '\\u0143': 'N',\r\n        '\\u00D1': 'N',\r\n        '\\u1E44': 'N',\r\n        '\\u0147': 'N',\r\n        '\\u1E46': 'N',\r\n        '\\u0145': 'N',\r\n        '\\u1E4A': 'N',\r\n        '\\u1E48': 'N',\r\n        '\\u0220': 'N',\r\n        '\\u019D': 'N',\r\n        '\\uA790': 'N',\r\n        '\\uA7A4': 'N',\r\n        '\\u01CA': 'NJ',\r\n        '\\u01CB': 'Nj',\r\n        '\\u24C4': 'O',\r\n        '\\uFF2F': 'O',\r\n        '\\u00D2': 'O',\r\n        '\\u00D3': 'O',\r\n        '\\u00D4': 'O',\r\n        '\\u1ED2': 'O',\r\n        '\\u1ED0': 'O',\r\n        '\\u1ED6': 'O',\r\n        '\\u1ED4': 'O',\r\n        '\\u00D5': 'O',\r\n        '\\u1E4C': 'O',\r\n        '\\u022C': 'O',\r\n        '\\u1E4E': 'O',\r\n        '\\u014C': 'O',\r\n        '\\u1E50': 'O',\r\n        '\\u1E52': 'O',\r\n        '\\u014E': 'O',\r\n        '\\u022E': 'O',\r\n        '\\u0230': 'O',\r\n        '\\u00D6': 'O',\r\n        '\\u022A': 'O',\r\n        '\\u1ECE': 'O',\r\n        '\\u0150': 'O',\r\n        '\\u01D1': 'O',\r\n        '\\u020C': 'O',\r\n        '\\u020E': 'O',\r\n        '\\u01A0': 'O',\r\n        '\\u1EDC': 'O',\r\n        '\\u1EDA': 'O',\r\n        '\\u1EE0': 'O',\r\n        '\\u1EDE': 'O',\r\n        '\\u1EE2': 'O',\r\n        '\\u1ECC': 'O',\r\n        '\\u1ED8': 'O',\r\n        '\\u01EA': 'O',\r\n        '\\u01EC': 'O',\r\n        '\\u00D8': 'O',\r\n        '\\u01FE': 'O',\r\n        '\\u0186': 'O',\r\n        '\\u019F': 'O',\r\n        '\\uA74A': 'O',\r\n        '\\uA74C': 'O',\r\n        '\\u01A2': 'OI',\r\n        '\\uA74E': 'OO',\r\n        '\\u0222': 'OU',\r\n        '\\u24C5': 'P',\r\n        '\\uFF30': 'P',\r\n        '\\u1E54': 'P',\r\n        '\\u1E56': 'P',\r\n        '\\u01A4': 'P',\r\n        '\\u2C63': 'P',\r\n        '\\uA750': 'P',\r\n        '\\uA752': 'P',\r\n        '\\uA754': 'P',\r\n        '\\u24C6': 'Q',\r\n        '\\uFF31': 'Q',\r\n        '\\uA756': 'Q',\r\n        '\\uA758': 'Q',\r\n        '\\u024A': 'Q',\r\n        '\\u24C7': 'R',\r\n        '\\uFF32': 'R',\r\n        '\\u0154': 'R',\r\n        '\\u1E58': 'R',\r\n        '\\u0158': 'R',\r\n        '\\u0210': 'R',\r\n        '\\u0212': 'R',\r\n        '\\u1E5A': 'R',\r\n        '\\u1E5C': 'R',\r\n        '\\u0156': 'R',\r\n        '\\u1E5E': 'R',\r\n        '\\u024C': 'R',\r\n        '\\u2C64': 'R',\r\n        '\\uA75A': 'R',\r\n        '\\uA7A6': 'R',\r\n        '\\uA782': 'R',\r\n        '\\u24C8': 'S',\r\n        '\\uFF33': 'S',\r\n        '\\u1E9E': 'S',\r\n        '\\u015A': 'S',\r\n        '\\u1E64': 'S',\r\n        '\\u015C': 'S',\r\n        '\\u1E60': 'S',\r\n        '\\u0160': 'S',\r\n        '\\u1E66': 'S',\r\n        '\\u1E62': 'S',\r\n        '\\u1E68': 'S',\r\n        '\\u0218': 'S',\r\n        '\\u015E': 'S',\r\n        '\\u2C7E': 'S',\r\n        '\\uA7A8': 'S',\r\n        '\\uA784': 'S',\r\n        '\\u24C9': 'T',\r\n        '\\uFF34': 'T',\r\n        '\\u1E6A': 'T',\r\n        '\\u0164': 'T',\r\n        '\\u1E6C': 'T',\r\n        '\\u021A': 'T',\r\n        '\\u0162': 'T',\r\n        '\\u1E70': 'T',\r\n        '\\u1E6E': 'T',\r\n        '\\u0166': 'T',\r\n        '\\u01AC': 'T',\r\n        '\\u01AE': 'T',\r\n        '\\u023E': 'T',\r\n        '\\uA786': 'T',\r\n        '\\uA728': 'TZ',\r\n        '\\u24CA': 'U',\r\n        '\\uFF35': 'U',\r\n        '\\u00D9': 'U',\r\n        '\\u00DA': 'U',\r\n        '\\u00DB': 'U',\r\n        '\\u0168': 'U',\r\n        '\\u1E78': 'U',\r\n        '\\u016A': 'U',\r\n        '\\u1E7A': 'U',\r\n        '\\u016C': 'U',\r\n        '\\u00DC': 'U',\r\n        '\\u01DB': 'U',\r\n        '\\u01D7': 'U',\r\n        '\\u01D5': 'U',\r\n        '\\u01D9': 'U',\r\n        '\\u1EE6': 'U',\r\n        '\\u016E': 'U',\r\n        '\\u0170': 'U',\r\n        '\\u01D3': 'U',\r\n        '\\u0214': 'U',\r\n        '\\u0216': 'U',\r\n        '\\u01AF': 'U',\r\n        '\\u1EEA': 'U',\r\n        '\\u1EE8': 'U',\r\n        '\\u1EEE': 'U',\r\n        '\\u1EEC': 'U',\r\n        '\\u1EF0': 'U',\r\n        '\\u1EE4': 'U',\r\n        '\\u1E72': 'U',\r\n        '\\u0172': 'U',\r\n        '\\u1E76': 'U',\r\n        '\\u1E74': 'U',\r\n        '\\u0244': 'U',\r\n        '\\u24CB': 'V',\r\n        '\\uFF36': 'V',\r\n        '\\u1E7C': 'V',\r\n        '\\u1E7E': 'V',\r\n        '\\u01B2': 'V',\r\n        '\\uA75E': 'V',\r\n        '\\u0245': 'V',\r\n        '\\uA760': 'VY',\r\n        '\\u24CC': 'W',\r\n        '\\uFF37': 'W',\r\n        '\\u1E80': 'W',\r\n        '\\u1E82': 'W',\r\n        '\\u0174': 'W',\r\n        '\\u1E86': 'W',\r\n        '\\u1E84': 'W',\r\n        '\\u1E88': 'W',\r\n        '\\u2C72': 'W',\r\n        '\\u24CD': 'X',\r\n        '\\uFF38': 'X',\r\n        '\\u1E8A': 'X',\r\n        '\\u1E8C': 'X',\r\n        '\\u24CE': 'Y',\r\n        '\\uFF39': 'Y',\r\n        '\\u1EF2': 'Y',\r\n        '\\u00DD': 'Y',\r\n        '\\u0176': 'Y',\r\n        '\\u1EF8': 'Y',\r\n        '\\u0232': 'Y',\r\n        '\\u1E8E': 'Y',\r\n        '\\u0178': 'Y',\r\n        '\\u1EF6': 'Y',\r\n        '\\u1EF4': 'Y',\r\n        '\\u01B3': 'Y',\r\n        '\\u024E': 'Y',\r\n        '\\u1EFE': 'Y',\r\n        '\\u24CF': 'Z',\r\n        '\\uFF3A': 'Z',\r\n        '\\u0179': 'Z',\r\n        '\\u1E90': 'Z',\r\n        '\\u017B': 'Z',\r\n        '\\u017D': 'Z',\r\n        '\\u1E92': 'Z',\r\n        '\\u1E94': 'Z',\r\n        '\\u01B5': 'Z',\r\n        '\\u0224': 'Z',\r\n        '\\u2C7F': 'Z',\r\n        '\\u2C6B': 'Z',\r\n        '\\uA762': 'Z',\r\n        '\\u24D0': 'a',\r\n        '\\uFF41': 'a',\r\n        '\\u1E9A': 'a',\r\n        '\\u00E0': 'a',\r\n        '\\u00E1': 'a',\r\n        '\\u00E2': 'a',\r\n        '\\u1EA7': 'a',\r\n        '\\u1EA5': 'a',\r\n        '\\u1EAB': 'a',\r\n        '\\u1EA9': 'a',\r\n        '\\u00E3': 'a',\r\n        '\\u0101': 'a',\r\n        '\\u0103': 'a',\r\n        '\\u1EB1': 'a',\r\n        '\\u1EAF': 'a',\r\n        '\\u1EB5': 'a',\r\n        '\\u1EB3': 'a',\r\n        '\\u0227': 'a',\r\n        '\\u01E1': 'a',\r\n        '\\u00E4': 'a',\r\n        '\\u01DF': 'a',\r\n        '\\u1EA3': 'a',\r\n        '\\u00E5': 'a',\r\n        '\\u01FB': 'a',\r\n        '\\u01CE': 'a',\r\n        '\\u0201': 'a',\r\n        '\\u0203': 'a',\r\n        '\\u1EA1': 'a',\r\n        '\\u1EAD': 'a',\r\n        '\\u1EB7': 'a',\r\n        '\\u1E01': 'a',\r\n        '\\u0105': 'a',\r\n        '\\u2C65': 'a',\r\n        '\\u0250': 'a',\r\n        '\\uA733': 'aa',\r\n        '\\u00E6': 'ae',\r\n        '\\u01FD': 'ae',\r\n        '\\u01E3': 'ae',\r\n        '\\uA735': 'ao',\r\n        '\\uA737': 'au',\r\n        '\\uA739': 'av',\r\n        '\\uA73B': 'av',\r\n        '\\uA73D': 'ay',\r\n        '\\u24D1': 'b',\r\n        '\\uFF42': 'b',\r\n        '\\u1E03': 'b',\r\n        '\\u1E05': 'b',\r\n        '\\u1E07': 'b',\r\n        '\\u0180': 'b',\r\n        '\\u0183': 'b',\r\n        '\\u0253': 'b',\r\n        '\\u24D2': 'c',\r\n        '\\uFF43': 'c',\r\n        '\\u0107': 'c',\r\n        '\\u0109': 'c',\r\n        '\\u010B': 'c',\r\n        '\\u010D': 'c',\r\n        '\\u00E7': 'c',\r\n        '\\u1E09': 'c',\r\n        '\\u0188': 'c',\r\n        '\\u023C': 'c',\r\n        '\\uA73F': 'c',\r\n        '\\u2184': 'c',\r\n        '\\u24D3': 'd',\r\n        '\\uFF44': 'd',\r\n        '\\u1E0B': 'd',\r\n        '\\u010F': 'd',\r\n        '\\u1E0D': 'd',\r\n        '\\u1E11': 'd',\r\n        '\\u1E13': 'd',\r\n        '\\u1E0F': 'd',\r\n        '\\u0111': 'd',\r\n        '\\u018C': 'd',\r\n        '\\u0256': 'd',\r\n        '\\u0257': 'd',\r\n        '\\uA77A': 'd',\r\n        '\\u01F3': 'dz',\r\n        '\\u01C6': 'dz',\r\n        '\\u24D4': 'e',\r\n        '\\uFF45': 'e',\r\n        '\\u00E8': 'e',\r\n        '\\u00E9': 'e',\r\n        '\\u00EA': 'e',\r\n        '\\u1EC1': 'e',\r\n        '\\u1EBF': 'e',\r\n        '\\u1EC5': 'e',\r\n        '\\u1EC3': 'e',\r\n        '\\u1EBD': 'e',\r\n        '\\u0113': 'e',\r\n        '\\u1E15': 'e',\r\n        '\\u1E17': 'e',\r\n        '\\u0115': 'e',\r\n        '\\u0117': 'e',\r\n        '\\u00EB': 'e',\r\n        '\\u1EBB': 'e',\r\n        '\\u011B': 'e',\r\n        '\\u0205': 'e',\r\n        '\\u0207': 'e',\r\n        '\\u1EB9': 'e',\r\n        '\\u1EC7': 'e',\r\n        '\\u0229': 'e',\r\n        '\\u1E1D': 'e',\r\n        '\\u0119': 'e',\r\n        '\\u1E19': 'e',\r\n        '\\u1E1B': 'e',\r\n        '\\u0247': 'e',\r\n        '\\u025B': 'e',\r\n        '\\u01DD': 'e',\r\n        '\\u24D5': 'f',\r\n        '\\uFF46': 'f',\r\n        '\\u1E1F': 'f',\r\n        '\\u0192': 'f',\r\n        '\\uA77C': 'f',\r\n        '\\u24D6': 'g',\r\n        '\\uFF47': 'g',\r\n        '\\u01F5': 'g',\r\n        '\\u011D': 'g',\r\n        '\\u1E21': 'g',\r\n        '\\u011F': 'g',\r\n        '\\u0121': 'g',\r\n        '\\u01E7': 'g',\r\n        '\\u0123': 'g',\r\n        '\\u01E5': 'g',\r\n        '\\u0260': 'g',\r\n        '\\uA7A1': 'g',\r\n        '\\u1D79': 'g',\r\n        '\\uA77F': 'g',\r\n        '\\u24D7': 'h',\r\n        '\\uFF48': 'h',\r\n        '\\u0125': 'h',\r\n        '\\u1E23': 'h',\r\n        '\\u1E27': 'h',\r\n        '\\u021F': 'h',\r\n        '\\u1E25': 'h',\r\n        '\\u1E29': 'h',\r\n        '\\u1E2B': 'h',\r\n        '\\u1E96': 'h',\r\n        '\\u0127': 'h',\r\n        '\\u2C68': 'h',\r\n        '\\u2C76': 'h',\r\n        '\\u0265': 'h',\r\n        '\\u0195': 'hv',\r\n        '\\u24D8': 'i',\r\n        '\\uFF49': 'i',\r\n        '\\u00EC': 'i',\r\n        '\\u00ED': 'i',\r\n        '\\u00EE': 'i',\r\n        '\\u0129': 'i',\r\n        '\\u012B': 'i',\r\n        '\\u012D': 'i',\r\n        '\\u00EF': 'i',\r\n        '\\u1E2F': 'i',\r\n        '\\u1EC9': 'i',\r\n        '\\u01D0': 'i',\r\n        '\\u0209': 'i',\r\n        '\\u020B': 'i',\r\n        '\\u1ECB': 'i',\r\n        '\\u012F': 'i',\r\n        '\\u1E2D': 'i',\r\n        '\\u0268': 'i',\r\n        '\\u0131': 'i',\r\n        '\\u24D9': 'j',\r\n        '\\uFF4A': 'j',\r\n        '\\u0135': 'j',\r\n        '\\u01F0': 'j',\r\n        '\\u0249': 'j',\r\n        '\\u24DA': 'k',\r\n        '\\uFF4B': 'k',\r\n        '\\u1E31': 'k',\r\n        '\\u01E9': 'k',\r\n        '\\u1E33': 'k',\r\n        '\\u0137': 'k',\r\n        '\\u1E35': 'k',\r\n        '\\u0199': 'k',\r\n        '\\u2C6A': 'k',\r\n        '\\uA741': 'k',\r\n        '\\uA743': 'k',\r\n        '\\uA745': 'k',\r\n        '\\uA7A3': 'k',\r\n        '\\u24DB': 'l',\r\n        '\\uFF4C': 'l',\r\n        '\\u0140': 'l',\r\n        '\\u013A': 'l',\r\n        '\\u013E': 'l',\r\n        '\\u1E37': 'l',\r\n        '\\u1E39': 'l',\r\n        '\\u013C': 'l',\r\n        '\\u1E3D': 'l',\r\n        '\\u1E3B': 'l',\r\n        '\\u017F': 'l',\r\n        '\\u0142': 'l',\r\n        '\\u019A': 'l',\r\n        '\\u026B': 'l',\r\n        '\\u2C61': 'l',\r\n        '\\uA749': 'l',\r\n        '\\uA781': 'l',\r\n        '\\uA747': 'l',\r\n        '\\u01C9': 'lj',\r\n        '\\u24DC': 'm',\r\n        '\\uFF4D': 'm',\r\n        '\\u1E3F': 'm',\r\n        '\\u1E41': 'm',\r\n        '\\u1E43': 'm',\r\n        '\\u0271': 'm',\r\n        '\\u026F': 'm',\r\n        '\\u24DD': 'n',\r\n        '\\uFF4E': 'n',\r\n        '\\u01F9': 'n',\r\n        '\\u0144': 'n',\r\n        '\\u00F1': 'n',\r\n        '\\u1E45': 'n',\r\n        '\\u0148': 'n',\r\n        '\\u1E47': 'n',\r\n        '\\u0146': 'n',\r\n        '\\u1E4B': 'n',\r\n        '\\u1E49': 'n',\r\n        '\\u019E': 'n',\r\n        '\\u0272': 'n',\r\n        '\\u0149': 'n',\r\n        '\\uA791': 'n',\r\n        '\\uA7A5': 'n',\r\n        '\\u01CC': 'nj',\r\n        '\\u24DE': 'o',\r\n        '\\uFF4F': 'o',\r\n        '\\u00F2': 'o',\r\n        '\\u00F3': 'o',\r\n        '\\u00F4': 'o',\r\n        '\\u1ED3': 'o',\r\n        '\\u1ED1': 'o',\r\n        '\\u1ED7': 'o',\r\n        '\\u1ED5': 'o',\r\n        '\\u00F5': 'o',\r\n        '\\u1E4D': 'o',\r\n        '\\u022D': 'o',\r\n        '\\u1E4F': 'o',\r\n        '\\u014D': 'o',\r\n        '\\u1E51': 'o',\r\n        '\\u1E53': 'o',\r\n        '\\u014F': 'o',\r\n        '\\u022F': 'o',\r\n        '\\u0231': 'o',\r\n        '\\u00F6': 'o',\r\n        '\\u022B': 'o',\r\n        '\\u1ECF': 'o',\r\n        '\\u0151': 'o',\r\n        '\\u01D2': 'o',\r\n        '\\u020D': 'o',\r\n        '\\u020F': 'o',\r\n        '\\u01A1': 'o',\r\n        '\\u1EDD': 'o',\r\n        '\\u1EDB': 'o',\r\n        '\\u1EE1': 'o',\r\n        '\\u1EDF': 'o',\r\n        '\\u1EE3': 'o',\r\n        '\\u1ECD': 'o',\r\n        '\\u1ED9': 'o',\r\n        '\\u01EB': 'o',\r\n        '\\u01ED': 'o',\r\n        '\\u00F8': 'o',\r\n        '\\u01FF': 'o',\r\n        '\\u0254': 'o',\r\n        '\\uA74B': 'o',\r\n        '\\uA74D': 'o',\r\n        '\\u0275': 'o',\r\n        '\\u01A3': 'oi',\r\n        '\\u0223': 'ou',\r\n        '\\uA74F': 'oo',\r\n        '\\u24DF': 'p',\r\n        '\\uFF50': 'p',\r\n        '\\u1E55': 'p',\r\n        '\\u1E57': 'p',\r\n        '\\u01A5': 'p',\r\n        '\\u1D7D': 'p',\r\n        '\\uA751': 'p',\r\n        '\\uA753': 'p',\r\n        '\\uA755': 'p',\r\n        '\\u24E0': 'q',\r\n        '\\uFF51': 'q',\r\n        '\\u024B': 'q',\r\n        '\\uA757': 'q',\r\n        '\\uA759': 'q',\r\n        '\\u24E1': 'r',\r\n        '\\uFF52': 'r',\r\n        '\\u0155': 'r',\r\n        '\\u1E59': 'r',\r\n        '\\u0159': 'r',\r\n        '\\u0211': 'r',\r\n        '\\u0213': 'r',\r\n        '\\u1E5B': 'r',\r\n        '\\u1E5D': 'r',\r\n        '\\u0157': 'r',\r\n        '\\u1E5F': 'r',\r\n        '\\u024D': 'r',\r\n        '\\u027D': 'r',\r\n        '\\uA75B': 'r',\r\n        '\\uA7A7': 'r',\r\n        '\\uA783': 'r',\r\n        '\\u24E2': 's',\r\n        '\\uFF53': 's',\r\n        '\\u00DF': 's',\r\n        '\\u015B': 's',\r\n        '\\u1E65': 's',\r\n        '\\u015D': 's',\r\n        '\\u1E61': 's',\r\n        '\\u0161': 's',\r\n        '\\u1E67': 's',\r\n        '\\u1E63': 's',\r\n        '\\u1E69': 's',\r\n        '\\u0219': 's',\r\n        '\\u015F': 's',\r\n        '\\u023F': 's',\r\n        '\\uA7A9': 's',\r\n        '\\uA785': 's',\r\n        '\\u1E9B': 's',\r\n        '\\u24E3': 't',\r\n        '\\uFF54': 't',\r\n        '\\u1E6B': 't',\r\n        '\\u1E97': 't',\r\n        '\\u0165': 't',\r\n        '\\u1E6D': 't',\r\n        '\\u021B': 't',\r\n        '\\u0163': 't',\r\n        '\\u1E71': 't',\r\n        '\\u1E6F': 't',\r\n        '\\u0167': 't',\r\n        '\\u01AD': 't',\r\n        '\\u0288': 't',\r\n        '\\u2C66': 't',\r\n        '\\uA787': 't',\r\n        '\\uA729': 'tz',\r\n        '\\u24E4': 'u',\r\n        '\\uFF55': 'u',\r\n        '\\u00F9': 'u',\r\n        '\\u00FA': 'u',\r\n        '\\u00FB': 'u',\r\n        '\\u0169': 'u',\r\n        '\\u1E79': 'u',\r\n        '\\u016B': 'u',\r\n        '\\u1E7B': 'u',\r\n        '\\u016D': 'u',\r\n        '\\u00FC': 'u',\r\n        '\\u01DC': 'u',\r\n        '\\u01D8': 'u',\r\n        '\\u01D6': 'u',\r\n        '\\u01DA': 'u',\r\n        '\\u1EE7': 'u',\r\n        '\\u016F': 'u',\r\n        '\\u0171': 'u',\r\n        '\\u01D4': 'u',\r\n        '\\u0215': 'u',\r\n        '\\u0217': 'u',\r\n        '\\u01B0': 'u',\r\n        '\\u1EEB': 'u',\r\n        '\\u1EE9': 'u',\r\n        '\\u1EEF': 'u',\r\n        '\\u1EED': 'u',\r\n        '\\u1EF1': 'u',\r\n        '\\u1EE5': 'u',\r\n        '\\u1E73': 'u',\r\n        '\\u0173': 'u',\r\n        '\\u1E77': 'u',\r\n        '\\u1E75': 'u',\r\n        '\\u0289': 'u',\r\n        '\\u24E5': 'v',\r\n        '\\uFF56': 'v',\r\n        '\\u1E7D': 'v',\r\n        '\\u1E7F': 'v',\r\n        '\\u028B': 'v',\r\n        '\\uA75F': 'v',\r\n        '\\u028C': 'v',\r\n        '\\uA761': 'vy',\r\n        '\\u24E6': 'w',\r\n        '\\uFF57': 'w',\r\n        '\\u1E81': 'w',\r\n        '\\u1E83': 'w',\r\n        '\\u0175': 'w',\r\n        '\\u1E87': 'w',\r\n        '\\u1E85': 'w',\r\n        '\\u1E98': 'w',\r\n        '\\u1E89': 'w',\r\n        '\\u2C73': 'w',\r\n        '\\u24E7': 'x',\r\n        '\\uFF58': 'x',\r\n        '\\u1E8B': 'x',\r\n        '\\u1E8D': 'x',\r\n        '\\u24E8': 'y',\r\n        '\\uFF59': 'y',\r\n        '\\u1EF3': 'y',\r\n        '\\u00FD': 'y',\r\n        '\\u0177': 'y',\r\n        '\\u1EF9': 'y',\r\n        '\\u0233': 'y',\r\n        '\\u1E8F': 'y',\r\n        '\\u00FF': 'y',\r\n        '\\u1EF7': 'y',\r\n        '\\u1E99': 'y',\r\n        '\\u1EF5': 'y',\r\n        '\\u01B4': 'y',\r\n        '\\u024F': 'y',\r\n        '\\u1EFF': 'y',\r\n        '\\u24E9': 'z',\r\n        '\\uFF5A': 'z',\r\n        '\\u017A': 'z',\r\n        '\\u1E91': 'z',\r\n        '\\u017C': 'z',\r\n        '\\u017E': 'z',\r\n        '\\u1E93': 'z',\r\n        '\\u1E95': 'z',\r\n        '\\u01B6': 'z',\r\n        '\\u0225': 'z',\r\n        '\\u0240': 'z',\r\n        '\\u2C6C': 'z',\r\n        '\\uA763': 'z',\r\n        '\\u0386': '\\u0391',\r\n        '\\u0388': '\\u0395',\r\n        '\\u0389': '\\u0397',\r\n        '\\u038A': '\\u0399',\r\n        '\\u03AA': '\\u0399',\r\n        '\\u038C': '\\u039F',\r\n        '\\u038E': '\\u03A5',\r\n        '\\u03AB': '\\u03A5',\r\n        '\\u038F': '\\u03A9',\r\n        '\\u03AC': '\\u03B1',\r\n        '\\u03AD': '\\u03B5',\r\n        '\\u03AE': '\\u03B7',\r\n        '\\u03AF': '\\u03B9',\r\n        '\\u03CA': '\\u03B9',\r\n        '\\u0390': '\\u03B9',\r\n        '\\u03CC': '\\u03BF',\r\n        '\\u03CD': '\\u03C5',\r\n        '\\u03CB': '\\u03C5',\r\n        '\\u03B0': '\\u03C5',\r\n        '\\u03C9': '\\u03C9',\r\n        '\\u03C2': '\\u03C3'\r\n    };\r\n    DataUtil.fnOperators = {\r\n        /**\r\n         * Returns true when the actual input is equal to the given input.\r\n         * @param  {string|number|boolean} actual\r\n         * @param  {string|number|boolean} expected\r\n         * @param  {boolean} ignoreCase?\r\n         * @param  {boolean} ignoreAccent?\r\n         */\r\n        equal: function (actual, expected, ignoreCase, ignoreAccent) {\r\n            if (ignoreAccent) {\r\n                actual = DataUtil.ignoreDiacritics(actual);\r\n                expected = DataUtil.ignoreDiacritics(expected);\r\n            }\r\n            if (ignoreCase) {\r\n                return DataUtil.toLowerCase(actual) === DataUtil.toLowerCase(expected);\r\n            }\r\n            return actual === expected;\r\n        },\r\n        /**\r\n         * Returns true when the actual input is not equal to the given input.\r\n         * @param  {string|number|boolean} actual\r\n         * @param  {string|number|boolean} expected\r\n         * @param  {boolean} ignoreCase?\r\n         */\r\n        notequal: function (actual, expected, ignoreCase, ignoreAccent) {\r\n            if (ignoreAccent) {\r\n                actual = DataUtil.ignoreDiacritics(actual);\r\n                expected = DataUtil.ignoreDiacritics(expected);\r\n            }\r\n            return !DataUtil.fnOperators.equal(actual, expected, ignoreCase);\r\n        },\r\n        /**\r\n         * Returns true when the actual input is less than to the given input.\r\n         * @param  {string|number|boolean} actual\r\n         * @param  {string|number|boolean} expected\r\n         * @param  {boolean} ignoreCase?\r\n         */\r\n        lessthan: function (actual, expected, ignoreCase) {\r\n            if (ignoreCase) {\r\n                return DataUtil.toLowerCase(actual) < DataUtil.toLowerCase(expected);\r\n            }\r\n            return actual < expected;\r\n        },\r\n        /**\r\n         * Returns true when the actual input is greater than to the given input.\r\n         * @param  {string|number|boolean} actual\r\n         * @param  {string|number|boolean} expected\r\n         * @param  {boolean} ignoreCase?\r\n         */\r\n        greaterthan: function (actual, expected, ignoreCase) {\r\n            if (ignoreCase) {\r\n                return DataUtil.toLowerCase(actual) > DataUtil.toLowerCase(expected);\r\n            }\r\n            return actual > expected;\r\n        },\r\n        /**\r\n         * Returns true when the actual input is less than or equal to the given input.\r\n         * @param  {string|number|boolean} actual\r\n         * @param  {string|number|boolean} expected\r\n         * @param  {boolean} ignoreCase?\r\n         */\r\n        lessthanorequal: function (actual, expected, ignoreCase) {\r\n            if (ignoreCase) {\r\n                return DataUtil.toLowerCase(actual) <= DataUtil.toLowerCase(expected);\r\n            }\r\n            return actual <= expected;\r\n        },\r\n        /**\r\n         * Returns true when the actual input is greater than or equal to the given input.\r\n         * @param  {string|number|boolean} actual\r\n         * @param  {string|number|boolean} expected\r\n         * @param  {boolean} ignoreCase?\r\n         */\r\n        greaterthanorequal: function (actual, expected, ignoreCase) {\r\n            if (ignoreCase) {\r\n                return DataUtil.toLowerCase(actual) >= DataUtil.toLowerCase(expected);\r\n            }\r\n            return actual >= expected;\r\n        },\r\n        /**\r\n         * Returns true when the actual input contains the given string.\r\n         * @param  {string|number} actual\r\n         * @param  {string|number} expected\r\n         * @param  {boolean} ignoreCase?\r\n         */\r\n        contains: function (actual, expected, ignoreCase, ignoreAccent) {\r\n            if (ignoreAccent) {\r\n                actual = DataUtil.ignoreDiacritics(actual);\r\n                expected = DataUtil.ignoreDiacritics(expected);\r\n            }\r\n            if (ignoreCase) {\r\n                return !isNullOrUndefined(actual) && !isNullOrUndefined(expected) &&\r\n                    DataUtil.toLowerCase(actual).indexOf(DataUtil.toLowerCase(expected)) !== -1;\r\n            }\r\n            return !isNullOrUndefined(actual) && !isNullOrUndefined(expected) &&\r\n                actual.toString().indexOf(expected) !== -1;\r\n        },\r\n        /**\r\n         * Returns true when the given input value is not null.\r\n         * @param  {string|number} actual\r\n         * @returns boolean\r\n         */\r\n        notnull: function (actual) {\r\n            return actual !== null;\r\n        },\r\n        /**\r\n         * Returns true when the given input value is null.\r\n         * @param  {string|number} actual\r\n         * @returns boolean\r\n         */\r\n        isnull: function (actual) {\r\n            return actual === null;\r\n        },\r\n        /**\r\n         * Returns true when the actual input starts with the given string\r\n         * @param  {string} actual\r\n         * @param  {string} expected\r\n         * @param  {boolean} ignoreCase?\r\n         */\r\n        startswith: function (actual, expected, ignoreCase, ignoreAccent) {\r\n            if (ignoreAccent) {\r\n                actual = DataUtil.ignoreDiacritics(actual);\r\n                expected = DataUtil.ignoreDiacritics(expected);\r\n            }\r\n            if (ignoreCase) {\r\n                return actual && expected && DataUtil.startsWith(DataUtil.toLowerCase(actual), DataUtil.toLowerCase(expected));\r\n            }\r\n            return actual && expected && DataUtil.startsWith(actual, expected);\r\n        },\r\n        /**\r\n         * Returns true when the actual input ends with the given string.\r\n         * @param  {string} actual\r\n         * @param  {string} expected\r\n         * @param  {boolean} ignoreCase?\r\n         */\r\n        endswith: function (actual, expected, ignoreCase, ignoreAccent) {\r\n            if (ignoreAccent) {\r\n                actual = DataUtil.ignoreDiacritics(actual);\r\n                expected = DataUtil.ignoreDiacritics(expected);\r\n            }\r\n            if (ignoreCase) {\r\n                return actual && expected && DataUtil.endsWith(DataUtil.toLowerCase(actual), DataUtil.toLowerCase(expected));\r\n            }\r\n            return actual && expected && DataUtil.endsWith(actual, expected);\r\n        },\r\n        /**\r\n         * It will return the filter operator based on the filter symbol.\r\n         * @param  {string} operator\r\n         * @hidden\r\n         */\r\n        processSymbols: function (operator) {\r\n            var fnName = DataUtil.operatorSymbols[operator];\r\n            if (fnName) {\r\n                var fn = DataUtil.fnOperators[fnName];\r\n                return fn;\r\n            }\r\n            return DataUtil.throwError('Query - Process Operator : Invalid operator');\r\n        },\r\n        /**\r\n         * It will return the valid filter operator based on the specified operators.\r\n         * @param  {string} operator\r\n         * @hidden\r\n         */\r\n        processOperator: function (operator) {\r\n            var fn = DataUtil.fnOperators[operator];\r\n            if (fn) {\r\n                return fn;\r\n            }\r\n            return DataUtil.fnOperators.processSymbols(operator);\r\n        }\r\n    };\r\n    /**\r\n     * To perform the parse operation on JSON data, like convert to string from JSON or convert to JSON from string.\r\n     */\r\n    DataUtil.parse = {\r\n        /**\r\n         * Parse the given string to the plain JavaScript object.\r\n         * @param  {string|Object|Object[]} jsonText\r\n         */\r\n        parseJson: function (jsonText) {\r\n            if (typeof jsonText === 'string') {\r\n                jsonText = JSON.parse(jsonText, DataUtil.parse.jsonReviver);\r\n            }\r\n            else if (jsonText instanceof Array) {\r\n                DataUtil.parse.iterateAndReviveArray(jsonText);\r\n            }\r\n            else if (typeof jsonText === 'object' && jsonText !== null) {\r\n                DataUtil.parse.iterateAndReviveJson(jsonText);\r\n            }\r\n            return jsonText;\r\n        },\r\n        /**\r\n         * It will perform on array of values.\r\n         * @param  {string[]|Object[]} array\r\n         * @hidden\r\n         */\r\n        iterateAndReviveArray: function (array) {\r\n            for (var i = 0; i < array.length; i++) {\r\n                if (typeof array[i] === 'object' && array[i] !== null) {\r\n                    DataUtil.parse.iterateAndReviveJson(array[i]);\r\n                }\r\n                else if (typeof array[i] === 'string' && !/^[\\s]*\\[|^[\\s]*\\{(.)+:|\\\"/g.test(array[i])) {\r\n                    array[i] = DataUtil.parse.jsonReviver('', array[i]);\r\n                }\r\n                else {\r\n                    array[i] = DataUtil.parse.parseJson(array[i]);\r\n                }\r\n            }\r\n        },\r\n        /**\r\n         * It will perform on JSON values\r\n         * @param  {JSON} json\r\n         * @hidden\r\n         */\r\n        iterateAndReviveJson: function (json) {\r\n            var value;\r\n            var keys = Object.keys(json);\r\n            for (var _i = 0, keys_2 = keys; _i < keys_2.length; _i++) {\r\n                var prop = keys_2[_i];\r\n                if (DataUtil.startsWith(prop, '__')) {\r\n                    continue;\r\n                }\r\n                value = json[prop];\r\n                if (typeof value === 'object') {\r\n                    if (value instanceof Array) {\r\n                        DataUtil.parse.iterateAndReviveArray(value);\r\n                    }\r\n                    else if (value) {\r\n                        DataUtil.parse.iterateAndReviveJson(value);\r\n                    }\r\n                }\r\n                else {\r\n                    json[prop] = DataUtil.parse.jsonReviver(json[prop], value);\r\n                }\r\n            }\r\n        },\r\n        /**\r\n         * It will perform on JSON values\r\n         * @param  {string} field\r\n         * @param  {string|Date} value\r\n         * @hidden\r\n         */\r\n        jsonReviver: function (field, value) {\r\n            var dupValue = value;\r\n            if (typeof value === 'string') {\r\n                var ms = /^\\/Date\\(([+-]?[0-9]+)([+-][0-9]{4})?\\)\\/$/.exec(value);\r\n                if (ms) {\r\n                    return DataUtil.dateParse.toTimeZone(new Date(parseInt(ms[1], 10)), DataUtil.serverTimezoneOffset, true);\r\n                }\r\n                else if (/^(\\d{4}\\-\\d\\d\\-\\d\\d([tT][\\d:\\.]*){1})([zZ]|([+\\-])(\\d\\d):?(\\d\\d))?$/.test(value)) {\r\n                    var arr = dupValue.split(/[^0-9]/);\r\n                    value = DataUtil.dateParse\r\n                        .toTimeZone(new Date(parseInt(arr[0], 10), parseInt(arr[1], 10) - 1, parseInt(arr[2], 10), parseInt(arr[3], 10), parseInt(arr[4], 10), parseInt(arr[5], 10)), DataUtil.serverTimezoneOffset, true);\r\n                }\r\n            }\r\n            return value;\r\n        },\r\n        /**\r\n         * Check wheather the given value is JSON or not.\r\n         * @param  {Object[]} jsonData\r\n         */\r\n        isJson: function (jsonData) {\r\n            if (typeof jsonData[0] === 'string') {\r\n                return jsonData;\r\n            }\r\n            return DataUtil.parse.parseJson(jsonData);\r\n        },\r\n        /**\r\n         * Checks wheather the given value is GUID or not.\r\n         * @param  {string} value\r\n         */\r\n        isGuid: function (value) {\r\n            var regex = /[A-Fa-f0-9]{8}(?:-[A-Fa-f0-9]{4}){3}-[A-Fa-f0-9]{12}/i;\r\n            var match = regex.exec(value);\r\n            return match != null;\r\n        },\r\n        /**\r\n         * The method used to replace the value based on the type.\r\n         * @param  {Object} value\r\n         * @param  {boolean} stringify\r\n         * @hidden\r\n         */\r\n        replacer: function (value, stringify) {\r\n            if (DataUtil.isPlainObject(value)) {\r\n                return DataUtil.parse.jsonReplacer(value, stringify);\r\n            }\r\n            if (value instanceof Array) {\r\n                return DataUtil.parse.arrayReplacer(value);\r\n            }\r\n            if (value instanceof Date) {\r\n                return DataUtil.parse.jsonReplacer({ val: value }, stringify).val;\r\n            }\r\n            return value;\r\n        },\r\n        /**\r\n         * It will replace the JSON value.\r\n         * @param  {string} key\r\n         * @param  {Object} val\r\n         * @hidden\r\n         */\r\n        jsonReplacer: function (val, stringify) {\r\n            var value;\r\n            var keys = Object.keys(val);\r\n            for (var _i = 0, keys_3 = keys; _i < keys_3.length; _i++) {\r\n                var prop = keys_3[_i];\r\n                value = val[prop];\r\n                if (!(value instanceof Date)) {\r\n                    continue;\r\n                }\r\n                var d = value;\r\n                val[prop] = DataUtil.dateParse.toTimeZone(DataUtil.dateParse.addSelfOffset(d), DataUtil.serverTimezoneOffset).toJSON();\r\n            }\r\n            return val;\r\n        },\r\n        /**\r\n         * It will replace the Array of value.\r\n         * @param  {string} key\r\n         * @param  {Object[]} val\r\n         * @hidden\r\n         */\r\n        arrayReplacer: function (val) {\r\n            for (var i = 0; i < val.length; i++) {\r\n                if (DataUtil.isPlainObject(val[i])) {\r\n                    val[i] = DataUtil.parse.jsonReplacer(val[i]);\r\n                }\r\n                else if (val[i] instanceof Date) {\r\n                    val[i] = DataUtil.parse.jsonReplacer({ date: val[i] }).date;\r\n                }\r\n            }\r\n            return val;\r\n        }\r\n    };\r\n    /**\r\n     * @hidden\r\n     */\r\n    DataUtil.dateParse = {\r\n        addSelfOffset: function (input) {\r\n            return new Date(+input - (input.getTimezoneOffset() * 60000));\r\n        },\r\n        toUTC: function (input) {\r\n            return new Date(+input + (input.getTimezoneOffset() * 60000));\r\n        },\r\n        toTimeZone: function (input, offset, utc) {\r\n            if (offset === null) {\r\n                return input;\r\n            }\r\n            var unix = utc ? DataUtil.dateParse.toUTC(input) : input;\r\n            return new Date(+unix - (offset * 3600000));\r\n        },\r\n        toLocalTime: function (input) {\r\n            var datefn = input;\r\n            var timeZone = -datefn.getTimezoneOffset();\r\n            var differenceString = timeZone >= 0 ? '+' : '-';\r\n            var localtimefn = function (num) {\r\n                var norm = Math.floor(Math.abs(num));\r\n                return (norm < 10 ? '0' : '') + norm;\r\n            };\r\n            var val = datefn.getFullYear() + '-' + localtimefn(datefn.getMonth() + 1) + '-' + localtimefn(datefn.getDate()) +\r\n                'T' + localtimefn(datefn.getHours()) +\r\n                ':' + localtimefn(datefn.getMinutes()) +\r\n                ':' + localtimefn(datefn.getSeconds()) +\r\n                differenceString + localtimefn(timeZone / 60) +\r\n                ':' + localtimefn(timeZone % 60);\r\n            return val;\r\n        }\r\n    };\r\n    return DataUtil;\r\n}());\r\nexport { DataUtil };\r\n",null]}