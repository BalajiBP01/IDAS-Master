{"remainingRequest":"H:\\IDAS Admin\\SW Code Backup\\Inspirit.IDAS_new_v3_23-10-2019\\Inspirit.IDAS\\Inspirit.IDAS.Admin\\ClientApp\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js??ref--3-1!H:\\IDAS Admin\\SW Code Backup\\Inspirit.IDAS_new_v3_23-10-2019\\Inspirit.IDAS\\Inspirit.IDAS.Admin\\ClientApp\\node_modules\\@syncfusion\\ej2-data\\src\\manager.js","dependencies":[{"path":"H:\\IDAS Admin\\SW Code Backup\\Inspirit.IDAS_new_v3_23-10-2019\\Inspirit.IDAS\\Inspirit.IDAS.Admin\\ClientApp\\node_modules\\@syncfusion\\ej2-data\\src\\manager.js","mtime":499175100000},{"path":"H:\\IDAS Admin\\SW Code Backup\\Inspirit.IDAS_new_v3_23-10-2019\\Inspirit.IDAS\\Inspirit.IDAS.Admin\\ClientApp\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1510942300000},{"path":"H:\\IDAS Admin\\SW Code Backup\\Inspirit.IDAS_new_v3_23-10-2019\\Inspirit.IDAS\\Inspirit.IDAS.Admin\\ClientApp\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js","mtime":1518061566000}],"contextDependencies":[],"result":["import { Ajax } from '@syncfusion/ej2-base';\r\nimport { extend, isNullOrUndefined } from '@syncfusion/ej2-base';\r\nimport { DataUtil } from './util';\r\nimport { Query } from './query';\r\nimport { ODataAdaptor, JsonAdaptor, CacheAdaptor, RemoteSaveAdaptor } from './adaptors';\r\n/**\r\n * DataManager is used to manage and manipulate relational data.\r\n */\r\nvar DataManager = /*@__PURE__*/ (function () {\r\n    /**\r\n     * Constructor for DataManager class\r\n     * @param  {DataOptions|JSON[]} dataSource?\r\n     * @param  {Query} query?\r\n     * @param  {AdaptorOptions|string} adaptor?\r\n     * @hidden\r\n     */\r\n    function DataManager(dataSource, query, adaptor) {\r\n        var _this = this;\r\n        /** @hidden */\r\n        this.dateParse = true;\r\n        this.requests = [];\r\n        if (!dataSource && !this.dataSource) {\r\n            dataSource = [];\r\n        }\r\n        adaptor = adaptor || dataSource.adaptor;\r\n        var data;\r\n        if (dataSource instanceof Array) {\r\n            data = {\r\n                json: dataSource,\r\n                offline: true\r\n            };\r\n        }\r\n        else if (typeof dataSource === 'object') {\r\n            if (!dataSource.json) {\r\n                dataSource.json = [];\r\n            }\r\n            data = {\r\n                url: dataSource.url,\r\n                insertUrl: dataSource.insertUrl,\r\n                removeUrl: dataSource.removeUrl,\r\n                updateUrl: dataSource.updateUrl,\r\n                crudUrl: dataSource.crudUrl,\r\n                batchUrl: dataSource.batchUrl,\r\n                json: dataSource.json,\r\n                headers: dataSource.headers,\r\n                accept: dataSource.accept,\r\n                data: dataSource.data,\r\n                timeTillExpiration: dataSource.timeTillExpiration,\r\n                cachingPageSize: dataSource.cachingPageSize,\r\n                enableCaching: dataSource.enableCaching,\r\n                requestType: dataSource.requestType,\r\n                key: dataSource.key,\r\n                crossDomain: dataSource.crossDomain,\r\n                jsonp: dataSource.jsonp,\r\n                dataType: dataSource.dataType,\r\n                offline: dataSource.offline !== undefined ? dataSource.offline\r\n                    : dataSource.adaptor instanceof RemoteSaveAdaptor ? false : dataSource.url ? false : true,\r\n                requiresFormat: dataSource.requiresFormat\r\n            };\r\n        }\r\n        else {\r\n            DataUtil.throwError('DataManager: Invalid arguments');\r\n        }\r\n        if (data.requiresFormat === undefined && !DataUtil.isCors()) {\r\n            data.requiresFormat = isNullOrUndefined(data.crossDomain) ? true : data.crossDomain;\r\n        }\r\n        if (data.dataType === undefined) {\r\n            data.dataType = 'json';\r\n        }\r\n        this.dataSource = data;\r\n        this.defaultQuery = query;\r\n        if (data.url && data.offline && !data.json.length) {\r\n            this.isDataAvailable = false;\r\n            this.adaptor = adaptor || new ODataAdaptor();\r\n            this.dataSource.offline = false;\r\n            this.ready = this.executeQuery(query || new Query());\r\n            this.ready.then(function (e) {\r\n                _this.dataSource.offline = true;\r\n                _this.isDataAvailable = true;\r\n                data.json = e.result;\r\n                _this.adaptor = new JsonAdaptor();\r\n            });\r\n        }\r\n        else {\r\n            this.adaptor = data.offline ? new JsonAdaptor() : new ODataAdaptor();\r\n        }\r\n        if (!data.jsonp && this.adaptor instanceof ODataAdaptor) {\r\n            data.jsonp = 'callback';\r\n        }\r\n        this.adaptor = adaptor || this.adaptor;\r\n        if (data.enableCaching) {\r\n            this.adaptor = new CacheAdaptor(this.adaptor, data.timeTillExpiration, data.cachingPageSize);\r\n        }\r\n        return this;\r\n    }\r\n    /**\r\n     * Overrides DataManager's default query with given query.\r\n     * @param  {Query} query - Defines the new default query.\r\n     */\r\n    DataManager.prototype.setDefaultQuery = function (query) {\r\n        this.defaultQuery = query;\r\n        return this;\r\n    };\r\n    /**\r\n     * Executes the given query with local data source.\r\n     * @param  {Query} query - Defines the query to retrieve data.\r\n     */\r\n    DataManager.prototype.executeLocal = function (query) {\r\n        if (!this.defaultQuery && !(query instanceof Query)) {\r\n            DataUtil.throwError('DataManager - executeLocal() : A query is required to execute');\r\n        }\r\n        if (!this.dataSource.json) {\r\n            DataUtil.throwError('DataManager - executeLocal() : Json data is required to execute');\r\n        }\r\n        query = query || this.defaultQuery;\r\n        var result = this.adaptor.processQuery(this, query);\r\n        if (query.subQuery) {\r\n            var from = query.subQuery.fromTable;\r\n            var lookup = query.subQuery.lookups;\r\n            var res = query.isCountRequired ? result.result :\r\n                result;\r\n            if (lookup && lookup instanceof Array) {\r\n                DataUtil.buildHierarchy(query.subQuery.fKey, from, res, lookup, query.subQuery.key);\r\n            }\r\n            for (var j = 0; j < res.length; j++) {\r\n                if (res[j][from] instanceof Array) {\r\n                    res[j] = extend({}, {}, res[j]);\r\n                    res[j][from] = this.adaptor.processResponse(query.subQuery.using(new DataManager(res[j][from].slice(0))).executeLocal(), this, query);\r\n                }\r\n            }\r\n        }\r\n        return this.adaptor.processResponse(result, this, query);\r\n    };\r\n    /**\r\n     * Executes the given query with either local or remote data source.\r\n     * It will be executed as asynchronously and returns Promise object which will be resolved or rejected after action completed.\r\n     * @param  {Query|Function} query - Defines the query to retrieve data.\r\n     * @param  {Function} done - Defines the callback function and triggers when the Promise is resolved.\r\n     * @param  {Function} fail - Defines the callback function and triggers when the Promise is rejected.\r\n     * @param  {Function} always - Defines the callback function and triggers when the Promise is resolved or rejected.\r\n     */\r\n    DataManager.prototype.executeQuery = function (query, done, fail, always) {\r\n        var _this = this;\r\n        if (typeof query === 'function') {\r\n            always = fail;\r\n            fail = done;\r\n            done = query;\r\n            query = null;\r\n        }\r\n        if (!query) {\r\n            query = this.defaultQuery;\r\n        }\r\n        if (!(query instanceof Query)) {\r\n            DataUtil.throwError('DataManager - executeQuery() : A query is required to execute');\r\n        }\r\n        var deffered = new Deferred();\r\n        var args = { query: query };\r\n        if (!this.dataSource.offline && (this.dataSource.url !== undefined && this.dataSource.url !== '')) {\r\n            var result = this.adaptor.processQuery(this, query);\r\n            this.makeRequest(result, deffered, args, query);\r\n        }\r\n        else {\r\n            DataManager.nextTick(function () {\r\n                var res = _this.executeLocal(query);\r\n                args = DataManager.getDeferedArgs(query, res, args);\r\n                deffered.resolve(args);\r\n            });\r\n        }\r\n        if (done || fail) {\r\n            deffered.promise.then(done, fail);\r\n        }\r\n        if (always) {\r\n            deffered.promise.then(always, always);\r\n        }\r\n        return deffered.promise;\r\n    };\r\n    DataManager.getDeferedArgs = function (query, result, args) {\r\n        if (query.isCountRequired) {\r\n            args.result = result.result;\r\n            args.count = result.count;\r\n            args.aggregates = result.aggregates;\r\n        }\r\n        else {\r\n            args.result = result;\r\n        }\r\n        return args;\r\n    };\r\n    DataManager.nextTick = function (fn) {\r\n        (window.setImmediate || window.setTimeout)(fn, 0);\r\n    };\r\n    DataManager.prototype.extendRequest = function (url, fnSuccess, fnFail) {\r\n        return extend({}, {\r\n            type: 'GET',\r\n            dataType: this.dataSource.dataType,\r\n            crossDomain: this.dataSource.crossDomain,\r\n            jsonp: this.dataSource.jsonp,\r\n            cache: true,\r\n            processData: false,\r\n            onSuccess: fnSuccess,\r\n            onFailure: fnFail\r\n        }, url);\r\n    };\r\n    DataManager.prototype.makeRequest = function (url, deffered, args, query) {\r\n        var _this = this;\r\n        var isSelector = !!query.subQuerySelector;\r\n        var fnFail = function (e) {\r\n            args.error = e;\r\n            deffered.reject(args);\r\n        };\r\n        var process = function (data, count, xhr, request, actual, aggregates, virtualSelectRecords) {\r\n            args.xhr = xhr;\r\n            args.count = count ? parseInt(count.toString(), 10) : 0;\r\n            args.result = data;\r\n            args.request = request;\r\n            args.aggregates = aggregates;\r\n            args.actual = actual;\r\n            args.virtualSelectRecords = virtualSelectRecords;\r\n            deffered.resolve(args);\r\n        };\r\n        var fnQueryChild = function (data, selector) {\r\n            var subDeffer = new Deferred();\r\n            var childArgs = { parent: args };\r\n            query.subQuery.isChild = true;\r\n            var subUrl = _this.adaptor.processQuery(_this, query.subQuery, data ? _this.adaptor.processResponse(data) : selector);\r\n            var childReq = _this.makeRequest(subUrl, subDeffer, childArgs, query.subQuery);\r\n            if (!isSelector) {\r\n                subDeffer.then(function (subData) {\r\n                    if (data) {\r\n                        DataUtil.buildHierarchy(query.subQuery.fKey, query.subQuery.fromTable, data, subData, query.subQuery.key);\r\n                        process(data, subData.count, subData.xhr);\r\n                    }\r\n                }, fnFail);\r\n            }\r\n            return childReq;\r\n        };\r\n        var fnSuccess = function (data, request) {\r\n            if (request.httpRequest.getResponseHeader('Content-Type').indexOf('xml') === -1 && _this.dateParse) {\r\n                data = DataUtil.parse.parseJson(data);\r\n            }\r\n            var result = _this.adaptor.processResponse(data, _this, query, request.httpRequest, request);\r\n            var count = 0;\r\n            var aggregates = null;\r\n            var virtualSelectRecords = 'virtualSelectRecords';\r\n            var virtualRecords = data[virtualSelectRecords];\r\n            if (query.isCountRequired) {\r\n                count = result.count;\r\n                aggregates = result.aggregates;\r\n                result = result.result;\r\n            }\r\n            if (!query.subQuery) {\r\n                process(result, count, request.httpRequest, request.type, data, aggregates, virtualRecords);\r\n                return;\r\n            }\r\n            if (!isSelector) {\r\n                fnQueryChild(result, request);\r\n            }\r\n        };\r\n        var req = this.extendRequest(url, fnSuccess, fnFail);\r\n        var ajax = new Ajax(req);\r\n        ajax.beforeSend = function () {\r\n            _this.beforeSend(ajax.httpRequest, ajax);\r\n        };\r\n        req = ajax.send();\r\n        req.catch(function (e) { return true; }); // to handle failure remote requests.        \r\n        this.requests.push(ajax);\r\n        if (isSelector) {\r\n            var promise = void 0;\r\n            var res = query.subQuerySelector.call(this, { query: query.subQuery, parent: query });\r\n            if (res && res.length) {\r\n                promise = Promise.all([req, fnQueryChild(null, res)]);\r\n                promise.then(function () {\r\n                    var args = [];\r\n                    for (var _i = 0; _i < arguments.length; _i++) {\r\n                        args[_i] = arguments[_i];\r\n                    }\r\n                    var result = args[0];\r\n                    var pResult = _this.adaptor.processResponse(result[0], _this, query, _this.requests[0].httpRequest, _this.requests[0]);\r\n                    var count = 0;\r\n                    if (query.isCountRequired) {\r\n                        count = pResult.count;\r\n                        pResult = pResult.result;\r\n                    }\r\n                    var cResult = _this.adaptor.processResponse(result[1], _this, query.subQuery, _this.requests[1].httpRequest, _this.requests[1]);\r\n                    count = 0;\r\n                    if (query.subQuery.isCountRequired) {\r\n                        count = cResult.count;\r\n                        cResult = cResult.result;\r\n                    }\r\n                    DataUtil.buildHierarchy(query.subQuery.fKey, query.subQuery.fromTable, pResult, cResult, query.subQuery.key);\r\n                    isSelector = false;\r\n                    process(pResult, count, _this.requests[0].httpRequest);\r\n                });\r\n            }\r\n            else {\r\n                isSelector = false;\r\n            }\r\n        }\r\n        return req;\r\n    };\r\n    DataManager.prototype.beforeSend = function (request, settings) {\r\n        this.adaptor.beforeSend(this, request, settings);\r\n        var headers = this.dataSource.headers;\r\n        var props;\r\n        for (var i = 0; headers && i < headers.length; i++) {\r\n            props = [];\r\n            var keys = Object.keys(headers[i]);\r\n            for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {\r\n                var prop = keys_1[_i];\r\n                props.push(prop);\r\n                request.setRequestHeader(prop, headers[i][prop]);\r\n            }\r\n        }\r\n    };\r\n    /**\r\n     * Save bulk changes to the given table name.\r\n     * User can add a new record, edit an existing record, and delete a record at the same time.\r\n     * If the datasource from remote, then updated in a single post.\r\n     * @param  {Object} changes - Defines the CrudOptions.\r\n     * @param  {string} key - Defines the column field.\r\n     * @param  {string|Query} tableName - Defines the table name.\r\n     * @param  {Query} query - Sets default query for the DataManager.\r\n     */\r\n    DataManager.prototype.saveChanges = function (changes, key, tableName, query, original) {\r\n        var _this = this;\r\n        if (tableName instanceof Query) {\r\n            query = tableName;\r\n            tableName = null;\r\n        }\r\n        var args = {\r\n            url: tableName,\r\n            key: key || this.dataSource.key\r\n        };\r\n        var req = this.adaptor.batchRequest(this, changes, args, query, original);\r\n        if (this.dataSource.offline) {\r\n            return req;\r\n        }\r\n        var deff = new Deferred();\r\n        var ajax = new Ajax(req);\r\n        ajax.beforeSend = function () {\r\n            _this.beforeSend(ajax.httpRequest, ajax);\r\n        };\r\n        ajax.onSuccess = function (data, request) {\r\n            deff.resolve(_this.adaptor.processResponse(data, _this, null, request.httpRequest, request, changes, args));\r\n        };\r\n        ajax.onFailure = function (e) {\r\n            deff.reject([{ error: e }]);\r\n        };\r\n        ajax.send().catch(function (e) { return true; }); // to handle the failure requests.        \r\n        return deff.promise;\r\n    };\r\n    /**\r\n     * Inserts new record in the given table.\r\n     * @param  {Object} data - Defines the data to insert.\r\n     * @param  {string|Query} tableName - Defines the table name.\r\n     * @param  {Query} query - Sets default query for the DataManager.\r\n     */\r\n    DataManager.prototype.insert = function (data, tableName, query, position) {\r\n        if (tableName instanceof Query) {\r\n            query = tableName;\r\n            tableName = null;\r\n        }\r\n        var req = this.adaptor.insert(this, data, tableName, query, position);\r\n        if (this.dataSource.offline) {\r\n            return req;\r\n        }\r\n        return this.doAjaxRequest(req);\r\n    };\r\n    /**\r\n     * Removes data from the table with the given key.\r\n     * @param  {string} keyField - Defines the column field.\r\n     * @param  {Object} value - Defines the value to find the data in the specified column.\r\n     * @param  {string|Query} tableName - Defines the table name\r\n     * @param  {Query} query - Sets default query for the DataManager.\r\n     */\r\n    DataManager.prototype.remove = function (keyField, value, tableName, query) {\r\n        if (typeof value === 'object') {\r\n            value = value[keyField];\r\n        }\r\n        if (tableName instanceof Query) {\r\n            query = tableName;\r\n            tableName = null;\r\n        }\r\n        var res = this.adaptor.remove(this, keyField, value, tableName, query);\r\n        if (this.dataSource.offline) {\r\n            return res;\r\n        }\r\n        return this.doAjaxRequest(res);\r\n    };\r\n    /**\r\n     * Updates existing record in the given table.\r\n     * @param  {string} keyField - Defines the column field.\r\n     * @param  {Object} value - Defines the value to find the data in the specified column.\r\n     * @param  {string|Query} tableName - Defines the table name\r\n     * @param  {Query} query - Sets default query for the DataManager.\r\n     */\r\n    DataManager.prototype.update = function (keyField, value, tableName, query, original) {\r\n        if (tableName instanceof Query) {\r\n            query = tableName;\r\n            tableName = null;\r\n        }\r\n        var res = this.adaptor.update(this, keyField, value, tableName, query, original);\r\n        if (this.dataSource.offline) {\r\n            return res;\r\n        }\r\n        return this.doAjaxRequest(res);\r\n    };\r\n    DataManager.prototype.doAjaxRequest = function (res) {\r\n        var _this = this;\r\n        var defer = new Deferred();\r\n        res = extend({}, {\r\n            type: 'POST',\r\n            contentType: 'application/json; charset=utf-8',\r\n            processData: false\r\n        }, res);\r\n        var ajax = new Ajax(res);\r\n        ajax.beforeSend = function () {\r\n            _this.beforeSend(ajax.httpRequest, ajax);\r\n        };\r\n        ajax.onSuccess = function (record, request) {\r\n            try {\r\n                DataUtil.parse.parseJson(record);\r\n            }\r\n            catch (e) {\r\n                record = [];\r\n            }\r\n            record = _this.adaptor.processResponse(DataUtil.parse.parseJson(record), _this, null, request.httpRequest, request);\r\n            defer.resolve(record);\r\n        };\r\n        ajax.onFailure = function (e) {\r\n            defer.reject([{ error: e }]);\r\n        };\r\n        ajax.send().catch(function (e) { return true; }); // to handle the failure requests.\r\n        return defer.promise;\r\n    };\r\n    return DataManager;\r\n}());\r\nexport { DataManager };\r\n/**\r\n * Deferred is used to handle asynchronous operation.\r\n */\r\nvar Deferred = /*@__PURE__*/ (function () {\r\n    function Deferred() {\r\n        var _this = this;\r\n        /**\r\n         * Promise is an object that represents a value that may not be available yet, but will be resolved at some point in the future.\r\n         */\r\n        this.promise = new Promise(function (resolve, reject) {\r\n            _this.resolve = resolve;\r\n            _this.reject = reject;\r\n        });\r\n        /**\r\n         * Defines the callback function triggers when the Deferred object is resolved.\r\n         */\r\n        this.then = this.promise.then.bind(this.promise);\r\n        /**\r\n         * Defines the callback function triggers when the Deferred object is rejected.\r\n         */\r\n        this.catch = this.promise.catch.bind(this.promise);\r\n    }\r\n    return Deferred;\r\n}());\r\nexport { Deferred };\r\n",null]}