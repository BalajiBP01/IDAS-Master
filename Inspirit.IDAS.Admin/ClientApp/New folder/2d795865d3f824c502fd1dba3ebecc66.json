{"remainingRequest":"H:\\IDAS Admin\\SW Code Backup\\Inspirit.IDAS_new_v3_23-10-2019\\Inspirit.IDAS\\Inspirit.IDAS.Admin\\ClientApp\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js??ref--3-1!H:\\IDAS Admin\\SW Code Backup\\Inspirit.IDAS_new_v3_23-10-2019\\Inspirit.IDAS\\Inspirit.IDAS.Admin\\ClientApp\\node_modules\\@syncfusion\\ej2-richtexteditor\\src\\editor-manager\\plugin\\clearformat.js","dependencies":[{"path":"H:\\IDAS Admin\\SW Code Backup\\Inspirit.IDAS_new_v3_23-10-2019\\Inspirit.IDAS\\Inspirit.IDAS.Admin\\ClientApp\\node_modules\\@syncfusion\\ej2-richtexteditor\\src\\editor-manager\\plugin\\clearformat.js","mtime":499175100000},{"path":"H:\\IDAS Admin\\SW Code Backup\\Inspirit.IDAS_new_v3_23-10-2019\\Inspirit.IDAS\\Inspirit.IDAS.Admin\\ClientApp\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1510942300000},{"path":"H:\\IDAS Admin\\SW Code Backup\\Inspirit.IDAS_new_v3_23-10-2019\\Inspirit.IDAS\\Inspirit.IDAS.Admin\\ClientApp\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js","mtime":1518061566000}],"contextDependencies":[],"result":["/**\r\n * `Clear Format` module is used to handle Clear Format.\r\n */\r\nimport { NodeSelection } from './../../selection/index';\r\nimport { NodeCutter } from './nodecutter';\r\nimport { InsertMethods } from './insert-methods';\r\nimport { IsFormatted } from './isformatted';\r\nvar ClearFormat = /*@__PURE__*/ (function () {\r\n    function ClearFormat() {\r\n    }\r\n    ClearFormat.clear = function (docElement, endNode) {\r\n        var nodeSelection = new NodeSelection();\r\n        var nodeCutter = new NodeCutter();\r\n        var range = nodeSelection.getRange(docElement);\r\n        var isCollapsed = range.collapsed;\r\n        var nodes = nodeSelection.getInsertNodeCollection(range);\r\n        var save = nodeSelection.save(range, docElement);\r\n        if (!isCollapsed) {\r\n            var preNode = nodeCutter.GetSpliceNode(range, nodes[0]);\r\n            if (nodes.length === 1) {\r\n                nodeSelection.setSelectionContents(docElement, preNode);\r\n                range = nodeSelection.getRange(docElement);\r\n            }\r\n            else {\r\n                var lasNode = nodeCutter.GetSpliceNode(range, nodes[nodes.length - 1]);\r\n                nodeSelection.setSelectionText(docElement, preNode, lasNode, 0, (lasNode.nodeType === 3) ?\r\n                    lasNode.textContent.length : lasNode.childNodes.length);\r\n                range = nodeSelection.getRange(docElement);\r\n            }\r\n            var exactNodes = nodeSelection.getNodeCollection(range);\r\n            var cloneSelectNodes = exactNodes.slice();\r\n            this.clearInlines(nodeSelection.getSelectionNodes(cloneSelectNodes), cloneSelectNodes, nodeSelection.getRange(docElement), nodeCutter, endNode);\r\n            this.reSelection(docElement, save, exactNodes);\r\n            range = nodeSelection.getRange(docElement);\r\n            exactNodes = nodeSelection.getNodeCollection(range);\r\n            var cloneParentNodes = exactNodes.slice();\r\n            this.clearBlocks(docElement, cloneParentNodes, endNode, nodeCutter, nodeSelection);\r\n            this.reSelection(docElement, save, exactNodes);\r\n        }\r\n    };\r\n    ClearFormat.reSelection = function (docElement, save, exactNodes) {\r\n        var selectionNodes = save.getInsertNodes(exactNodes);\r\n        save.startContainer = save.getNodeArray(selectionNodes[0], true, docElement);\r\n        save.startOffset = 0;\r\n        save.endContainer = save.getNodeArray(selectionNodes[selectionNodes.length - 1], false, docElement);\r\n        var endIndexNode = selectionNodes[selectionNodes.length - 1];\r\n        save.endOffset = (endIndexNode.nodeType === 3) ? endIndexNode.textContent.length\r\n            : endIndexNode.childNodes.length;\r\n        save.restore();\r\n    };\r\n    ClearFormat.clearBlocks = function (docElement, nodes, endNode, nodeCutter, nodeSelection) {\r\n        var parentNodes = [];\r\n        for (var index = 0; index < nodes.length; index++) {\r\n            if (this.BLOCK_TAGS.indexOf(nodes[index].nodeName.toLocaleLowerCase()) > -1\r\n                && parentNodes.indexOf(nodes[index]) === -1) {\r\n                parentNodes.push(nodes[index]);\r\n            }\r\n            else if ((this.BLOCK_TAGS.indexOf(nodes[index].parentNode.nodeName.toLocaleLowerCase()) > -1)\r\n                && parentNodes.indexOf(nodes[index].parentNode) === -1\r\n                && endNode !== nodes[index].parentNode) {\r\n                parentNodes.push(nodes[index].parentNode);\r\n            }\r\n        }\r\n        parentNodes = this.spliceParent(parentNodes, nodes)[0];\r\n        parentNodes = this.removeParent(parentNodes);\r\n        this.unWrap(docElement, parentNodes, nodeCutter, nodeSelection);\r\n    };\r\n    ClearFormat.spliceParent = function (parentNodes, nodes) {\r\n        for (var index1 = 0; index1 < parentNodes.length; index1++) {\r\n            var len = parentNodes[index1].childNodes.length;\r\n            for (var index2 = 0; index2 < len; index2++) {\r\n                if ((nodes.indexOf(parentNodes[index1].childNodes[index2]) > 0)\r\n                    && (parentNodes[index1].childNodes[index2].childNodes.length > 0)) {\r\n                    nodes = this.spliceParent([parentNodes[index1].childNodes[index2]], nodes)[1];\r\n                }\r\n                if ((nodes.indexOf(parentNodes[index1].childNodes[index2]) <= -1) &&\r\n                    (parentNodes[index1].childNodes[index2].textContent.trim() !== '')) {\r\n                    for (var index3 = 0; index3 < len; index3++) {\r\n                        if (nodes.indexOf(parentNodes[index1].childNodes[index3]) > -1) {\r\n                            nodes.splice(nodes.indexOf(parentNodes[index1].childNodes[index3]), 1);\r\n                        }\r\n                    }\r\n                    index2 = parentNodes[index1].childNodes.length;\r\n                    var parentIndex = parentNodes.indexOf(parentNodes[index1].parentNode);\r\n                    var nodeIndex = nodes.indexOf(parentNodes[index1].parentNode);\r\n                    if (parentIndex > -1) {\r\n                        parentNodes.splice(parentIndex, 1);\r\n                    }\r\n                    if (nodeIndex > -1) {\r\n                        nodes.splice(nodeIndex, 1);\r\n                    }\r\n                    var elementIndex = nodes.indexOf(parentNodes[index1]);\r\n                    if (elementIndex > -1) {\r\n                        nodes.splice(elementIndex, 1);\r\n                    }\r\n                    parentNodes.splice(index1, 1);\r\n                    index1--;\r\n                }\r\n            }\r\n        }\r\n        return [parentNodes, nodes];\r\n    };\r\n    ClearFormat.removeChild = function (parentNodes, parentNode) {\r\n        var count = parentNode.childNodes.length;\r\n        if (count > 0) {\r\n            for (var index = 0; index < count; index++) {\r\n                if (parentNodes.indexOf(parentNode.childNodes[index]) > -1) {\r\n                    parentNodes = this.removeChild(parentNodes, parentNode.childNodes[index]);\r\n                    parentNodes.splice(parentNodes.indexOf(parentNode.childNodes[index]), 1);\r\n                }\r\n            }\r\n        }\r\n        return parentNodes;\r\n    };\r\n    ClearFormat.removeParent = function (parentNodes) {\r\n        for (var index = 0; index < parentNodes.length; index++) {\r\n            if (parentNodes.indexOf(parentNodes[index].parentNode) > -1) {\r\n                parentNodes = this.removeChild(parentNodes, parentNodes[index]);\r\n                parentNodes.splice(index, 1);\r\n                index--;\r\n            }\r\n        }\r\n        return parentNodes;\r\n    };\r\n    ClearFormat.unWrap = function (docElement, parentNodes, nodeCutter, nodeSelection) {\r\n        for (var index1 = 0; index1 < parentNodes.length; index1++) {\r\n            if (this.NONVALID_TAGS.indexOf(parentNodes[index1].nodeName.toLowerCase()) > -1\r\n                && parentNodes[index1].parentNode\r\n                && this.NONVALID_PARENT_TAGS.indexOf(parentNodes[index1].parentNode.nodeName.toLowerCase()) > -1) {\r\n                nodeSelection.setSelectionText(docElement, parentNodes[index1], parentNodes[index1], 0, parentNodes[index1].childNodes.length);\r\n                InsertMethods.unwrap(nodeCutter.GetSpliceNode(nodeSelection.getRange(docElement), parentNodes[index1].parentNode));\r\n            }\r\n            if (parentNodes[index1].nodeName.toLocaleLowerCase() !== 'p') {\r\n                if (this.NONVALID_PARENT_TAGS.indexOf(parentNodes[index1].nodeName.toLowerCase()) < 0\r\n                    && parentNodes[index1].parentNode.nodeName.toLocaleLowerCase() !== 'p'\r\n                    && !(parentNodes[index1].childNodes.length === 1\r\n                        && parentNodes[index1].childNodes[0].nodeName.toLocaleLowerCase() === 'p')) {\r\n                    InsertMethods.Wrap(parentNodes[index1], docElement.createElement('p'));\r\n                }\r\n                var childNodes = InsertMethods.unwrap(parentNodes[index1]);\r\n                if (childNodes.length === 1\r\n                    && childNodes[0].parentNode.nodeName.toLocaleLowerCase() === 'p') {\r\n                    InsertMethods.Wrap(parentNodes[index1], docElement.createElement('p'));\r\n                    InsertMethods.unwrap(parentNodes[index1]);\r\n                }\r\n                for (var index2 = 0; index2 < childNodes.length; index2++) {\r\n                    if (this.NONVALID_TAGS.indexOf(childNodes[index2].nodeName.toLowerCase()) > -1) {\r\n                        this.unWrap(docElement, [childNodes[index2]], nodeCutter, nodeSelection);\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                InsertMethods.Wrap(parentNodes[index1], docElement.createElement('p'));\r\n                InsertMethods.unwrap(parentNodes[index1]);\r\n            }\r\n        }\r\n    };\r\n    ClearFormat.clearInlines = function (textNodes, nodes, range, nodeCutter, endNode) {\r\n        for (var index = 0; index < textNodes.length; index++) {\r\n            if (textNodes[index].parentNode &&\r\n                IsFormatted.inlineTags.indexOf(textNodes[index].parentNode.nodeName.toLocaleLowerCase()) > -1) {\r\n                nodeCutter.GetSpliceNode(range, textNodes[index].parentNode);\r\n                this.removeInlineParent(textNodes[index].parentNode);\r\n            }\r\n        }\r\n    };\r\n    ClearFormat.removeInlineParent = function (textNodes) {\r\n        var nodes = InsertMethods.unwrap(textNodes);\r\n        for (var index = 0; index < nodes.length; index++) {\r\n            if (nodes[index].parentNode.childNodes.length === 1\r\n                && IsFormatted.inlineTags.indexOf(nodes[index].parentNode.nodeName.toLocaleLowerCase()) > -1) {\r\n                this.removeInlineParent(nodes[index].parentNode);\r\n            }\r\n            else if (IsFormatted.inlineTags.indexOf(nodes[index].nodeName.toLocaleLowerCase()) > -1) {\r\n                this.removeInlineParent(nodes[index]);\r\n            }\r\n        }\r\n    };\r\n    ClearFormat.BLOCK_TAGS = ['address', 'article', 'aside', 'blockquote',\r\n        'details', 'dd', 'div', 'dl', 'dt', 'fieldset', 'figcaption', 'figure', 'footer',\r\n        'form', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'header', 'hgroup', 'li', 'main', 'nav',\r\n        'noscript', 'ol', 'p', 'pre', 'section', 'table', 'tbody', 'td', 'tfoot', 'th',\r\n        'thead', 'tr', 'ul'];\r\n    ClearFormat.NONVALID_PARENT_TAGS = ['thead', 'tbody', 'ul', 'ol', 'table', 'tfoot'];\r\n    ClearFormat.NONVALID_TAGS = ['thead', 'tbody', 'figcaption', 'td', 'tr',\r\n        'th', 'tfoot', 'figcaption', 'li'];\r\n    return ClearFormat;\r\n}());\r\nexport { ClearFormat };\r\n",null]}