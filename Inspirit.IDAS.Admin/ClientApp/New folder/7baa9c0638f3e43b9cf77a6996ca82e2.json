{"remainingRequest":"D:\\Projects\\IDAS_TFS\\Inspirit.IDAS\\Inspirit.IDAS.Admin\\ClientApp\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js??ref--3-1!D:\\Projects\\IDAS_TFS\\Inspirit.IDAS\\Inspirit.IDAS.Admin\\ClientApp\\node_modules\\@syncfusion\\ej2-richtexteditor\\src\\markdown-parser\\plugin\\formats.js","dependencies":[{"path":"D:\\Projects\\IDAS_TFS\\Inspirit.IDAS\\Inspirit.IDAS.Admin\\ClientApp\\node_modules\\@syncfusion\\ej2-richtexteditor\\src\\markdown-parser\\plugin\\formats.js","mtime":499162500000},{"path":"D:\\Projects\\IDAS_TFS\\Inspirit.IDAS\\Inspirit.IDAS.Admin\\ClientApp\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1510929699000},{"path":"D:\\Projects\\IDAS_TFS\\Inspirit.IDAS\\Inspirit.IDAS.Admin\\ClientApp\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js","mtime":1518048966000}],"contextDependencies":[],"result":["import { extend } from '@syncfusion/ej2-base';\r\nimport * as EVENTS from './../../common/constant';\r\nimport * as CONSTANT from './../../markdown-parser/base/constant';\r\n/**\r\n * MDFormats internal plugin\r\n * @hidden\r\n */\r\nvar MDFormats = /*@__PURE__*/ (function () {\r\n    /**\r\n     * Constructor for creating the Formats plugin\r\n     * @hidden\r\n     */\r\n    function MDFormats(options) {\r\n        extend(this, this, options, true);\r\n        this.selection = this.parent.markdownSelection;\r\n        this.addEventListener();\r\n    }\r\n    MDFormats.prototype.addEventListener = function () {\r\n        this.parent.observer.on(EVENTS.FORMAT_TYPE, this.applyFormats, this);\r\n    };\r\n    MDFormats.prototype.applyFormats = function (e) {\r\n        e.subCommand = e.subCommand.toLowerCase();\r\n        var textArea = this.parent.element;\r\n        this.selection.save(textArea.selectionStart, textArea.selectionEnd);\r\n        var parents = this.selection.getSelectedParentPoints(textArea);\r\n        if (this.isAppliedFormat(parents) === e.subCommand) {\r\n            if (e.subCommand === 'pre') {\r\n                if (parents.length > 1) {\r\n                    this.applyCodeBlock(textArea, e, parents);\r\n                }\r\n                else {\r\n                    return;\r\n                }\r\n            }\r\n            this.cleanFormat(textArea);\r\n            this.restore(textArea, textArea.selectionStart, textArea.selectionEnd, e);\r\n            return;\r\n        }\r\n        if (e.subCommand === 'p') {\r\n            this.cleanFormat(textArea);\r\n            this.restore(textArea, textArea.selectionStart, textArea.selectionEnd, e);\r\n            return;\r\n        }\r\n        else {\r\n            this.cleanFormat(textArea, e.subCommand);\r\n        }\r\n        var start = textArea.selectionStart;\r\n        var end = textArea.selectionEnd;\r\n        var addedLength = 0;\r\n        parents = this.selection.getSelectedParentPoints(textArea);\r\n        if (e.subCommand === 'pre') {\r\n            if (parents.length > 1) {\r\n                this.applyCodeBlock(textArea, e, parents);\r\n            }\r\n            else {\r\n                extend(e, e, { subCommand: 'InlineCode' }, true);\r\n                this.parent.observer.notify(CONSTANT.selectionCommand, e);\r\n            }\r\n            return;\r\n        }\r\n        for (var i = 0; i < parents.length; i++) {\r\n            if (parents[i].text !== '' && !this.selection.isStartWith(parents[i].text, '\\\\' + this.syntax[e.subCommand])) {\r\n                parents[i].text = this.syntax[e.subCommand] + parents[i].text;\r\n                textArea.value = textArea.value.substr(0, parents[i].start) + parents[i].text + '\\n' +\r\n                    textArea.value.substr(parents[i].end, textArea.value.length);\r\n                start = i === 0 ? start + this.syntax[e.subCommand].length : start;\r\n                addedLength += this.syntax[e.subCommand].length;\r\n                if (parents.length !== 1) {\r\n                    for (var j = i; j < parents.length; j++) {\r\n                        parents[j].start = j !== 0 ?\r\n                            this.syntax[e.subCommand].length + parents[j].start : parents[j].start;\r\n                        parents[j].end = this.syntax[e.subCommand].length + parents[j].end;\r\n                    }\r\n                }\r\n            }\r\n            else if (parents[i].text === '' && i === 0) {\r\n                this.selection.save(start, end);\r\n                if (parents.length !== 1) {\r\n                    for (var j = i; j < parents.length; j++) {\r\n                        parents[j].start = j !== 0 ? 1 + parents[j].start : parents[j].start;\r\n                        parents[j].end = 1 + parents[j].end;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        this.restore(textArea, start, end + addedLength, e);\r\n    };\r\n    MDFormats.prototype.clearRegex = function () {\r\n        var regex = '';\r\n        var configKey = Object.keys(this.syntax);\r\n        for (var j = 0; j < configKey.length && configKey[j] !== 'pre' && configKey[j] !== 'p'; j++) {\r\n            regex += regex === '' ? '^(' + this.selection.replaceSpecialChar(this.syntax[configKey[j]].trim()) + ')' :\r\n                '|^(' + this.selection.replaceSpecialChar(this.syntax[configKey[j]].trim()) + ')';\r\n        }\r\n        return regex;\r\n    };\r\n    MDFormats.prototype.cleanFormat = function (textArea, command) {\r\n        var parents = this.selection.getSelectedParentPoints(textArea);\r\n        var start = textArea.selectionStart;\r\n        var end = textArea.selectionEnd;\r\n        var removeLength = 0;\r\n        if (this.selection.isClear(parents, this.clearRegex())) {\r\n            for (var i = 0; i < parents.length; i++) {\r\n                var configKey = Object.keys(this.syntax);\r\n                for (var j = 0; parents[i].text !== '' && j < configKey.length; j++) {\r\n                    var removeText = this.syntax[configKey[j]];\r\n                    if (configKey[j] === command) {\r\n                        continue;\r\n                    }\r\n                    var regex = new RegExp('^(' + this.selection.replaceSpecialChar(removeText) + ')', 'gim');\r\n                    if (regex.test(parents[i].text)) {\r\n                        parents[i].text = parents[i].text.replace(regex, '');\r\n                        textArea.value = textArea.value.substr(0, parents[i].start) + parents[i].text + '\\n' +\r\n                            textArea.value.substr(parents[i].end, textArea.value.length);\r\n                        start = i === 0 ? (start - (removeText.length)) > 0 ? start - (removeText.length) : 0 : start;\r\n                        removeLength += removeText.length;\r\n                        if (parents.length !== 1) {\r\n                            for (var k = 0; k < parents.length; k++) {\r\n                                parents[k].start = k !== 0 ?\r\n                                    parents[k].start - removeText.length : parents[k].start;\r\n                                parents[k].end = parents[k].end - removeText.length;\r\n                            }\r\n                        }\r\n                        break;\r\n                    }\r\n                }\r\n                if (parents[i].text === '' && i === 0) {\r\n                    this.selection.save(start, end);\r\n                    if (parents.length !== 1) {\r\n                        for (var j = i; j < parents.length; j++) {\r\n                            parents[j].start = j !== 0 ? 1 + parents[j].start : parents[j].start;\r\n                            parents[j].end = 1 + parents[j].end;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            this.restore(textArea, start, end - removeLength);\r\n        }\r\n    };\r\n    MDFormats.prototype.applyCodeBlock = function (textArea, event, parents) {\r\n        var command = event.subCommand;\r\n        var start = parents[0].start;\r\n        var end = parents[parents.length - 1].end;\r\n        var parentLines = this.selection.getAllParents(textArea.value);\r\n        var firstPrevText = parentLines[parents[0].line - 1];\r\n        var lastNextText = parentLines[(parents.length + 1) + 1];\r\n        var addedLength = 0;\r\n        if (!this.selection.isStartWith(firstPrevText, this.syntax.pre.split('\\n')[0]) &&\r\n            !this.selection.isStartWith(lastNextText, this.syntax.pre.split('\\n')[0])) {\r\n            var lines = textArea.value.substring(start, end).split('\\n');\r\n            var lastLine = lines[lines.length - 1] === '' ? '' : '\\n';\r\n            textArea.value = textArea.value.substr(0, start) + this.syntax[command] + textArea.value.substring(start, end) +\r\n                lastLine + this.syntax[command] +\r\n                textArea.value.substr(end, textArea.value.length);\r\n            start = this.selection.selectionStart + this.syntax[command].length;\r\n            end = this.selection.selectionEnd + this.syntax[command].length - 1;\r\n        }\r\n        else {\r\n            var cmd = this.syntax[command];\r\n            var selection = this.parent.markdownSelection.getSelectedInlinePoints(textArea);\r\n            var startNo = textArea.value.substr(0, textArea.selectionStart).lastIndexOf(cmd);\r\n            var endNo = textArea.value.substr(textArea.selectionEnd, textArea.selectionEnd).indexOf(cmd);\r\n            endNo = endNo + selection.end;\r\n            var repStartText = this.replaceAt(textArea.value.substr(0, selection.start), cmd, '', startNo, selection.start);\r\n            var repEndText = this.replaceAt(textArea.value.substr(selection.end, textArea.value.length), cmd, '', 0, endNo);\r\n            textArea.value = repStartText + selection.text + repEndText;\r\n            start = this.selection.selectionStart - cmd.length;\r\n            end = this.selection.selectionEnd - cmd.length;\r\n        }\r\n        this.restore(textArea, start, end, event);\r\n    };\r\n    MDFormats.prototype.replaceAt = function (input, search, replace, start, end) {\r\n        return input.slice(0, start)\r\n            + input.slice(start, end).replace(search, replace)\r\n            + input.slice(end);\r\n    };\r\n    MDFormats.prototype.restore = function (textArea, start, end, event) {\r\n        this.selection.save(start, end);\r\n        this.selection.restore(textArea);\r\n        if (event && event.callBack) {\r\n            event.callBack({\r\n                requestType: event.subCommand,\r\n                selectedText: this.selection.getSelectedText(textArea),\r\n                editorMode: 'Markdown',\r\n                event: event.event\r\n            });\r\n        }\r\n    };\r\n    MDFormats.prototype.isAppliedFormat = function (lines, documentNode) {\r\n        var format = 'p';\r\n        var configKey = Object.keys(this.syntax);\r\n        var keys = Object.keys(this.syntax);\r\n        var direction = this.parent.element.selectionDirection;\r\n        var checkLine = direction === 'backward' ? lines[0].text : lines[lines.length - 1].text;\r\n        for (var i = 0; !documentNode && i < keys.length; i++) {\r\n            if (keys[i] !== 'pre' && this.selection.isStartWith(checkLine, this.syntax[keys[i]])) {\r\n                format = keys[i];\r\n                break;\r\n            }\r\n            else if (keys[i] === 'pre') {\r\n                var parentLines = this.selection.getAllParents(this.parent.element.value);\r\n                var firstPrevText = parentLines[lines[0].line - 1];\r\n                var lastNextText = parentLines[lines.length + 1];\r\n                if (this.selection.isStartWith(firstPrevText, this.syntax[keys[i]].split('\\n')[0]) &&\r\n                    this.selection.isStartWith(lastNextText, this.syntax[keys[i]].split('\\n')[0])) {\r\n                    format = keys[i];\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        return format;\r\n    };\r\n    return MDFormats;\r\n}());\r\nexport { MDFormats };\r\n",null]}